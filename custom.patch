From d42095309577a428f720fa0724cd08293013be1e Mon Sep 17 00:00:00 2001
From: Daniel Liu <daniel17liu@gmail.com>
Date: Fri, 7 Mar 2025 11:19:42 -0800
Subject: [PATCH] i forgot what i changed

---
 config.def.h      |    5 +-
 config.def.h.orig |  188 --
 config.h          |    5 +-
 config.mk.orig    |   39 -
 drw.c.orig        |  451 ----
 drw.h.orig        |   58 -
 drw.o             |  Bin 13968 -> 13968 bytes
 dwm               |  Bin 82512 -> 82528 bytes
 dwm.c             | 5087 ++++++++++++++++++++++-----------------------
 dwm.c.orig        | 2774 ------------------------
 dwm.o             |  Bin 77288 -> 77448 bytes
 util.o            |  Bin 2224 -> 2224 bytes
 12 files changed, 2492 insertions(+), 6115 deletions(-)
 delete mode 100644 config.def.h.orig
 delete mode 100644 config.mk.orig
 delete mode 100644 drw.c.orig
 delete mode 100644 drw.h.orig
 delete mode 100644 dwm.c.orig

diff --git a/config.def.h b/config.def.h
index 8aeed0c..fbc4bf5 100644
--- a/config.def.h
+++ b/config.def.h
@@ -22,7 +22,8 @@ static const int topbar             = 0;     /* 0 means bottom bar */
 #define ICONSPACING 5 /* space between icon and title */
 static const unsigned int colorfultag = 1; /* 0 means use SchemeSel for selected tag */
 static const int focusonwheel       = 0;
-static const char *fonts[]          = { "Iosevka Term:size=14:style=Regular", "Material\\-Design\\-Iconic\\-Font:style=Design-Iconic-Font:size=16", "Iosevka Nerd Font Mono:size=14:style=Regular" };
+/* static const char *fonts[]          = { "Iosevka Aile:size=14:style=Regular", "Material\\-Design\\-Iconic\\-Font:style=Design-Iconic-Font:size=16", "Iosevka Nerd Font Mono:size=14:style=Regular" }; */
+static const char *fonts[]          = { "Iosevka Term:size=14:style=Regular", "Material\\-Design\\-Iconic\\-Font:style=Design-Iconic-Font:size=16" };
 static const char dmenufont[]       = "Iosevka Term:size=14";
 static const char col_gray1[] = "#020203";
 static const char col_gray2[] = "#1c252c";
@@ -100,7 +101,7 @@ static const char *dmenucmd[] = { "dmenu_run", "-m",  dmenumon,   "-fn", dmenufo
 static const char *termcmd[]  = { "wezterm", NULL };
 static const char *filecmd[]  = { "nemo", NULL };
 static const char *screenshotcmd[] = {
-    "screenshot", "area", NULL};
+    "/bin/sh", "-c", "maim -su | xclip -selection clipboard -t image/png", NULL};
 static const char *lockscreencmd[] = {"slock", NULL};
 
 /* Volume commands */
diff --git a/config.def.h.orig b/config.def.h.orig
deleted file mode 100644
index 2980390..0000000
--- a/config.def.h.orig
+++ /dev/null
@@ -1,188 +0,0 @@
-#include <X11/XF86keysym.h>
-/* See LICENSE file for copyright and license details. */
-
-/* appearance */
-static const unsigned int borderpx  = 2;        /* border pixel of windows */
-static const unsigned int barpadding = 6; static const unsigned int snap      = 32;       /* snap pixel */
-static const unsigned int gappih    = 8;       /* horiz inner gap between windows */
-static const unsigned int gappiv    = 8;       /* vert inner gap between windows */
-static const unsigned int gappoh    = 8;       /* horiz outer gap between windows and screen edge */
-static const unsigned int gappov    = 8;       /* vert outer gap between windows and screen edge */
-static const int smartgaps          = 0;        /* 1 means no outer gap when there is only one window */
-static const unsigned int systraypinning = 0;   /* 0: sloppy systray follows selected monitor, >0: pin systray to monitor X */
-static const unsigned int systrayonleft = 0;   	/* 0: systray in the right corner, >0: systray on left of status text */
-static const unsigned int systrayspacing = 6;   /* systray spacing */
-static const unsigned int systrayiconsize = 24; /* systray icon size in px */
-static const int systraypinningfailfirst = 1;   /* 1: if pinning fails, display systray on the first monitor, False: display systray on the last monitor*/
-static const int showsystray        = 1;     /* 0 means no systray */
-static const int showbar            = 1;     /* 0 means no bar */
-static const int topbar             = 0;     /* 0 means bottom bar */
-static const unsigned int colorfultag = 1; /* 0 means use SchemeSel for selected tag */
-static const int focusonwheel       = 0;
-static const char *fonts[]          = { "Iosevka Term:size=14:style=Regular", "Material\\-Design\\-Iconic\\-Font:style=Design-Iconic-Font:size=16" };
-static const char dmenufont[]       = "Iosevka Term:size=14";
-static const char col_gray1[] = "#020203";
-static const char col_gray2[] = "#1c252c";
-static const char col_gray3[] = "#6b7078";
-static const char col_gray4[] = "#e3e6eb";
-static const char col_red[] = "#e05f65";
-static const char col_orange[] = "#f1cf8a";
-static const char col_green[] = "#78dba9";
-static const char col_cyan[] = "#74bee9";
-static const char col_blue[] = "#70a5eb";
-static const char col_purple[] = "#c68aee";
-static const char col_borderbar[] = "#020203";
-static const char *colors[][3]      = {
-	/*               fg         bg         border   */
-	[SchemeNorm] = { col_cyan, col_gray1, col_gray1 },
-	[SchemeSel]  = { col_blue, col_gray1,  col_blue  },
-  [SchemeTag]        = { col_gray3, col_gray1, col_gray3 },
-  [SchemeTag1]       = { col_gray1, col_blue,  col_gray3 },
-  [SchemeTag2]       = { col_gray1, col_red,  col_gray3 },
-  [SchemeTag3]       = { col_gray1, col_orange,  col_gray3 },
-  [SchemeTag4]       = { col_gray1, col_green,  col_gray3 },
-  [SchemeTag5]       = { col_gray1, col_cyan,  col_gray3 },
-};
-
-/* tagging */
-static const char *tags[] = {"", "", "", "", ""};
-static const char *alttags[] = { "", "", "", "", "" };
-static const int tagschemes[] = { SchemeTag1, SchemeTag2, SchemeTag3,
-                                  SchemeTag4, SchemeTag5
-                                };
-
-static const unsigned int ulinepad	= 6;	/* horizontal padding between the underline and tag */
-static const unsigned int ulinestroke	= 2;	/* thickness / height of the underline */
-static const unsigned int ulinevoffset	= 0;	/* how far above the bottom of the bar the line should appear */
-static const int ulineall 		= 0;	/* 1 to show underline on all tags, 0 for just the active ones */
-
-static const Rule rules[] = {
-	/* xprop(1):
-	 *	WM_CLASS(STRING) = instance, class
-	 *	WM_NAME(STRING) = title
-	 */
-	/* class      instance    title       tags mask     isfloating   monitor */
-  {"Nemo", NULL, NULL, 0, 1, -1},
-  {"CEmu", NULL, NULL, 0, 1, -1},
-};
-
-/* layout(s) */
-static const float mfact     = 0.55; /* factor of master area size [0.05..0.95] */
-static const int nmaster     = 1;    /* number of clients in master area */
-static const int resizehints = 1;    /* 1 means respect size hints in tiled resizals */
-static const int lockfullscreen = 1; /* 1 will force focus on the fullscreen window */
-
-static const Layout layouts[] = {
-	/* symbol     arrange function */
-	{ "",      tile },    /* first entry is default */
-	{ "",      NULL },    /* no layout function means floating behavior */
-	{ "",      monocle },
-};
-
-/* key definitions */
-#define MODKEY Mod4Mask
-#define TAGKEYS(KEY,TAG) \
-	{ MODKEY,                       KEY,      view,           {.ui = 1 << TAG} }, \
-	{ MODKEY|ControlMask,           KEY,      toggleview,     {.ui = 1 << TAG} }, \
-	{ MODKEY|ShiftMask,             KEY,      tag,            {.ui = 1 << TAG} }, \
-	{ MODKEY|ControlMask|ShiftMask, KEY,      toggletag,      {.ui = 1 << TAG} },
-
-/* helper for spawning shell commands in the pre dwm-5.0 fashion */
-#define SHCMD(cmd) { .v = (const char*[]){ "/bin/sh", "-c", cmd, NULL } }
-
-/* commands */
-static char dmenumon[2] = "0"; /* component of dmenucmd, manipulated in spawn() */
-static const char *dmenucmd[] = { "dmenu_run", "-m",  dmenumon,   "-fn", dmenufont, "-nb", col_gray1, "-nf", col_gray3,   "-sb", col_gray1, "-sf", col_blue, "-p",  "Search:", NULL};
-static const char *termcmd[]  = { "wezterm", NULL };
-static const char *filecmd[]  = { "nemo", NULL };
-static const char *screenshotcmd[] = {
-    "screenshot", "area", NULL};
-static const char *lockscreencmd[] = {"slock", NULL};
-
-/* Volume commands */
-static const char *upvol[] = {"pamixer", "-i", "5", NULL};
-static const char *downvol[] = {"pamixer", "-d", "5", NULL};
-static const char *mutevol[] = {"pamixer", "-t", NULL};
-
-/*Brightness commands*/
-static const char *upbri[] = {"xbacklight", "-inc", "5", NULL};
-static const char *downbri[] = {"xbacklight", "-dec", "5", NULL};
-
-static const Key keys[] = {
-	/* modifier                     key        function        argument */
-	{ MODKEY,                       XK_p,      spawn,          {.v = dmenucmd } },
-	{ MODKEY,                       XK_Return, spawn,          {.v = termcmd } },
-	{ MODKEY | ShiftMask,                       XK_f, spawn,          {.v = filecmd } },
-  {MODKEY | ShiftMask, XK_s, spawn, {.v = screenshotcmd}},
-  {MODKEY | Mod1Mask, XK_x, spawn, {.v = lockscreencmd}},
-  {0, XF86XK_AudioLowerVolume, spawn, {.v = downvol}},
-  {0, XF86XK_AudioMute, spawn, {.v = mutevol}},
-  {0, XF86XK_AudioRaiseVolume, spawn, {.v = upvol}},
-  {0, XF86XK_MonBrightnessUp, spawn, {.v = upbri}},
-  {0, XF86XK_MonBrightnessDown, spawn, {.v = downbri}},
-	{ MODKEY,                       XK_b,      togglebar,      {0} },
-	{ MODKEY,                       XK_j,      focusstack,     {.i = +1 } },
-	{ MODKEY,                       XK_k,      focusstack,     {.i = -1 } },
-	{ MODKEY,                       XK_i,      incnmaster,     {.i = +1 } },
-	{ MODKEY,                       XK_d,      incnmaster,     {.i = -1 } },
-	{ MODKEY,                       XK_h,      setmfact,       {.f = -0.05} },
-	{ MODKEY,                       XK_l,      setmfact,       {.f = +0.05} },
-	{ MODKEY|Mod4Mask,              XK_h,      incrgaps,       {.i = +1 } },
-	{ MODKEY|Mod4Mask,              XK_l,      incrgaps,       {.i = -1 } },
-	{ MODKEY|Mod4Mask|ShiftMask,    XK_h,      incrogaps,      {.i = +1 } },
-	{ MODKEY|Mod4Mask|ShiftMask,    XK_l,      incrogaps,      {.i = -1 } },
-	{ MODKEY|Mod4Mask|ControlMask,  XK_h,      incrigaps,      {.i = +1 } },
-	{ MODKEY|Mod4Mask|ControlMask,  XK_l,      incrigaps,      {.i = -1 } },
-	{ MODKEY|Mod4Mask,              XK_0,      togglegaps,     {0} },
-	{ MODKEY|Mod4Mask|ShiftMask,    XK_0,      defaultgaps,    {0} },
-	{ MODKEY,                       XK_y,      incrihgaps,     {.i = +1 } },
-	{ MODKEY,                       XK_o,      incrihgaps,     {.i = -1 } },
-	{ MODKEY|ControlMask,           XK_y,      incrivgaps,     {.i = +1 } },
-	{ MODKEY|ControlMask,           XK_o,      incrivgaps,     {.i = -1 } },
-	{ MODKEY|Mod4Mask,              XK_y,      incrohgaps,     {.i = +1 } },
-	{ MODKEY|Mod4Mask,              XK_o,      incrohgaps,     {.i = -1 } },
-	{ MODKEY|ShiftMask,             XK_y,      incrovgaps,     {.i = +1 } },
-	{ MODKEY|ShiftMask,             XK_o,      incrovgaps,     {.i = -1 } },
-	{ MODKEY,                       XK_z,      zoom,           {0} },
-	{ MODKEY,                       XK_Tab,    view,           {0} },
-	{ MODKEY|ShiftMask,             XK_c,      killclient,     {0} },
-	{ MODKEY,                       XK_t,      setlayout,      {.v = &layouts[0]} },
-	{ MODKEY,                       XK_f,      setlayout,      {.v = &layouts[1]} },
-	{ MODKEY,                       XK_m,      setlayout,      {.v = &layouts[2]} },
-	{ MODKEY,                       XK_space,  setlayout,      {0} },
-	{ MODKEY|ShiftMask,             XK_space,  togglefloating, {0} },
-	{ MODKEY,                       XK_0,      view,           {.ui = ~0 } },
-	{ MODKEY|ShiftMask,             XK_0,      tag,            {.ui = ~0 } },
-	{ MODKEY,                       XK_Left,  focusmon,       {.i = -1 } },
-	{ MODKEY,                       XK_Right, focusmon,       {.i = +1 } },
-	{ MODKEY|ShiftMask,             XK_Left,  tagmon,         {.i = -1 } },
-	{ MODKEY|ShiftMask,             XK_Right, tagmon,         {.i = +1 } },
-	TAGKEYS(                        XK_1,                      0)
-	TAGKEYS(                        XK_2,                      1)
-	TAGKEYS(                        XK_3,                      2)
-	TAGKEYS(                        XK_4,                      3)
-	TAGKEYS(                        XK_5,                      4)
-	TAGKEYS(                        XK_6,                      5)
-	TAGKEYS(                        XK_7,                      6)
-	TAGKEYS(                        XK_8,                      7)
-	TAGKEYS(                        XK_9,                      8)
-	{ MODKEY|ShiftMask,             XK_q,      quit,           {0} },
-};
-
-/* button definitions */
-/* click can be ClkTagBar, ClkLtSymbol, ClkStatusText, ClkWinTitle, ClkClientWin, or ClkRootWin */
-static const Button buttons[] = {
-	/* click                event mask      button          function        argument */
-	{ ClkTagBar,            MODKEY,         Button1,        tag,            {0} },
-	{ ClkTagBar,            MODKEY,         Button3,        toggletag,      {0} },
-	{ ClkWinTitle,          0,              Button2,        zoom,           {0} },
-	{ ClkStatusText,        0,              Button2,        spawn,          {.v = termcmd } },
-	{ ClkClientWin,         MODKEY,         Button1,        movemouse,      {0} },
-	{ ClkClientWin,         MODKEY,         Button2,        togglefloating, {0} },
-	{ ClkClientWin,         MODKEY,         Button3,        resizemouse,    {0} },
-	{ ClkTagBar,            0,              Button1,        view,           {0} },
-	{ ClkTagBar,            0,              Button3,        toggleview,     {0} },
-	{ ClkTagBar,            MODKEY,         Button1,        tag,            {0} },
-	{ ClkTagBar,            MODKEY,         Button3,        toggletag,      {0} },
-};
-
diff --git a/config.h b/config.h
index 8aeed0c..fbc4bf5 100644
--- a/config.h
+++ b/config.h
@@ -22,7 +22,8 @@ static const int topbar             = 0;     /* 0 means bottom bar */
 #define ICONSPACING 5 /* space between icon and title */
 static const unsigned int colorfultag = 1; /* 0 means use SchemeSel for selected tag */
 static const int focusonwheel       = 0;
-static const char *fonts[]          = { "Iosevka Term:size=14:style=Regular", "Material\\-Design\\-Iconic\\-Font:style=Design-Iconic-Font:size=16", "Iosevka Nerd Font Mono:size=14:style=Regular" };
+/* static const char *fonts[]          = { "Iosevka Aile:size=14:style=Regular", "Material\\-Design\\-Iconic\\-Font:style=Design-Iconic-Font:size=16", "Iosevka Nerd Font Mono:size=14:style=Regular" }; */
+static const char *fonts[]          = { "Iosevka Term:size=14:style=Regular", "Material\\-Design\\-Iconic\\-Font:style=Design-Iconic-Font:size=16" };
 static const char dmenufont[]       = "Iosevka Term:size=14";
 static const char col_gray1[] = "#020203";
 static const char col_gray2[] = "#1c252c";
@@ -100,7 +101,7 @@ static const char *dmenucmd[] = { "dmenu_run", "-m",  dmenumon,   "-fn", dmenufo
 static const char *termcmd[]  = { "wezterm", NULL };
 static const char *filecmd[]  = { "nemo", NULL };
 static const char *screenshotcmd[] = {
-    "screenshot", "area", NULL};
+    "/bin/sh", "-c", "maim -su | xclip -selection clipboard -t image/png", NULL};
 static const char *lockscreencmd[] = {"slock", NULL};
 
 /* Volume commands */
diff --git a/config.mk.orig b/config.mk.orig
deleted file mode 100644
index 8efca9a..0000000
--- a/config.mk.orig
+++ /dev/null
@@ -1,39 +0,0 @@
-# dwm version
-VERSION = 6.5
-
-# Customize below to fit your system
-
-# paths
-PREFIX = /usr/local
-MANPREFIX = ${PREFIX}/share/man
-
-X11INC = /usr/X11R6/include
-X11LIB = /usr/X11R6/lib
-
-# Xinerama, comment if you don't want it
-XINERAMALIBS  = -lXinerama
-XINERAMAFLAGS = -DXINERAMA
-
-# freetype
-FREETYPELIBS = -lfontconfig -lXft
-FREETYPEINC = /usr/include/freetype2
-# OpenBSD (uncomment)
-#FREETYPEINC = ${X11INC}/freetype2
-#MANPREFIX = ${PREFIX}/man
-
-# includes and libs
-INCS = -I${X11INC} -I${FREETYPEINC}
-LIBS = -L${X11LIB} -lX11 ${XINERAMALIBS} ${FREETYPELIBS}
-
-# flags
-CPPFLAGS = -D_DEFAULT_SOURCE -D_BSD_SOURCE -D_XOPEN_SOURCE=700L -DVERSION=\"${VERSION}\" ${XINERAMAFLAGS}
-#CFLAGS   = -g -std=c99 -pedantic -Wall -O0 ${INCS} ${CPPFLAGS}
-CFLAGS   = -std=c99 -pedantic -Wall -Wno-deprecated-declarations -Os ${INCS} ${CPPFLAGS}
-LDFLAGS  = ${LIBS}
-
-# Solaris
-#CFLAGS = -fast ${INCS} -DVERSION=\"${VERSION}\"
-#LDFLAGS = ${LIBS}
-
-# compiler and linker
-CC = cc
diff --git a/drw.c.orig b/drw.c.orig
deleted file mode 100644
index d721380..0000000
--- a/drw.c.orig
+++ /dev/null
@@ -1,451 +0,0 @@
-/* See LICENSE file for copyright and license details. */
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <X11/Xlib.h>
-#include <X11/Xft/Xft.h>
-
-#include "drw.h"
-#include "util.h"
-
-#define UTF_INVALID 0xFFFD
-#define UTF_SIZ     4
-
-static const unsigned char utfbyte[UTF_SIZ + 1] = {0x80,    0, 0xC0, 0xE0, 0xF0};
-static const unsigned char utfmask[UTF_SIZ + 1] = {0xC0, 0x80, 0xE0, 0xF0, 0xF8};
-static const long utfmin[UTF_SIZ + 1] = {       0,    0,  0x80,  0x800,  0x10000};
-static const long utfmax[UTF_SIZ + 1] = {0x10FFFF, 0x7F, 0x7FF, 0xFFFF, 0x10FFFF};
-
-static long
-utf8decodebyte(const char c, size_t *i)
-{
-	for (*i = 0; *i < (UTF_SIZ + 1); ++(*i))
-		if (((unsigned char)c & utfmask[*i]) == utfbyte[*i])
-			return (unsigned char)c & ~utfmask[*i];
-	return 0;
-}
-
-static size_t
-utf8validate(long *u, size_t i)
-{
-	if (!BETWEEN(*u, utfmin[i], utfmax[i]) || BETWEEN(*u, 0xD800, 0xDFFF))
-		*u = UTF_INVALID;
-	for (i = 1; *u > utfmax[i]; ++i)
-		;
-	return i;
-}
-
-static size_t
-utf8decode(const char *c, long *u, size_t clen)
-{
-	size_t i, j, len, type;
-	long udecoded;
-
-	*u = UTF_INVALID;
-	if (!clen)
-		return 0;
-	udecoded = utf8decodebyte(c[0], &len);
-	if (!BETWEEN(len, 1, UTF_SIZ))
-		return 1;
-	for (i = 1, j = 1; i < clen && j < len; ++i, ++j) {
-		udecoded = (udecoded << 6) | utf8decodebyte(c[i], &type);
-		if (type)
-			return j;
-	}
-	if (j < len)
-		return 0;
-	*u = udecoded;
-	utf8validate(u, len);
-
-	return len;
-}
-
-Drw *
-drw_create(Display *dpy, int screen, Window root, unsigned int w, unsigned int h)
-{
-	Drw *drw = ecalloc(1, sizeof(Drw));
-
-	drw->dpy = dpy;
-	drw->screen = screen;
-	drw->root = root;
-	drw->w = w;
-	drw->h = h;
-	drw->drawable = XCreatePixmap(dpy, root, w, h, DefaultDepth(dpy, screen));
-	drw->gc = XCreateGC(dpy, root, 0, NULL);
-	XSetLineAttributes(dpy, drw->gc, 1, LineSolid, CapButt, JoinMiter);
-
-	return drw;
-}
-
-void
-drw_resize(Drw *drw, unsigned int w, unsigned int h)
-{
-	if (!drw)
-		return;
-
-	drw->w = w;
-	drw->h = h;
-	if (drw->drawable)
-		XFreePixmap(drw->dpy, drw->drawable);
-	drw->drawable = XCreatePixmap(drw->dpy, drw->root, w, h, DefaultDepth(drw->dpy, drw->screen));
-}
-
-void
-drw_free(Drw *drw)
-{
-	XFreePixmap(drw->dpy, drw->drawable);
-	XFreeGC(drw->dpy, drw->gc);
-	drw_fontset_free(drw->fonts);
-	free(drw);
-}
-
-/* This function is an implementation detail. Library users should use
- * drw_fontset_create instead.
- */
-static Fnt *
-xfont_create(Drw *drw, const char *fontname, FcPattern *fontpattern)
-{
-	Fnt *font;
-	XftFont *xfont = NULL;
-	FcPattern *pattern = NULL;
-
-	if (fontname) {
-		/* Using the pattern found at font->xfont->pattern does not yield the
-		 * same substitution results as using the pattern returned by
-		 * FcNameParse; using the latter results in the desired fallback
-		 * behaviour whereas the former just results in missing-character
-		 * rectangles being drawn, at least with some fonts. */
-		if (!(xfont = XftFontOpenName(drw->dpy, drw->screen, fontname))) {
-			fprintf(stderr, "error, cannot load font from name: '%s'\n", fontname);
-			return NULL;
-		}
-		if (!(pattern = FcNameParse((FcChar8 *) fontname))) {
-			fprintf(stderr, "error, cannot parse font name to pattern: '%s'\n", fontname);
-			XftFontClose(drw->dpy, xfont);
-			return NULL;
-		}
-	} else if (fontpattern) {
-		if (!(xfont = XftFontOpenPattern(drw->dpy, fontpattern))) {
-			fprintf(stderr, "error, cannot load font from pattern.\n");
-			return NULL;
-		}
-	} else {
-		die("no font specified.");
-	}
-
-	font = ecalloc(1, sizeof(Fnt));
-	font->xfont = xfont;
-	font->pattern = pattern;
-	font->h = xfont->ascent + xfont->descent;
-	font->dpy = drw->dpy;
-
-	return font;
-}
-
-static void
-xfont_free(Fnt *font)
-{
-	if (!font)
-		return;
-	if (font->pattern)
-		FcPatternDestroy(font->pattern);
-	XftFontClose(font->dpy, font->xfont);
-	free(font);
-}
-
-Fnt*
-drw_fontset_create(Drw* drw, const char *fonts[], size_t fontcount)
-{
-	Fnt *cur, *ret = NULL;
-	size_t i;
-
-	if (!drw || !fonts)
-		return NULL;
-
-	for (i = 1; i <= fontcount; i++) {
-		if ((cur = xfont_create(drw, fonts[fontcount - i], NULL))) {
-			cur->next = ret;
-			ret = cur;
-		}
-	}
-	return (drw->fonts = ret);
-}
-
-void
-drw_fontset_free(Fnt *font)
-{
-	if (font) {
-		drw_fontset_free(font->next);
-		xfont_free(font);
-	}
-}
-
-void
-drw_clr_create(Drw *drw, Clr *dest, const char *clrname)
-{
-	if (!drw || !dest || !clrname)
-		return;
-
-	if (!XftColorAllocName(drw->dpy, DefaultVisual(drw->dpy, drw->screen),
-	                       DefaultColormap(drw->dpy, drw->screen),
-	                       clrname, dest))
-		die("error, cannot allocate color '%s'", clrname);
-  dest->pixel |= 0xff << 24;
-}
-
-/* Wrapper to create color schemes. The caller has to call free(3) on the
- * returned color scheme when done using it. */
-Clr *
-drw_scm_create(Drw *drw, const char *clrnames[], size_t clrcount)
-{
-	size_t i;
-	Clr *ret;
-
-	/* need at least two colors for a scheme */
-	if (!drw || !clrnames || clrcount < 2 || !(ret = ecalloc(clrcount, sizeof(XftColor))))
-		return NULL;
-
-	for (i = 0; i < clrcount; i++)
-		drw_clr_create(drw, &ret[i], clrnames[i]);
-	return ret;
-}
-
-void
-drw_setfontset(Drw *drw, Fnt *set)
-{
-	if (drw)
-		drw->fonts = set;
-}
-
-void
-drw_setscheme(Drw *drw, Clr *scm)
-{
-	if (drw)
-		drw->scheme = scm;
-}
-
-void
-drw_rect(Drw *drw, int x, int y, unsigned int w, unsigned int h, int filled, int invert)
-{
-	if (!drw || !drw->scheme)
-		return;
-	XSetForeground(drw->dpy, drw->gc, invert ? drw->scheme[ColBg].pixel : drw->scheme[ColFg].pixel);
-	if (filled)
-		XFillRectangle(drw->dpy, drw->drawable, drw->gc, x, y, w, h);
-	else
-		XDrawRectangle(drw->dpy, drw->drawable, drw->gc, x, y, w - 1, h - 1);
-}
-
-int
-drw_text(Drw *drw, int x, int y, unsigned int w, unsigned int h, unsigned int lpad, const char *text, int invert)
-{
-	int i, ty, ellipsis_x = 0;
-	unsigned int tmpw, ew, ellipsis_w = 0, ellipsis_len;
-	XftDraw *d = NULL;
-	Fnt *usedfont, *curfont, *nextfont;
-	int utf8strlen, utf8charlen, render = x || y || w || h;
-	long utf8codepoint = 0;
-	const char *utf8str;
-	FcCharSet *fccharset;
-	FcPattern *fcpattern;
-	FcPattern *match;
-	XftResult result;
-	int charexists = 0, overflow = 0;
-	/* keep track of a couple codepoints for which we have no match. */
-	enum { nomatches_len = 64 };
-	static struct { long codepoint[nomatches_len]; unsigned int idx; } nomatches;
-	static unsigned int ellipsis_width = 0;
-
-	if (!drw || (render && (!drw->scheme || !w)) || !text || !drw->fonts)
-		return 0;
-
-	if (!render) {
-		w = invert ? invert : ~invert;
-	} else {
-		XSetForeground(drw->dpy, drw->gc, drw->scheme[invert ? ColFg : ColBg].pixel);
-		XFillRectangle(drw->dpy, drw->drawable, drw->gc, x, y, w, h);
-		d = XftDrawCreate(drw->dpy, drw->drawable,
-		                  DefaultVisual(drw->dpy, drw->screen),
-		                  DefaultColormap(drw->dpy, drw->screen));
-		x += lpad;
-		w -= lpad;
-	}
-
-	usedfont = drw->fonts;
-	if (!ellipsis_width && render)
-		ellipsis_width = drw_fontset_getwidth(drw, "...");
-	while (1) {
-		ew = ellipsis_len = utf8strlen = 0;
-		utf8str = text;
-		nextfont = NULL;
-		while (*text) {
-			utf8charlen = utf8decode(text, &utf8codepoint, UTF_SIZ);
-			for (curfont = drw->fonts; curfont; curfont = curfont->next) {
-				charexists = charexists || XftCharExists(drw->dpy, curfont->xfont, utf8codepoint);
-				if (charexists) {
-					drw_font_getexts(curfont, text, utf8charlen, &tmpw, NULL);
-					if (ew + ellipsis_width <= w) {
-						/* keep track where the ellipsis still fits */
-						ellipsis_x = x + ew;
-						ellipsis_w = w - ew;
-						ellipsis_len = utf8strlen;
-					}
-
-					if (ew + tmpw > w) {
-						overflow = 1;
-						/* called from drw_fontset_getwidth_clamp():
-						 * it wants the width AFTER the overflow
-						 */
-						if (!render)
-							x += tmpw;
-						else
-							utf8strlen = ellipsis_len;
-					} else if (curfont == usedfont) {
-						utf8strlen += utf8charlen;
-						text += utf8charlen;
-						ew += tmpw;
-					} else {
-						nextfont = curfont;
-					}
-					break;
-				}
-			}
-
-			if (overflow || !charexists || nextfont)
-				break;
-			else
-				charexists = 0;
-		}
-
-		if (utf8strlen) {
-			if (render) {
-				ty = y + (h - usedfont->h) / 2 + usedfont->xfont->ascent;
-				XftDrawStringUtf8(d, &drw->scheme[invert ? ColBg : ColFg],
-				                  usedfont->xfont, x, ty, (XftChar8 *)utf8str, utf8strlen);
-			}
-			x += ew;
-			w -= ew;
-		}
-		if (render && overflow)
-			drw_text(drw, ellipsis_x, y, ellipsis_w, h, 0, "...", invert);
-
-		if (!*text || overflow) {
-			break;
-		} else if (nextfont) {
-			charexists = 0;
-			usedfont = nextfont;
-		} else {
-			/* Regardless of whether or not a fallback font is found, the
-			 * character must be drawn. */
-			charexists = 1;
-
-			for (i = 0; i < nomatches_len; ++i) {
-				/* avoid calling XftFontMatch if we know we won't find a match */
-				if (utf8codepoint == nomatches.codepoint[i])
-					goto no_match;
-			}
-
-			fccharset = FcCharSetCreate();
-			FcCharSetAddChar(fccharset, utf8codepoint);
-
-			if (!drw->fonts->pattern) {
-				/* Refer to the comment in xfont_create for more information. */
-				die("the first font in the cache must be loaded from a font string.");
-			}
-
-			fcpattern = FcPatternDuplicate(drw->fonts->pattern);
-			FcPatternAddCharSet(fcpattern, FC_CHARSET, fccharset);
-			FcPatternAddBool(fcpattern, FC_SCALABLE, FcTrue);
-
-			FcConfigSubstitute(NULL, fcpattern, FcMatchPattern);
-			FcDefaultSubstitute(fcpattern);
-			match = XftFontMatch(drw->dpy, drw->screen, fcpattern, &result);
-
-			FcCharSetDestroy(fccharset);
-			FcPatternDestroy(fcpattern);
-
-			if (match) {
-				usedfont = xfont_create(drw, NULL, match);
-				if (usedfont && XftCharExists(drw->dpy, usedfont->xfont, utf8codepoint)) {
-					for (curfont = drw->fonts; curfont->next; curfont = curfont->next)
-						; /* NOP */
-					curfont->next = usedfont;
-				} else {
-					xfont_free(usedfont);
-					nomatches.codepoint[++nomatches.idx % nomatches_len] = utf8codepoint;
-no_match:
-					usedfont = drw->fonts;
-				}
-			}
-		}
-	}
-	if (d)
-		XftDrawDestroy(d);
-
-	return x + (render ? w : 0);
-}
-
-void
-drw_map(Drw *drw, Window win, int x, int y, unsigned int w, unsigned int h)
-{
-	if (!drw)
-		return;
-
-	XCopyArea(drw->dpy, drw->drawable, win, drw->gc, x, y, w, h, x, y);
-	XSync(drw->dpy, False);
-}
-
-unsigned int
-drw_fontset_getwidth(Drw *drw, const char *text)
-{
-	if (!drw || !drw->fonts || !text)
-		return 0;
-	return drw_text(drw, 0, 0, 0, 0, 0, text, 0);
-}
-
-unsigned int
-drw_fontset_getwidth_clamp(Drw *drw, const char *text, unsigned int n)
-{
-	unsigned int tmp = 0;
-	if (drw && drw->fonts && text && n)
-		tmp = drw_text(drw, 0, 0, 0, 0, 0, text, n);
-	return MIN(n, tmp);
-}
-
-void
-drw_font_getexts(Fnt *font, const char *text, unsigned int len, unsigned int *w, unsigned int *h)
-{
-	XGlyphInfo ext;
-
-	if (!font || !text)
-		return;
-
-	XftTextExtentsUtf8(font->dpy, font->xfont, (XftChar8 *)text, len, &ext);
-	if (w)
-		*w = ext.xOff;
-	if (h)
-		*h = font->h;
-}
-
-Cur *
-drw_cur_create(Drw *drw, int shape)
-{
-	Cur *cur;
-
-	if (!drw || !(cur = ecalloc(1, sizeof(Cur))))
-		return NULL;
-
-	cur->cursor = XCreateFontCursor(drw->dpy, shape);
-
-	return cur;
-}
-
-void
-drw_cur_free(Drw *drw, Cur *cursor)
-{
-	if (!cursor)
-		return;
-
-	XFreeCursor(drw->dpy, cursor->cursor);
-	free(cursor);
-}
diff --git a/drw.h.orig b/drw.h.orig
deleted file mode 100644
index 6471431..0000000
--- a/drw.h.orig
+++ /dev/null
@@ -1,58 +0,0 @@
-/* See LICENSE file for copyright and license details. */
-
-typedef struct {
-	Cursor cursor;
-} Cur;
-
-typedef struct Fnt {
-	Display *dpy;
-	unsigned int h;
-	XftFont *xfont;
-	FcPattern *pattern;
-	struct Fnt *next;
-} Fnt;
-
-enum { ColFg, ColBg, ColBorder }; /* Clr scheme index */
-typedef XftColor Clr;
-
-typedef struct {
-	unsigned int w, h;
-	Display *dpy;
-	int screen;
-	Window root;
-	Drawable drawable;
-	GC gc;
-	Clr *scheme;
-	Fnt *fonts;
-} Drw;
-
-/* Drawable abstraction */
-Drw *drw_create(Display *dpy, int screen, Window win, unsigned int w, unsigned int h);
-void drw_resize(Drw *drw, unsigned int w, unsigned int h);
-void drw_free(Drw *drw);
-
-/* Fnt abstraction */
-Fnt *drw_fontset_create(Drw* drw, const char *fonts[], size_t fontcount);
-void drw_fontset_free(Fnt* set);
-unsigned int drw_fontset_getwidth(Drw *drw, const char *text);
-unsigned int drw_fontset_getwidth_clamp(Drw *drw, const char *text, unsigned int n);
-void drw_font_getexts(Fnt *font, const char *text, unsigned int len, unsigned int *w, unsigned int *h);
-
-/* Colorscheme abstraction */
-void drw_clr_create(Drw *drw, Clr *dest, const char *clrname);
-Clr *drw_scm_create(Drw *drw, const char *clrnames[], size_t clrcount);
-
-/* Cursor abstraction */
-Cur *drw_cur_create(Drw *drw, int shape);
-void drw_cur_free(Drw *drw, Cur *cursor);
-
-/* Drawing context manipulation */
-void drw_setfontset(Drw *drw, Fnt *set);
-void drw_setscheme(Drw *drw, Clr *scm);
-
-/* Drawing functions */
-void drw_rect(Drw *drw, int x, int y, unsigned int w, unsigned int h, int filled, int invert);
-int drw_text(Drw *drw, int x, int y, unsigned int w, unsigned int h, unsigned int lpad, const char *text, int invert);
-
-/* Map functions */
-void drw_map(Drw *drw, Window win, int x, int y, unsigned int w, unsigned int h);
diff --git a/drw.o b/drw.o
index e93719bc4b39365b9dbfd41249ef07f4d7a4f833..020b40b0611586373dc560109724964a8aa7e7cd 100644
GIT binary patch
delta 16
YcmbP`J0W+&0U>5fLxatSh0ZDi06ORfk^lez

delta 16
YcmbP`J0W+&0U>4!1Jliih0ZDi06O;ul>h($

diff --git a/dwm b/dwm
index e12c3a33eda527a9fc064238cc39d5072cc58e5e..e19b11ffdacec8ba59b62e745261b75cb91ee38f 100755
GIT binary patch
delta 12140
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

delta 11941
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
HEbRXPVe*68

diff --git a/dwm.c b/dwm.c
index 1872f88..017b256 100644
--- a/dwm.c
+++ b/dwm.c
@@ -20,24 +20,24 @@
  *
  * To understand everything else, start reading main().
  */
+#include <X11/Xatom.h>
+#include <X11/Xlib.h>
+#include <X11/Xproto.h>
+#include <X11/Xutil.h>
+#include <X11/cursorfont.h>
+#include <X11/keysym.h>
 #include <errno.h>
+#include <limits.h>
 #include <locale.h>
 #include <signal.h>
 #include <stdarg.h>
+#include <stdint.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
-#include <unistd.h>
-#include <limits.h>
-#include <stdint.h>
 #include <sys/types.h>
 #include <sys/wait.h>
-#include <X11/cursorfont.h>
-#include <X11/keysym.h>
-#include <X11/Xatom.h>
-#include <X11/Xlib.h>
-#include <X11/Xproto.h>
-#include <X11/Xutil.h>
+#include <unistd.h>
 #ifdef XINERAMA
 #include <X11/extensions/Xinerama.h>
 #endif /* XINERAMA */
@@ -47,30 +47,34 @@
 #include "util.h"
 
 /* macros */
-#define BUTTONMASK              (ButtonPressMask|ButtonReleaseMask)
-#define CLEANMASK(mask)         (mask & ~(numlockmask|LockMask) & (ShiftMask|ControlMask|Mod1Mask|Mod2Mask|Mod3Mask|Mod4Mask|Mod5Mask))
-#define INTERSECT(x,y,w,h,m)    (MAX(0, MIN((x)+(w),(m)->wx+(m)->ww) - MAX((x),(m)->wx)) \
-                               * MAX(0, MIN((y)+(h),(m)->wy+(m)->wh) - MAX((y),(m)->wy)))
-#define ISVISIBLEONTAG(C, T)    ((C->tags & T))
-#define ISVISIBLE(C)            ISVISIBLEONTAG(C, C->mon->tagset[C->mon->seltags])
-#define LENGTH(X)               (sizeof X / sizeof X[0])
-#define MOUSEMASK               (BUTTONMASK|PointerMotionMask)
-#define WIDTH(X)                ((X)->w + 2 * (X)->bw)
-#define HEIGHT(X)               ((X)->h + 2 * (X)->bw)
-#define TAGMASK                 ((1 << LENGTH(tags)) - 1)
-#define TEXTW(X)                (drw_fontset_getwidth(drw, (X)) + lrpad)
-
-#define SYSTEM_TRAY_REQUEST_DOCK    0
+#define BUTTONMASK (ButtonPressMask | ButtonReleaseMask)
+#define CLEANMASK(mask)                                                        \
+  (mask & ~(numlockmask | LockMask) &                                          \
+   (ShiftMask | ControlMask | Mod1Mask | Mod2Mask | Mod3Mask | Mod4Mask |      \
+    Mod5Mask))
+#define INTERSECT(x, y, w, h, m)                                               \
+  (MAX(0, MIN((x) + (w), (m)->wx + (m)->ww) - MAX((x), (m)->wx)) *             \
+   MAX(0, MIN((y) + (h), (m)->wy + (m)->wh) - MAX((y), (m)->wy)))
+#define ISVISIBLEONTAG(C, T) ((C->tags & T))
+#define ISVISIBLE(C) ISVISIBLEONTAG(C, C->mon->tagset[C->mon->seltags])
+#define LENGTH(X) (sizeof X / sizeof X[0])
+#define MOUSEMASK (BUTTONMASK | PointerMotionMask)
+#define WIDTH(X) ((X)->w + 2 * (X)->bw)
+#define HEIGHT(X) ((X)->h + 2 * (X)->bw)
+#define TAGMASK ((1 << LENGTH(tags)) - 1)
+#define TEXTW(X) (drw_fontset_getwidth(drw, (X)) + lrpad)
+
+#define SYSTEM_TRAY_REQUEST_DOCK 0
 /* XEMBED messages */
-#define XEMBED_EMBEDDED_NOTIFY      0
-#define XEMBED_WINDOW_ACTIVATE      1
-#define XEMBED_FOCUS_IN             4
-#define XEMBED_MODALITY_ON         10
-#define XEMBED_MAPPED              (1 << 0)
-#define XEMBED_WINDOW_ACTIVATE      1
-#define XEMBED_WINDOW_DEACTIVATE    2
-#define VERSION_MAJOR               0
-#define VERSION_MINOR               0
+#define XEMBED_EMBEDDED_NOTIFY 0
+#define XEMBED_WINDOW_ACTIVATE 1
+#define XEMBED_FOCUS_IN 4
+#define XEMBED_MODALITY_ON 10
+#define XEMBED_MAPPED (1 << 0)
+#define XEMBED_WINDOW_ACTIVATE 1
+#define XEMBED_WINDOW_DEACTIVATE 2
+#define VERSION_MAJOR 0
+#define VERSION_MINOR 0
 #define XEMBED_EMBEDDED_VERSION (VERSION_MAJOR << 16) | VERSION_MINOR
 
 /* enums */
@@ -86,104 +90,132 @@ enum {
   SchemeTag5,
   SchemeLayout
 }; /* color schemes */
-enum { NetSupported, NetWMName, NetWMIcon, NetWMState, NetWMCheck,
-       NetSystemTray, NetSystemTrayOP, NetSystemTrayOrientation, NetSystemTrayOrientationHorz,
-       NetWMFullscreen, NetActiveWindow, NetWMWindowType,
-       NetWMWindowTypeDialog, NetClientList, NetLast }; /* EWMH atoms */
+enum {
+  NetSupported,
+  NetWMName,
+  NetWMIcon,
+  NetWMState,
+  NetWMCheck,
+  NetSystemTray,
+  NetSystemTrayOP,
+  NetSystemTrayOrientation,
+  NetSystemTrayOrientationHorz,
+  NetWMFullscreen,
+  NetActiveWindow,
+  NetWMWindowType,
+  NetWMWindowTypeDialog,
+  NetClientList,
+  NetLast
+}; /* EWMH atoms */
 enum { Manager, Xembed, XembedInfo, XLast }; /* Xembed atoms */
-enum { WMProtocols, WMDelete, WMState, WMTakeFocus, WMLast }; /* default atoms */
-enum { ClkTagBar, ClkLtSymbol, ClkStatusText, ClkWinTitle,
-       ClkClientWin, ClkRootWin, ClkLast }; /* clicks */
+enum {
+  WMProtocols,
+  WMDelete,
+  WMState,
+  WMTakeFocus,
+  WMLast
+}; /* default atoms */
+enum {
+  ClkTagBar,
+  ClkLtSymbol,
+  ClkStatusText,
+  ClkWinTitle,
+  ClkClientWin,
+  ClkRootWin,
+  ClkLast
+}; /* clicks */
 
 typedef union {
-	int i;
-	unsigned int ui;
-	float f;
-	const void *v;
+  int i;
+  unsigned int ui;
+  float f;
+  const void *v;
 } Arg;
 
 typedef struct {
-	unsigned int click;
-	unsigned int mask;
-	unsigned int button;
-	void (*func)(const Arg *arg);
-	const Arg arg;
+  unsigned int click;
+  unsigned int mask;
+  unsigned int button;
+  void (*func)(const Arg *arg);
+  const Arg arg;
 } Button;
 
 typedef struct Monitor Monitor;
 typedef struct Client Client;
 struct Client {
-	char name[256];
-	float mina, maxa;
-	int x, y, w, h;
-	int oldx, oldy, oldw, oldh;
-	int basew, baseh, incw, inch, maxw, maxh, minw, minh, hintsvalid;
-	int bw, oldbw;
-	unsigned int tags;
-	int isfixed, isfloating, isurgent, neverfocus, oldstate, isfullscreen;
-	unsigned int icw, ich; Picture icon;
-	Client *next;
-	Client *snext;
-	Monitor *mon;
-	Window win;
+  char name[256];
+  float mina, maxa;
+  int x, y, w, h;
+  int oldx, oldy, oldw, oldh;
+  int basew, baseh, incw, inch, maxw, maxh, minw, minh, hintsvalid;
+  int bw, oldbw;
+  unsigned int tags;
+  int isfixed, isfloating, isurgent, neverfocus, oldstate, isfullscreen;
+  unsigned int icw, ich;
+  Picture icon;
+  Client *next;
+  Client *snext;
+  Monitor *mon;
+  Window win;
 };
 
 typedef struct {
-	unsigned int mod;
-	KeySym keysym;
-	void (*func)(const Arg *);
-	const Arg arg;
+  unsigned int mod;
+  KeySym keysym;
+  void (*func)(const Arg *);
+  const Arg arg;
 } Key;
 
 typedef struct {
-	const char *symbol;
-	void (*arrange)(Monitor *);
+  const char *symbol;
+  void (*arrange)(Monitor *);
 } Layout;
 
 struct Monitor {
-	char ltsymbol[16];
-	float mfact;
-	int nmaster;
-	int num;
-	int by;               /* bar geometry */
-	int mx, my, mw, mh;   /* screen size */
-	int wx, wy, ww, wh;   /* window area  */
-	int gappih;           /* horizontal gap between windows */
-	int gappiv;           /* vertical gap between windows */
-	int gappoh;           /* horizontal outer gaps */
-	int gappov;           /* vertical outer gaps */
-	unsigned int seltags;
-	unsigned int sellt;
-	unsigned int tagset[2];
+  char ltsymbol[16];
+  float mfact;
+  int nmaster;
+  int num;
+  int by;             /* bar geometry */
+  int mx, my, mw, mh; /* screen size */
+  int wx, wy, ww, wh; /* window area  */
+  int gappih;         /* horizontal gap between windows */
+  int gappiv;         /* vertical gap between windows */
+  int gappoh;         /* horizontal outer gaps */
+  int gappov;         /* vertical outer gaps */
+  unsigned int seltags;
+  unsigned int sellt;
+  unsigned int tagset[2];
   unsigned int colorfultag;
-	int showbar;
-	int topbar;
-	Client *clients;
-	Client *sel;
-	Client *stack;
-	Monitor *next;
-	Window barwin;
-	const Layout *lt[2];
+  int showbar;
+  int topbar;
+  Client *clients;
+  Client *sel;
+  Client *stack;
+  Monitor *next;
+  Window barwin;
+  const Layout *lt[2];
 };
 
 typedef struct {
-	const char *class;
-	const char *instance;
-	const char *title;
-	unsigned int tags;
-	int isfloating;
-	int monitor;
+  const char *class;
+  const char *instance;
+  const char *title;
+  unsigned int tags;
+  int isfloating;
+  int monitor;
 } Rule;
 
-typedef struct Systray   Systray;
+typedef struct Systray Systray;
 struct Systray {
-	Window win;
-	Client *icons;
+  Window win;
+  Client *icons;
 };
 
 /* function declarations */
 static void applyrules(Client *c);
-static int applysizehints(Client *c, int *x, int *y, int *w, int *h, int interact);
+static int applysizehints(Client *c, int *x, int *y, int *w, int *h,
+                          int interact);
 static void arrange(Monitor *m);
 static void arrangemon(Monitor *m);
 static void attach(Client *c);
@@ -204,7 +236,7 @@ static void detachstack(Client *c);
 static Monitor *dirtomon(int dir);
 static void drawbar(Monitor *m);
 static void drawbars(void);
-static int drawstatusbar(Monitor *m, int bh, char* text);
+static int drawstatusbar(Monitor *m, int bh, char *text);
 static void expose(XEvent *e);
 static void focus(Client *c);
 static void focusin(XEvent *e);
@@ -242,7 +274,8 @@ static void restack(Monitor *m);
 static void run(void);
 static void runAutostart(void);
 static void scan(void);
-static int sendevent(Window w, Atom proto, int m, long d0, long d1, long d2, long d3, long d4);
+static int sendevent(Window w, Atom proto, int m, long d0, long d1, long d2,
+                     long d3, long d4);
 static void sendmon(Client *c, Monitor *m);
 static void setclientstate(Client *c, long state);
 static void setfocus(Client *c);
@@ -303,27 +336,26 @@ static Systray *systray = NULL;
 static const char broken[] = "broken";
 static char stext[1024];
 static int screen;
-static int sw, sh;           /* X display screen geometry width, height */
-static int bh;               /* bar height */
-static int enablegaps = 1;   /* enables gaps, used by togglegaps */
-static int lrpad;            /* sum of left and right padding for text */
+static int sw, sh;         /* X display screen geometry width, height */
+static int bh;             /* bar height */
+static int enablegaps = 1; /* enables gaps, used by togglegaps */
+static int lrpad;          /* sum of left and right padding for text */
 static int (*xerrorxlib)(Display *, XErrorEvent *);
 static unsigned int numlockmask = 0;
-static void (*handler[LASTEvent]) (XEvent *) = {
-	[ButtonPress] = buttonpress,
-	[ClientMessage] = clientmessage,
-	[ConfigureRequest] = configurerequest,
-	[ConfigureNotify] = configurenotify,
-	[DestroyNotify] = destroynotify,
-	[Expose] = expose,
-	[FocusIn] = focusin,
-	[KeyPress] = keypress,
-	[MappingNotify] = mappingnotify,
-	[MapRequest] = maprequest,
-	[PropertyNotify] = propertynotify,
+static void (*handler[LASTEvent])(XEvent *) = {
+    [ButtonPress] = buttonpress,
+    [ClientMessage] = clientmessage,
+    [ConfigureRequest] = configurerequest,
+    [ConfigureNotify] = configurenotify,
+    [DestroyNotify] = destroynotify,
+    [Expose] = expose,
+    [FocusIn] = focusin,
+    [KeyPress] = keypress,
+    [MappingNotify] = mappingnotify,
+    [MapRequest] = maprequest,
+    [PropertyNotify] = propertynotify,
     [ResizeRequest] = resizerequest,
-	[UnmapNotify] = unmapnotify
-};
+    [UnmapNotify] = unmapnotify};
 static Atom wmatom[WMLast], netatom[NetLast], xatom[XLast];
 static int running = 1;
 static Cur *cursor[CurLast];
@@ -337,2539 +369,2392 @@ static Window root, wmcheckwin;
 #include "config.h"
 
 /* compile-time check if all tags fit into an unsigned int bit array. */
-struct NumTags { char limitexceeded[LENGTH(tags) > 31 ? -1 : 1]; };
+struct NumTags {
+  char limitexceeded[LENGTH(tags) > 31 ? -1 : 1];
+};
 
 /* function implementations */
-void
-applyrules(Client *c)
-{
-	const char *class, *instance;
-	unsigned int i;
-	const Rule *r;
-	Monitor *m;
-	XClassHint ch = { NULL, NULL };
-
-	/* rule matching */
-	c->isfloating = 0;
-	c->tags = 0;
-	XGetClassHint(dpy, c->win, &ch);
-	class    = ch.res_class ? ch.res_class : broken;
-	instance = ch.res_name  ? ch.res_name  : broken;
-
-	for (i = 0; i < LENGTH(rules); i++) {
-		r = &rules[i];
-		if ((!r->title || strstr(c->name, r->title))
-		&& (!r->class || strstr(class, r->class))
-		&& (!r->instance || strstr(instance, r->instance)))
-		{
-			c->isfloating = r->isfloating;
-			c->tags |= r->tags;
-			for (m = mons; m && m->num != r->monitor; m = m->next);
-			if (m)
-				c->mon = m;
-		}
-	}
-	if (ch.res_class)
-		XFree(ch.res_class);
-	if (ch.res_name)
-		XFree(ch.res_name);
-	c->tags = c->tags & TAGMASK ? c->tags & TAGMASK : c->mon->tagset[c->mon->seltags];
-}
-
-int
-applysizehints(Client *c, int *x, int *y, int *w, int *h, int interact)
-{
-	int baseismin;
-	Monitor *m = c->mon;
-
-	/* set minimum possible */
-	*w = MAX(1, *w);
-	*h = MAX(1, *h);
-	if (interact) {
-		if (*x > sw)
-			*x = sw - WIDTH(c);
-		if (*y > sh)
-			*y = sh - HEIGHT(c);
-		if (*x + *w + 2 * c->bw < 0)
-			*x = 0;
-		if (*y + *h + 2 * c->bw < 0)
-			*y = 0;
-	} else {
-		if (*x >= m->wx + m->ww)
-			*x = m->wx + m->ww - WIDTH(c);
-		if (*y >= m->wy + m->wh)
-			*y = m->wy + m->wh - HEIGHT(c);
-		if (*x + *w + 2 * c->bw <= m->wx)
-			*x = m->wx;
-		if (*y + *h + 2 * c->bw <= m->wy)
-			*y = m->wy;
-	}
-	if (*h < bh)
-		*h = bh;
-	if (*w < bh)
-		*w = bh;
-	if (resizehints || c->isfloating || !c->mon->lt[c->mon->sellt]->arrange) {
-		if (!c->hintsvalid)
-			updatesizehints(c);
-		/* see last two sentences in ICCCM 4.1.2.3 */
-		baseismin = c->basew == c->minw && c->baseh == c->minh;
-		if (!baseismin) { /* temporarily remove base dimensions */
-			*w -= c->basew;
-			*h -= c->baseh;
-		}
-		/* adjust for aspect limits */
-		if (c->mina > 0 && c->maxa > 0) {
-			if (c->maxa < (float)*w / *h)
-				*w = *h * c->maxa + 0.5;
-			else if (c->mina < (float)*h / *w)
-				*h = *w * c->mina + 0.5;
-		}
-		if (baseismin) { /* increment calculation requires this */
-			*w -= c->basew;
-			*h -= c->baseh;
-		}
-		/* adjust for increment value */
-		if (c->incw)
-			*w -= *w % c->incw;
-		if (c->inch)
-			*h -= *h % c->inch;
-		/* restore base dimensions */
-		*w = MAX(*w + c->basew, c->minw);
-		*h = MAX(*h + c->baseh, c->minh);
-		if (c->maxw)
-			*w = MIN(*w, c->maxw);
-		if (c->maxh)
-			*h = MIN(*h, c->maxh);
-	}
-	return *x != c->x || *y != c->y || *w != c->w || *h != c->h;
-}
-
-void
-arrange(Monitor *m)
-{
-	if (m)
-		showhide(m->stack);
-	else for (m = mons; m; m = m->next)
-		showhide(m->stack);
-	if (m) {
-		arrangemon(m);
-		restack(m);
-	} else for (m = mons; m; m = m->next)
-		arrangemon(m);
-}
-
-void
-arrangemon(Monitor *m)
-{
-	strncpy(m->ltsymbol, m->lt[m->sellt]->symbol, sizeof m->ltsymbol);
-	if (m->lt[m->sellt]->arrange)
-		m->lt[m->sellt]->arrange(m);
-}
-
-void
-attach(Client *c)
-{
-	c->next = c->mon->clients;
-	c->mon->clients = c;
-}
-
-void
-attachaside(Client *c) {
-	Client *at = nexttagged(c);
-	if(!at) {
-		attach(c);
-		return;
-	}
-	c->next = at->next;
-	at->next = c;
-}
-
-void
-attachstack(Client *c)
-{
-	c->snext = c->mon->stack;
-	c->mon->stack = c;
-}
-
-void
-buttonpress(XEvent *e)
-{
-	unsigned int i, x, click, occ;
-	Arg arg = {0};
-	Client *c;
-	Monitor *m;
-	XButtonPressedEvent *ev = &e->xbutton;
-
-	click = ClkRootWin;
-	/* focus monitor if necessary */
-	if ((m = wintomon(ev->window)) && m != selmon
-	    && (focusonwheel || (ev->button != Button4 && ev->button != Button5))) {
-		unfocus(selmon->sel, 1);
-		selmon = m;
-		focus(NULL);
-	}
-	if (ev->window == selmon->barwin) {
-		i = x = occ = 0;
-		/* Bitmask of occupied tags */
-		for (c = m->clients; c; c = c->next)
-			occ |= c->tags;
-
-		do
-			x += TEXTW(occ & 1 << i ? alttags[i] : tags[i]);
-		while (ev->x >= x && ++i < LENGTH(tags));
-		if (i < LENGTH(tags)) {
-			click = ClkTagBar;
-			arg.ui = 1 << i;
-		} else if (ev->x < x + TEXTW(selmon->ltsymbol))
-			click = ClkLtSymbol;
-		else if (ev->x > selmon->ww - (int)TEXTW(stext) - getsystraywidth())
-			click = ClkStatusText;
-		else
-			click = ClkWinTitle;
-	} else if ((c = wintoclient(ev->window))) {
-		if (focusonwheel || (ev->button != Button4 && ev->button != Button5))
-			focus(c);
-		XAllowEvents(dpy, ReplayPointer, CurrentTime);
-		click = ClkClientWin;
-	}
-	for (i = 0; i < LENGTH(buttons); i++)
-		if (click == buttons[i].click && buttons[i].func && buttons[i].button == ev->button
-		&& CLEANMASK(buttons[i].mask) == CLEANMASK(ev->state))
-			buttons[i].func(click == ClkTagBar && buttons[i].arg.i == 0 ? &arg : &buttons[i].arg);
-}
-
-void
-checkotherwm(void)
-{
-	xerrorxlib = XSetErrorHandler(xerrorstart);
-	/* this causes an error if some other window manager is running */
-	XSelectInput(dpy, DefaultRootWindow(dpy), SubstructureRedirectMask);
-	XSync(dpy, False);
-	XSetErrorHandler(xerror);
-	XSync(dpy, False);
-}
-
-void
-cleanup(void)
-{
-	Arg a = {.ui = ~0};
-	Layout foo = { "", NULL };
-	Monitor *m;
-	size_t i;
-
-	view(&a);
-	selmon->lt[selmon->sellt] = &foo;
-	for (m = mons; m; m = m->next)
-		while (m->stack)
-			unmanage(m->stack, 0);
-	XUngrabKey(dpy, AnyKey, AnyModifier, root);
-	while (mons)
-		cleanupmon(mons);
-
-	if (showsystray) {
-		XUnmapWindow(dpy, systray->win);
-		XDestroyWindow(dpy, systray->win);
-		free(systray);
-	}
-
-    for (i = 0; i < CurLast; i++)
-		drw_cur_free(drw, cursor[i]);
-	for (i = 0; i < LENGTH(colors) + 1; i++)
-		free(scheme[i]);
-	free(scheme);
-	XDestroyWindow(dpy, wmcheckwin);
-	drw_free(drw);
-	XSync(dpy, False);
-	XSetInputFocus(dpy, PointerRoot, RevertToPointerRoot, CurrentTime);
-	XDeleteProperty(dpy, root, netatom[NetActiveWindow]);
-}
-
-void
-cleanupmon(Monitor *mon)
-{
-	Monitor *m;
-
-	if (mon == mons)
-		mons = mons->next;
-	else {
-		for (m = mons; m && m->next != mon; m = m->next);
-		m->next = mon->next;
-	}
-	XUnmapWindow(dpy, mon->barwin);
-	XDestroyWindow(dpy, mon->barwin);
-	free(mon);
-}
-
-void
-clientmessage(XEvent *e)
-{
-	XWindowAttributes wa;
-	XSetWindowAttributes swa;
-	XClientMessageEvent *cme = &e->xclient;
-	Client *c = wintoclient(cme->window);
-
-	if (showsystray && cme->window == systray->win && cme->message_type == netatom[NetSystemTrayOP]) {
-		/* add systray icons */
-		if (cme->data.l[1] == SYSTEM_TRAY_REQUEST_DOCK) {
-			if (!(c = (Client *)calloc(1, sizeof(Client))))
-				die("fatal: could not malloc() %u bytes\n", sizeof(Client));
-			if (!(c->win = cme->data.l[2])) {
-				free(c);
-				return;
-			}
-			c->mon = selmon;
-			c->next = systray->icons;
-			systray->icons = c;
-			if (!XGetWindowAttributes(dpy, c->win, &wa)) {
-				/* use sane defaults */
-				wa.width = bh;
-				wa.height = bh;
-				wa.border_width = 0;
-			}
-			c->x = c->oldx = c->y = c->oldy = 0;
-			c->w = c->oldw = wa.width;
-			c->h = c->oldh = wa.height;
-			c->oldbw = wa.border_width;
-			c->bw = 0;
-			c->isfloating = True;
-			/* reuse tags field as mapped status */
-			c->tags = 1;
-			updatesizehints(c);
-			updatesystrayicongeom(c, wa.width, wa.height);
-			XAddToSaveSet(dpy, c->win);
-			XSelectInput(dpy, c->win, StructureNotifyMask | PropertyChangeMask | ResizeRedirectMask);
-			XReparentWindow(dpy, c->win, systray->win, 0, 0);
-			/* use parents background color */
-			swa.background_pixel  = scheme[SchemeNorm][ColBg].pixel;
-			XChangeWindowAttributes(dpy, c->win, CWBackPixel, &swa);
-			sendevent(c->win, netatom[Xembed], StructureNotifyMask, CurrentTime, XEMBED_EMBEDDED_NOTIFY, 0 , systray->win, XEMBED_EMBEDDED_VERSION);
-			/* FIXME not sure if I have to send these events, too */
-			sendevent(c->win, netatom[Xembed], StructureNotifyMask, CurrentTime, XEMBED_FOCUS_IN, 0 , systray->win, XEMBED_EMBEDDED_VERSION);
-			sendevent(c->win, netatom[Xembed], StructureNotifyMask, CurrentTime, XEMBED_WINDOW_ACTIVATE, 0 , systray->win, XEMBED_EMBEDDED_VERSION);
-			sendevent(c->win, netatom[Xembed], StructureNotifyMask, CurrentTime, XEMBED_MODALITY_ON, 0 , systray->win, XEMBED_EMBEDDED_VERSION);
-			XSync(dpy, False);
-			resizebarwin(selmon);
-			updatesystray();
-			setclientstate(c, NormalState);
-		}
-		return;
-	}
-
-	if (!c)
-		return;
-	if (cme->message_type == netatom[NetWMState]) {
-		if (cme->data.l[1] == netatom[NetWMFullscreen]
-		|| cme->data.l[2] == netatom[NetWMFullscreen])
-			setfullscreen(c, (cme->data.l[0] == 1 /* _NET_WM_STATE_ADD    */
-				|| (cme->data.l[0] == 2 /* _NET_WM_STATE_TOGGLE */ && !c->isfullscreen)));
-	} else if (cme->message_type == netatom[NetActiveWindow]) {
-		if (c != selmon->sel && !c->isurgent)
-			seturgent(c, 1);
-	}
-}
-
-void
-configure(Client *c)
-{
-	XConfigureEvent ce;
-
-	ce.type = ConfigureNotify;
-	ce.display = dpy;
-	ce.event = c->win;
-	ce.window = c->win;
-	ce.x = c->x;
-	ce.y = c->y;
-	ce.width = c->w;
-	ce.height = c->h;
-	ce.border_width = c->bw;
-	ce.above = None;
-	ce.override_redirect = False;
-	XSendEvent(dpy, c->win, False, StructureNotifyMask, (XEvent *)&ce);
-}
-
-void
-configurenotify(XEvent *e)
-{
-	Monitor *m;
-	Client *c;
-	XConfigureEvent *ev = &e->xconfigure;
-	int dirty;
-
-	/* TODO: updategeom handling sucks, needs to be simplified */
-	if (ev->window == root) {
-		dirty = (sw != ev->width || sh != ev->height);
-		sw = ev->width;
-		sh = ev->height;
-		if (updategeom() || dirty) {
-			drw_resize(drw, sw, bh);
-			updatebars();
-			for (m = mons; m; m = m->next) {
-				for (c = m->clients; c; c = c->next)
-					if (c->isfullscreen)
-						resizeclient(c, m->mx, m->my, m->mw, m->mh);
-				resizebarwin(m);
-			}
-			focus(NULL);
-			arrange(NULL);
-		}
-	}
-}
-
-void
-configurerequest(XEvent *e)
-{
-	Client *c;
-	Monitor *m;
-	XConfigureRequestEvent *ev = &e->xconfigurerequest;
-	XWindowChanges wc;
-
-	if ((c = wintoclient(ev->window))) {
-		if (ev->value_mask & CWBorderWidth)
-			c->bw = ev->border_width;
-		else if (c->isfloating || !selmon->lt[selmon->sellt]->arrange) {
-			m = c->mon;
-			if (ev->value_mask & CWX) {
-				c->oldx = c->x;
-				c->x = m->mx + ev->x;
-			}
-			if (ev->value_mask & CWY) {
-				c->oldy = c->y;
-				c->y = m->my + ev->y;
-			}
-			if (ev->value_mask & CWWidth) {
-				c->oldw = c->w;
-				c->w = ev->width;
-			}
-			if (ev->value_mask & CWHeight) {
-				c->oldh = c->h;
-				c->h = ev->height;
-			}
-			if ((c->x + c->w) > m->mx + m->mw && c->isfloating)
-				c->x = m->mx + (m->mw / 2 - WIDTH(c) / 2); /* center in x direction */
-			if ((c->y + c->h) > m->my + m->mh && c->isfloating)
-				c->y = m->my + (m->mh / 2 - HEIGHT(c) / 2); /* center in y direction */
-			if ((ev->value_mask & (CWX|CWY)) && !(ev->value_mask & (CWWidth|CWHeight)))
-				configure(c);
-			if (ISVISIBLE(c))
-				XMoveResizeWindow(dpy, c->win, c->x, c->y, c->w, c->h);
-		} else
-			configure(c);
-	} else {
-		wc.x = ev->x;
-		wc.y = ev->y;
-		wc.width = ev->width;
-		wc.height = ev->height;
-		wc.border_width = ev->border_width;
-		wc.sibling = ev->above;
-		wc.stack_mode = ev->detail;
-		XConfigureWindow(dpy, ev->window, ev->value_mask, &wc);
-	}
-	XSync(dpy, False);
-}
-
-Monitor *
-createmon(void)
-{
-	Monitor *m;
-
-	m = ecalloc(1, sizeof(Monitor));
-	m->tagset[0] = m->tagset[1] = 1;
-	m->mfact = mfact;
-	m->nmaster = nmaster;
-	m->showbar = showbar;
-	m->topbar = topbar;
+void applyrules(Client *c) {
+  const char *class, *instance;
+  unsigned int i;
+  const Rule *r;
+  Monitor *m;
+  XClassHint ch = {NULL, NULL};
+
+  /* rule matching */
+  c->isfloating = 0;
+  c->tags = 0;
+  XGetClassHint(dpy, c->win, &ch);
+  class = ch.res_class ? ch.res_class : broken;
+  instance = ch.res_name ? ch.res_name : broken;
+
+  for (i = 0; i < LENGTH(rules); i++) {
+    r = &rules[i];
+    if ((!r->title || strstr(c->name, r->title)) &&
+        (!r->class || strstr(class, r->class)) &&
+        (!r->instance || strstr(instance, r->instance))) {
+      c->isfloating = r->isfloating;
+      c->tags |= r->tags;
+      for (m = mons; m && m->num != r->monitor; m = m->next)
+        ;
+      if (m)
+        c->mon = m;
+    }
+  }
+  if (ch.res_class)
+    XFree(ch.res_class);
+  if (ch.res_name)
+    XFree(ch.res_name);
+  c->tags =
+      c->tags & TAGMASK ? c->tags & TAGMASK : c->mon->tagset[c->mon->seltags];
+}
+
+int applysizehints(Client *c, int *x, int *y, int *w, int *h, int interact) {
+  int baseismin;
+  Monitor *m = c->mon;
+
+  /* set minimum possible */
+  *w = MAX(1, *w);
+  *h = MAX(1, *h);
+  if (interact) {
+    if (*x > sw)
+      *x = sw - WIDTH(c);
+    if (*y > sh)
+      *y = sh - HEIGHT(c);
+    if (*x + *w + 2 * c->bw < 0)
+      *x = 0;
+    if (*y + *h + 2 * c->bw < 0)
+      *y = 0;
+  } else {
+    if (*x >= m->wx + m->ww)
+      *x = m->wx + m->ww - WIDTH(c);
+    if (*y >= m->wy + m->wh)
+      *y = m->wy + m->wh - HEIGHT(c);
+    if (*x + *w + 2 * c->bw <= m->wx)
+      *x = m->wx;
+    if (*y + *h + 2 * c->bw <= m->wy)
+      *y = m->wy;
+  }
+  if (*h < bh)
+    *h = bh;
+  if (*w < bh)
+    *w = bh;
+  if (resizehints || c->isfloating || !c->mon->lt[c->mon->sellt]->arrange) {
+    if (!c->hintsvalid)
+      updatesizehints(c);
+    /* see last two sentences in ICCCM 4.1.2.3 */
+    baseismin = c->basew == c->minw && c->baseh == c->minh;
+    if (!baseismin) { /* temporarily remove base dimensions */
+      *w -= c->basew;
+      *h -= c->baseh;
+    }
+    /* adjust for aspect limits */
+    if (c->mina > 0 && c->maxa > 0) {
+      if (c->maxa < (float)*w / *h)
+        *w = *h * c->maxa + 0.5;
+      else if (c->mina < (float)*h / *w)
+        *h = *w * c->mina + 0.5;
+    }
+    if (baseismin) { /* increment calculation requires this */
+      *w -= c->basew;
+      *h -= c->baseh;
+    }
+    /* adjust for increment value */
+    if (c->incw)
+      *w -= *w % c->incw;
+    if (c->inch)
+      *h -= *h % c->inch;
+    /* restore base dimensions */
+    *w = MAX(*w + c->basew, c->minw);
+    *h = MAX(*h + c->baseh, c->minh);
+    if (c->maxw)
+      *w = MIN(*w, c->maxw);
+    if (c->maxh)
+      *h = MIN(*h, c->maxh);
+  }
+  return *x != c->x || *y != c->y || *w != c->w || *h != c->h;
+}
+
+void arrange(Monitor *m) {
+  if (m)
+    showhide(m->stack);
+  else
+    for (m = mons; m; m = m->next)
+      showhide(m->stack);
+  if (m) {
+    arrangemon(m);
+    restack(m);
+  } else
+    for (m = mons; m; m = m->next)
+      arrangemon(m);
+}
+
+void arrangemon(Monitor *m) {
+  strncpy(m->ltsymbol, m->lt[m->sellt]->symbol, sizeof m->ltsymbol);
+  if (m->lt[m->sellt]->arrange)
+    m->lt[m->sellt]->arrange(m);
+}
+
+void attach(Client *c) {
+  c->next = c->mon->clients;
+  c->mon->clients = c;
+}
+
+void attachaside(Client *c) {
+  Client *at = nexttagged(c);
+  if (!at) {
+    attach(c);
+    return;
+  }
+  c->next = at->next;
+  at->next = c;
+}
+
+void attachstack(Client *c) {
+  c->snext = c->mon->stack;
+  c->mon->stack = c;
+}
+
+void buttonpress(XEvent *e) {
+  unsigned int i, x, click, occ;
+  Arg arg = {0};
+  Client *c;
+  Monitor *m;
+  XButtonPressedEvent *ev = &e->xbutton;
+
+  click = ClkRootWin;
+  /* focus monitor if necessary */
+  if ((m = wintomon(ev->window)) && m != selmon &&
+      (focusonwheel || (ev->button != Button4 && ev->button != Button5))) {
+    unfocus(selmon->sel, 1);
+    selmon = m;
+    focus(NULL);
+  }
+  if (ev->window == selmon->barwin) {
+    i = x = occ = 0;
+    /* Bitmask of occupied tags */
+    for (c = m->clients; c; c = c->next)
+      occ |= c->tags;
+
+    do
+      x += TEXTW(occ & 1 << i ? alttags[i] : tags[i]);
+    while (ev->x >= x && ++i < LENGTH(tags));
+    if (i < LENGTH(tags)) {
+      click = ClkTagBar;
+      arg.ui = 1 << i;
+    } else if (ev->x < x + TEXTW(selmon->ltsymbol))
+      click = ClkLtSymbol;
+    else if (ev->x > selmon->ww - (int)TEXTW(stext) - getsystraywidth())
+      click = ClkStatusText;
+    else
+      click = ClkWinTitle;
+  } else if ((c = wintoclient(ev->window))) {
+    if (focusonwheel || (ev->button != Button4 && ev->button != Button5))
+      focus(c);
+    XAllowEvents(dpy, ReplayPointer, CurrentTime);
+    click = ClkClientWin;
+  }
+  for (i = 0; i < LENGTH(buttons); i++)
+    if (click == buttons[i].click && buttons[i].func &&
+        buttons[i].button == ev->button &&
+        CLEANMASK(buttons[i].mask) == CLEANMASK(ev->state))
+      buttons[i].func(
+          click == ClkTagBar && buttons[i].arg.i == 0 ? &arg : &buttons[i].arg);
+}
+
+void checkotherwm(void) {
+  xerrorxlib = XSetErrorHandler(xerrorstart);
+  /* this causes an error if some other window manager is running */
+  XSelectInput(dpy, DefaultRootWindow(dpy), SubstructureRedirectMask);
+  XSync(dpy, False);
+  XSetErrorHandler(xerror);
+  XSync(dpy, False);
+}
+
+void cleanup(void) {
+  Arg a = {.ui = ~0};
+  Layout foo = {"", NULL};
+  Monitor *m;
+  size_t i;
+
+  view(&a);
+  selmon->lt[selmon->sellt] = &foo;
+  for (m = mons; m; m = m->next)
+    while (m->stack)
+      unmanage(m->stack, 0);
+  XUngrabKey(dpy, AnyKey, AnyModifier, root);
+  while (mons)
+    cleanupmon(mons);
+
+  if (showsystray) {
+    XUnmapWindow(dpy, systray->win);
+    XDestroyWindow(dpy, systray->win);
+    free(systray);
+  }
+
+  for (i = 0; i < CurLast; i++)
+    drw_cur_free(drw, cursor[i]);
+  for (i = 0; i < LENGTH(colors) + 1; i++)
+    free(scheme[i]);
+  free(scheme);
+  XDestroyWindow(dpy, wmcheckwin);
+  drw_free(drw);
+  XSync(dpy, False);
+  XSetInputFocus(dpy, PointerRoot, RevertToPointerRoot, CurrentTime);
+  XDeleteProperty(dpy, root, netatom[NetActiveWindow]);
+}
+
+void cleanupmon(Monitor *mon) {
+  Monitor *m;
+
+  if (mon == mons)
+    mons = mons->next;
+  else {
+    for (m = mons; m && m->next != mon; m = m->next)
+      ;
+    m->next = mon->next;
+  }
+  XUnmapWindow(dpy, mon->barwin);
+  XDestroyWindow(dpy, mon->barwin);
+  free(mon);
+}
+
+void clientmessage(XEvent *e) {
+  XWindowAttributes wa;
+  XSetWindowAttributes swa;
+  XClientMessageEvent *cme = &e->xclient;
+  Client *c = wintoclient(cme->window);
+
+  if (showsystray && cme->window == systray->win &&
+      cme->message_type == netatom[NetSystemTrayOP]) {
+    /* add systray icons */
+    if (cme->data.l[1] == SYSTEM_TRAY_REQUEST_DOCK) {
+      if (!(c = (Client *)calloc(1, sizeof(Client))))
+        die("fatal: could not malloc() %u bytes\n", sizeof(Client));
+      if (!(c->win = cme->data.l[2])) {
+        free(c);
+        return;
+      }
+      c->mon = selmon;
+      c->next = systray->icons;
+      systray->icons = c;
+      if (!XGetWindowAttributes(dpy, c->win, &wa)) {
+        /* use sane defaults */
+        wa.width = bh;
+        wa.height = bh;
+        wa.border_width = 0;
+      }
+      c->x = c->oldx = c->y = c->oldy = 0;
+      c->w = c->oldw = wa.width;
+      c->h = c->oldh = wa.height;
+      c->oldbw = wa.border_width;
+      c->bw = 0;
+      c->isfloating = True;
+      /* reuse tags field as mapped status */
+      c->tags = 1;
+      updatesizehints(c);
+      updatesystrayicongeom(c, wa.width, wa.height);
+      XAddToSaveSet(dpy, c->win);
+      XSelectInput(dpy, c->win,
+                   StructureNotifyMask | PropertyChangeMask |
+                       ResizeRedirectMask);
+      XClassHint ch = {"dwmsystray", "dwmsystray"};
+      XSetClassHint(dpy, c->win, &ch);
+      XReparentWindow(dpy, c->win, systray->win, 0, 0);
+      /* use parents background color */
+      swa.background_pixel = scheme[SchemeNorm][ColBg].pixel;
+      XChangeWindowAttributes(dpy, c->win, CWBackPixel, &swa);
+      sendevent(c->win, netatom[Xembed], StructureNotifyMask, CurrentTime,
+                XEMBED_EMBEDDED_NOTIFY, 0, systray->win,
+                XEMBED_EMBEDDED_VERSION);
+      /* FIXME not sure if I have to send these events, too */
+      sendevent(c->win, netatom[Xembed], StructureNotifyMask, CurrentTime,
+                XEMBED_FOCUS_IN, 0, systray->win, XEMBED_EMBEDDED_VERSION);
+      sendevent(c->win, netatom[Xembed], StructureNotifyMask, CurrentTime,
+                XEMBED_WINDOW_ACTIVATE, 0, systray->win,
+                XEMBED_EMBEDDED_VERSION);
+      sendevent(c->win, netatom[Xembed], StructureNotifyMask, CurrentTime,
+                XEMBED_MODALITY_ON, 0, systray->win, XEMBED_EMBEDDED_VERSION);
+      XSync(dpy, False);
+      resizebarwin(selmon);
+      updatesystray();
+      setclientstate(c, NormalState);
+    }
+    return;
+  }
+
+  if (!c)
+    return;
+  if (cme->message_type == netatom[NetWMState]) {
+    if (cme->data.l[1] == netatom[NetWMFullscreen] ||
+        cme->data.l[2] == netatom[NetWMFullscreen])
+      setfullscreen(c, (cme->data.l[0] == 1 /* _NET_WM_STATE_ADD    */
+                        || (cme->data.l[0] == 2 /* _NET_WM_STATE_TOGGLE */ &&
+                            !c->isfullscreen)));
+  } else if (cme->message_type == netatom[NetActiveWindow]) {
+    if (c != selmon->sel && !c->isurgent)
+      seturgent(c, 1);
+  }
+}
+
+void configure(Client *c) {
+  XConfigureEvent ce;
+
+  ce.type = ConfigureNotify;
+  ce.display = dpy;
+  ce.event = c->win;
+  ce.window = c->win;
+  ce.x = c->x;
+  ce.y = c->y;
+  ce.width = c->w;
+  ce.height = c->h;
+  ce.border_width = c->bw;
+  ce.above = None;
+  ce.override_redirect = False;
+  XSendEvent(dpy, c->win, False, StructureNotifyMask, (XEvent *)&ce);
+}
+
+void configurenotify(XEvent *e) {
+  Monitor *m;
+  Client *c;
+  XConfigureEvent *ev = &e->xconfigure;
+  int dirty;
+
+  /* TODO: updategeom handling sucks, needs to be simplified */
+  if (ev->window == root) {
+    dirty = (sw != ev->width || sh != ev->height);
+    sw = ev->width;
+    sh = ev->height;
+    if (updategeom() || dirty) {
+      drw_resize(drw, sw, bh);
+      updatebars();
+      for (m = mons; m; m = m->next) {
+        for (c = m->clients; c; c = c->next)
+          if (c->isfullscreen)
+            resizeclient(c, m->mx, m->my, m->mw, m->mh);
+        resizebarwin(m);
+      }
+      focus(NULL);
+      arrange(NULL);
+    }
+  }
+}
+
+void configurerequest(XEvent *e) {
+  Client *c;
+  Monitor *m;
+  XConfigureRequestEvent *ev = &e->xconfigurerequest;
+  XWindowChanges wc;
+
+  if ((c = wintoclient(ev->window))) {
+    if (ev->value_mask & CWBorderWidth)
+      c->bw = ev->border_width;
+    else if (c->isfloating || !selmon->lt[selmon->sellt]->arrange) {
+      m = c->mon;
+      if (ev->value_mask & CWX) {
+        c->oldx = c->x;
+        c->x = m->mx + ev->x;
+      }
+      if (ev->value_mask & CWY) {
+        c->oldy = c->y;
+        c->y = m->my + ev->y;
+      }
+      if (ev->value_mask & CWWidth) {
+        c->oldw = c->w;
+        c->w = ev->width;
+      }
+      if (ev->value_mask & CWHeight) {
+        c->oldh = c->h;
+        c->h = ev->height;
+      }
+      if ((c->x + c->w) > m->mx + m->mw && c->isfloating)
+        c->x = m->mx + (m->mw / 2 - WIDTH(c) / 2); /* center in x direction */
+      if ((c->y + c->h) > m->my + m->mh && c->isfloating)
+        c->y = m->my + (m->mh / 2 - HEIGHT(c) / 2); /* center in y direction */
+      if ((ev->value_mask & (CWX | CWY)) &&
+          !(ev->value_mask & (CWWidth | CWHeight)))
+        configure(c);
+      if (ISVISIBLE(c))
+        XMoveResizeWindow(dpy, c->win, c->x, c->y, c->w, c->h);
+    } else
+      configure(c);
+  } else {
+    wc.x = ev->x;
+    wc.y = ev->y;
+    wc.width = ev->width;
+    wc.height = ev->height;
+    wc.border_width = ev->border_width;
+    wc.sibling = ev->above;
+    wc.stack_mode = ev->detail;
+    XConfigureWindow(dpy, ev->window, ev->value_mask, &wc);
+  }
+  XSync(dpy, False);
+}
+
+Monitor *createmon(void) {
+  Monitor *m;
+
+  m = ecalloc(1, sizeof(Monitor));
+  m->tagset[0] = m->tagset[1] = 1;
+  m->mfact = mfact;
+  m->nmaster = nmaster;
+  m->showbar = showbar;
+  m->topbar = topbar;
   m->colorfultag = colorfultag ? colorfultag : 0;
-	m->gappih = gappih;
-	m->gappiv = gappiv;
-	m->gappoh = gappoh;
-	m->gappov = gappov;
-	m->lt[0] = &layouts[0];
-	m->lt[1] = &layouts[1 % LENGTH(layouts)];
-	strncpy(m->ltsymbol, layouts[0].symbol, sizeof m->ltsymbol);
-	return m;
-}
-
-void
-destroynotify(XEvent *e)
-{
-	Client *c;
-	XDestroyWindowEvent *ev = &e->xdestroywindow;
-
-	if ((c = wintoclient(ev->window)))
-		unmanage(c, 1);
-	else if ((c = wintosystrayicon(ev->window))) {
-		removesystrayicon(c);
-		resizebarwin(selmon);
-		updatesystray();
-	}
-}
-
-void
-detach(Client *c)
-{
-	Client **tc;
-
-	for (tc = &c->mon->clients; *tc && *tc != c; tc = &(*tc)->next);
-	*tc = c->next;
-}
-
-void
-detachstack(Client *c)
-{
-	Client **tc, *t;
-
-	for (tc = &c->mon->stack; *tc && *tc != c; tc = &(*tc)->snext);
-	*tc = c->snext;
-
-	if (c == c->mon->sel) {
-		for (t = c->mon->stack; t && !ISVISIBLE(t); t = t->snext);
-		c->mon->sel = t;
-	}
-}
-
-Monitor *
-dirtomon(int dir)
-{
-	Monitor *m = NULL;
-
-	if (dir > 0) {
-		if (!(m = selmon->next))
-			m = mons;
-	} else if (selmon == mons)
-		for (m = mons; m->next; m = m->next);
-	else
-		for (m = mons; m->next != selmon; m = m->next);
-	return m;
-}
-
-int
-drawstatusbar(Monitor *m, int bh, char* stext) {
-	int ret, i, w, x, len;
-	short isCode = 0;
-	char *text;
-	char *p;
-
-	len = strlen(stext) + 1 ;
-	if (!(text = (char*) malloc(sizeof(char)*len)))
-		die("malloc");
-	p = text;
-	memcpy(text, stext, len);
-
-	/* compute width of the status text */
-	w = 0;
-	i = -1;
-	while (text[++i]) {
-		if (text[i] == '^') {
-			if (!isCode) {
-				isCode = 1;
-				text[i] = '\0';
-				w += TEXTW(text) - lrpad;
-				text[i] = '^';
-				if (text[++i] == 'f')
-					w += atoi(text + ++i);
-			} else {
-				isCode = 0;
-				text = text + i + 1;
-				i = -1;
-			}
-		}
-	}
-	if (!isCode)
-		w += TEXTW(text) - lrpad;
-	else
-		isCode = 0;
-	text = p;
-
-	w += 2; /* 1px padding on both sides */
-	ret = m->ww - w - barpadding;
-	x = m->ww - w - getsystraywidth();
-
-	drw_setscheme(drw, scheme[LENGTH(colors)]);
-	drw->scheme[ColFg] = scheme[SchemeNorm][ColFg];
-	drw->scheme[ColBg] = scheme[SchemeNorm][ColBg];
-	drw_rect(drw, x, barpadding, w, bh, 1, 1);
-	x++;
-
-	/* process status text */
-	i = -1;
-	while (text[++i]) {
-		if (text[i] == '^' && !isCode) {
-			isCode = 1;
-
-			text[i] = '\0';
-			w = TEXTW(text) - lrpad;
-			drw_text(drw, x, barpadding, w, bh, 0, text, 0);
-
-			x += w;
-
-			/* process code */
-			while (text[++i] != '^') {
-				if (text[i] == 'c') {
-					char buf[8];
-					memcpy(buf, (char*)text+i+1, 7);
-					buf[7] = '\0';
-					drw_clr_create(drw, &drw->scheme[ColFg], buf);
-					i += 7;
-				} else if (text[i] == 'b') {
-					char buf[8];
-					memcpy(buf, (char*)text+i+1, 7);
-					buf[7] = '\0';
-					drw_clr_create(drw, &drw->scheme[ColBg], buf);
-					i += 7;
-				} else if (text[i] == 'd') {
-					drw->scheme[ColFg] = scheme[SchemeNorm][ColFg];
-					drw->scheme[ColBg] = scheme[SchemeNorm][ColBg];
-				} else if (text[i] == 'r') {
-					int rx = atoi(text + ++i);
-					while (text[++i] != ',');
-					int ry = atoi(text + ++i);
-					while (text[++i] != ',');
-					int rw = atoi(text + ++i);
-					while (text[++i] != ',');
-					int rh = atoi(text + ++i);
-
-					drw_rect(drw, rx + x, ry + barpadding, rw, rh, 1, 0);
-				} else if (text[i] == 'f') {
-					x += atoi(text + ++i);
-				}
-			}
-
-			text = text + i + 1;
-			i=-1;
-			isCode = 0;
-		}
-	}
-
-	if (!isCode) {
-		w = TEXTW(text) - lrpad;
-		drw_text(drw, x, barpadding, w, bh, 0, text, 0);
-	}
-
-	drw_setscheme(drw, scheme[SchemeNorm]);
-	free(p);
-
-	return ret;
-}
-
-void
-drawbar(Monitor *m)
-{
-	int x, y = barpadding, w, tw = 0, stw = 0;
-	int th = bh - barpadding * 2;
-	int mw = m->ww - barpadding * 2;
-	int boxs = drw->fonts->h / 9;
-	int boxw = drw->fonts->h / 6 + 2;
+  m->gappih = gappih;
+  m->gappiv = gappiv;
+  m->gappoh = gappoh;
+  m->gappov = gappov;
+  m->lt[0] = &layouts[0];
+  m->lt[1] = &layouts[1 % LENGTH(layouts)];
+  strncpy(m->ltsymbol, layouts[0].symbol, sizeof m->ltsymbol);
+  return m;
+}
+
+void destroynotify(XEvent *e) {
+  Client *c;
+  XDestroyWindowEvent *ev = &e->xdestroywindow;
+
+  if ((c = wintoclient(ev->window)))
+    unmanage(c, 1);
+  else if ((c = wintosystrayicon(ev->window))) {
+    removesystrayicon(c);
+    resizebarwin(selmon);
+    updatesystray();
+  }
+}
+
+void detach(Client *c) {
+  Client **tc;
+
+  for (tc = &c->mon->clients; *tc && *tc != c; tc = &(*tc)->next)
+    ;
+  *tc = c->next;
+}
+
+void detachstack(Client *c) {
+  Client **tc, *t;
+
+  for (tc = &c->mon->stack; *tc && *tc != c; tc = &(*tc)->snext)
+    ;
+  *tc = c->snext;
+
+  if (c == c->mon->sel) {
+    for (t = c->mon->stack; t && !ISVISIBLE(t); t = t->snext)
+      ;
+    c->mon->sel = t;
+  }
+}
+
+Monitor *dirtomon(int dir) {
+  Monitor *m = NULL;
+
+  if (dir > 0) {
+    if (!(m = selmon->next))
+      m = mons;
+  } else if (selmon == mons)
+    for (m = mons; m->next; m = m->next)
+      ;
+  else
+    for (m = mons; m->next != selmon; m = m->next)
+      ;
+  return m;
+}
+
+int drawstatusbar(Monitor *m, int bh, char *stext) {
+  int ret, i, w, x, len;
+  short isCode = 0;
+  char *text;
+  char *p;
+
+  len = strlen(stext) + 1;
+  if (!(text = (char *)malloc(sizeof(char) * len)))
+    die("malloc");
+  p = text;
+  memcpy(text, stext, len);
+
+  /* compute width of the status text */
+  w = 0;
+  i = -1;
+  while (text[++i]) {
+    if (text[i] == '^') {
+      if (!isCode) {
+        isCode = 1;
+        text[i] = '\0';
+        w += TEXTW(text) - lrpad;
+        text[i] = '^';
+        if (text[++i] == 'f')
+          w += atoi(text + ++i);
+      } else {
+        isCode = 0;
+        text = text + i + 1;
+        i = -1;
+      }
+    }
+  }
+  if (!isCode)
+    w += TEXTW(text) - lrpad;
+  else
+    isCode = 0;
+  text = p;
+
+  w += 2; /* 1px padding on both sides */
+  ret = m->ww - w - barpadding;
+  x = m->ww - w - getsystraywidth();
+
+  drw_setscheme(drw, scheme[LENGTH(colors)]);
+  drw->scheme[ColFg] = scheme[SchemeNorm][ColFg];
+  drw->scheme[ColBg] = scheme[SchemeNorm][ColBg];
+  drw_rect(drw, x, barpadding, w, bh, 1, 1);
+  x++;
+
+  /* process status text */
+  i = -1;
+  while (text[++i]) {
+    if (text[i] == '^' && !isCode) {
+      isCode = 1;
+
+      text[i] = '\0';
+      w = TEXTW(text) - lrpad;
+      drw_text(drw, x, barpadding, w, bh, 0, text, 0);
+
+      x += w;
+
+      /* process code */
+      while (text[++i] != '^') {
+        if (text[i] == 'c') {
+          char buf[8];
+          memcpy(buf, (char *)text + i + 1, 7);
+          buf[7] = '\0';
+          drw_clr_create(drw, &drw->scheme[ColFg], buf);
+          i += 7;
+        } else if (text[i] == 'b') {
+          char buf[8];
+          memcpy(buf, (char *)text + i + 1, 7);
+          buf[7] = '\0';
+          drw_clr_create(drw, &drw->scheme[ColBg], buf);
+          i += 7;
+        } else if (text[i] == 'd') {
+          drw->scheme[ColFg] = scheme[SchemeNorm][ColFg];
+          drw->scheme[ColBg] = scheme[SchemeNorm][ColBg];
+        } else if (text[i] == 'r') {
+          int rx = atoi(text + ++i);
+          while (text[++i] != ',')
+            ;
+          int ry = atoi(text + ++i);
+          while (text[++i] != ',')
+            ;
+          int rw = atoi(text + ++i);
+          while (text[++i] != ',')
+            ;
+          int rh = atoi(text + ++i);
+
+          drw_rect(drw, rx + x, ry + barpadding, rw, rh, 1, 0);
+        } else if (text[i] == 'f') {
+          x += atoi(text + ++i);
+        }
+      }
+
+      text = text + i + 1;
+      i = -1;
+      isCode = 0;
+    }
+  }
+
+  if (!isCode) {
+    w = TEXTW(text) - lrpad;
+    drw_text(drw, x, barpadding, w, bh, 0, text, 0);
+  }
+
+  drw_setscheme(drw, scheme[SchemeNorm]);
+  free(p);
+
+  return ret;
+}
+
+void drawbar(Monitor *m) {
+  int x, y = barpadding, w, tw = 0, stw = 0;
+  int th = bh - barpadding * 2;
+  int mw = m->ww - barpadding * 2;
+  int boxs = drw->fonts->h / 9;
+  int boxw = drw->fonts->h / 6 + 2;
   int maxtagw = 0;
-	unsigned int i, occ = 0, urg = 0;
-	const char *tagtext;
-	Client *c;
-
-	XSetForeground(drw->dpy, drw->gc, clrborder.pixel);
-	XFillRectangle(drw->dpy, drw->drawable, drw->gc, 0, 0, m->ww, bh);
-
-	if (!m->showbar)
-		return;
-
-	if(showsystray && m == systraytomon(m) && !systrayonleft)
-		stw = getsystraywidth();
-
-	/* draw status first so it can be overdrawn by tags later */
-	if (m == selmon) { /* status is only drawn on selected monitor */
-		tw = mw - drawstatusbar(m, th, stext);
-	}
-
-	resizebarwin(m);
-	for (c = m->clients; c; c = c->next) {
-		occ |= c->tags;
-		if (c->isurgent)
-			urg |= c->tags;
-	}
-	x = barpadding / 2;
-
-  for (i = 0; i<LENGTH(tags); i++) {
-		tagtext = occ & 1 << i ? alttags[i] : tags[i];
+  unsigned int i, occ = 0, urg = 0;
+  const char *tagtext;
+  Client *c;
+
+  XSetForeground(drw->dpy, drw->gc, clrborder.pixel);
+  XFillRectangle(drw->dpy, drw->drawable, drw->gc, 0, 0, m->ww, bh);
+
+  if (!m->showbar)
+    return;
+
+  if (showsystray && m == systraytomon(m) && !systrayonleft)
+    stw = getsystraywidth();
+
+  /* draw status first so it can be overdrawn by tags later */
+  if (m == selmon) { /* status is only drawn on selected monitor */
+    tw = mw - drawstatusbar(m, th, stext);
+  }
+
+  resizebarwin(m);
+  for (c = m->clients; c; c = c->next) {
+    occ |= c->tags;
+    if (c->isurgent)
+      urg |= c->tags;
+  }
+  x = barpadding / 2;
+
+  for (i = 0; i < LENGTH(tags); i++) {
+    tagtext = occ & 1 << i ? alttags[i] : tags[i];
     maxtagw = MAX(maxtagw, TEXTW(tagtext));
   }
 
-	for (i = 0; i < LENGTH(tags); i++) {
-		tagtext = occ & 1 << i ? alttags[i] : tags[i];
-		w = TEXTW(tagtext);
-    drw_setscheme(drw, scheme[occ & 1 << i ? (m->colorfultag ? tagschemes[i] : SchemeSel) : SchemeTag]);
-		drw_text(drw, x + barpadding, y, maxtagw - 2 * barpadding, bh - 2 * barpadding, (maxtagw - w)/2 + barpadding, tagtext, urg & 1 << i);
+  for (i = 0; i < LENGTH(tags); i++) {
+    tagtext = occ & 1 << i ? alttags[i] : tags[i];
+    w = TEXTW(tagtext);
+    drw_setscheme(
+        drw, scheme[occ & 1 << i ? (m->colorfultag ? tagschemes[i] : SchemeSel)
+                                 : SchemeTag]);
+    drw_text(drw, x + barpadding, y, maxtagw - 2 * barpadding,
+             bh - 2 * barpadding, (maxtagw - w) / 2 + barpadding, tagtext,
+             urg & 1 << i);
     drw_setscheme(drw, scheme[SchemeSel]);
-		if (ulineall || m->tagset[m->seltags] & 1 << i)
-			drw_rect(drw, x + ulinepad, bh - ulinestroke - ulinevoffset, maxtagw - (ulinepad * 2), ulinestroke, 1, 0);
-		x += (maxtagw - barpadding);
-	}
+    if (ulineall || m->tagset[m->seltags] & 1 << i)
+      drw_rect(drw, x + ulinepad, bh - ulinestroke - ulinevoffset,
+               maxtagw - (ulinepad * 2), ulinestroke, 1, 0);
+    x += (maxtagw - barpadding);
+  }
   x += barpadding;
-	w = TEXTW(m->ltsymbol);
-	drw_setscheme(drw, scheme[SchemeLayout]);
-	x = drw_text(drw, x, y, w, th, lrpad / 2, m->ltsymbol, 0);
-
-	if ((w = mw - tw - stw - x) > th) {
-		if (m->sel) {
-			drw_setscheme(drw, scheme[m == selmon ? SchemeSel : SchemeNorm]);
-			drw_text(drw, x, y, w, th, lrpad / 2 + (m->sel->icon ? m->sel->icw + ICONSPACING : 0), m->sel->name, 0);
-			if (m->sel->icon) drw_pic(drw, x + lrpad / 2, (th - m->sel->ich) / 2 + barpadding, m->sel->icw, m->sel->ich, m->sel->icon);
-			if (m->sel->isfloating)
-				drw_rect(drw, x + boxs, y + boxs, boxw, boxw, m->sel->isfixed, 0);
-		} else {
-			drw_setscheme(drw, scheme[SchemeNorm]);
-			drw_rect(drw, x, y, w, th, 1, 1);
-		}
-	}
-	drw_map(drw, m->barwin, 0, 0, m->ww - stw, bh);
-}
-
-void
-drawbars(void)
-{
-	Monitor *m;
-
-	for (m = mons; m; m = m->next)
-		drawbar(m);
-}
-
-void
-expose(XEvent *e)
-{
-	Monitor *m;
-	XExposeEvent *ev = &e->xexpose;
-
-	if (ev->count == 0 && (m = wintomon(ev->window))) {
-		drawbar(m);
-		if (m == selmon)
-			updatesystray();
-	}
-}
-
-void
-focus(Client *c)
-{
-	if (!c || !ISVISIBLE(c))
-		for (c = selmon->stack; c && !ISVISIBLE(c); c = c->snext);
-	if (selmon->sel && selmon->sel != c)
-		unfocus(selmon->sel, 0);
-	if (c) {
-		if (c->mon != selmon)
-			selmon = c->mon;
-		if (c->isurgent)
-			seturgent(c, 0);
-		detachstack(c);
-		attachstack(c);
-		grabbuttons(c, 1);
-		XSetWindowBorder(dpy, c->win, scheme[SchemeSel][ColBorder].pixel);
-		setfocus(c);
-	} else {
-		XSetInputFocus(dpy, root, RevertToPointerRoot, CurrentTime);
-		XDeleteProperty(dpy, root, netatom[NetActiveWindow]);
-	}
-	selmon->sel = c;
-	drawbars();
+  w = TEXTW(m->ltsymbol);
+  drw_setscheme(drw, scheme[SchemeLayout]);
+  x = drw_text(drw, x, y, w, th, lrpad / 2, m->ltsymbol, 0);
+
+  if ((w = mw - tw - stw - x) > th) {
+    if (m->sel) {
+      drw_setscheme(drw, scheme[m == selmon ? SchemeSel : SchemeNorm]);
+      drw_text(drw, x, y, w, th,
+               lrpad / 2 + (m->sel->icon ? m->sel->icw + ICONSPACING : 0),
+               m->sel->name, 0);
+      if (m->sel->icon)
+        drw_pic(drw, x + lrpad / 2, (th - m->sel->ich) / 2 + barpadding,
+                m->sel->icw, m->sel->ich, m->sel->icon);
+      if (m->sel->isfloating)
+        drw_rect(drw, x + boxs, y + boxs, boxw, boxw, m->sel->isfixed, 0);
+    } else {
+      drw_setscheme(drw, scheme[SchemeNorm]);
+      drw_rect(drw, x, y, w, th, 1, 1);
+    }
+  }
+  drw_map(drw, m->barwin, 0, 0, m->ww - stw, bh);
+}
+
+void drawbars(void) {
+  Monitor *m;
+
+  for (m = mons; m; m = m->next)
+    drawbar(m);
+}
+
+void expose(XEvent *e) {
+  Monitor *m;
+  XExposeEvent *ev = &e->xexpose;
+
+  if (ev->count == 0 && (m = wintomon(ev->window))) {
+    drawbar(m);
+    if (m == selmon)
+      updatesystray();
+  }
+}
+
+void focus(Client *c) {
+  if (!c || !ISVISIBLE(c))
+    for (c = selmon->stack; c && !ISVISIBLE(c); c = c->snext)
+      ;
+  if (selmon->sel && selmon->sel != c)
+    unfocus(selmon->sel, 0);
+  if (c) {
+    if (c->mon != selmon)
+      selmon = c->mon;
+    if (c->isurgent)
+      seturgent(c, 0);
+    detachstack(c);
+    attachstack(c);
+    grabbuttons(c, 1);
+    XSetWindowBorder(dpy, c->win, scheme[SchemeSel][ColBorder].pixel);
+    setfocus(c);
+  } else {
+    XSetInputFocus(dpy, root, RevertToPointerRoot, CurrentTime);
+    XDeleteProperty(dpy, root, netatom[NetActiveWindow]);
+  }
+  selmon->sel = c;
+  drawbars();
 }
 
 /* there are some broken focus acquiring clients needing extra handling */
-void
-focusin(XEvent *e)
-{
-	XFocusChangeEvent *ev = &e->xfocus;
-
-	if (selmon->sel && ev->window != selmon->sel->win)
-		setfocus(selmon->sel);
-}
-
-void
-focusmon(const Arg *arg)
-{
-	Monitor *m;
-
-	if (!mons->next)
-		return;
-	if ((m = dirtomon(arg->i)) == selmon)
-		return;
-	unfocus(selmon->sel, 0);
-	selmon = m;
-	focus(NULL);
-}
-
-void
-focusstack(const Arg *arg)
-{
-	Client *c = NULL, *i;
-
-	if (!selmon->sel || (selmon->sel->isfullscreen && lockfullscreen))
-		return;
-	if (arg->i > 0) {
-		for (c = selmon->sel->next; c && !ISVISIBLE(c); c = c->next);
-		if (!c)
-			for (c = selmon->clients; c && !ISVISIBLE(c); c = c->next);
-	} else {
-		for (i = selmon->clients; i != selmon->sel; i = i->next)
-			if (ISVISIBLE(i))
-				c = i;
-		if (!c)
-			for (; i; i = i->next)
-				if (ISVISIBLE(i))
-					c = i;
-	}
-	if (c) {
-		focus(c);
-		restack(selmon);
-	}
-}
-
-Atom
-getatomprop(Client *c, Atom prop)
-{
-	int di;
-	unsigned long dl;
-	unsigned char *p = NULL;
-	Atom da, atom = None;
-
-	/* FIXME getatomprop should return the number of items and a pointer to
-	 * the stored data instead of this workaround */
-	Atom req = XA_ATOM;
-	if (prop == xatom[XembedInfo])
-		req = xatom[XembedInfo];
-
-	if (XGetWindowProperty(dpy, c->win, prop, 0L, sizeof atom, False, req,
-		&da, &di, &dl, &dl, &p) == Success && p) {
-		atom = *(Atom *)p;
-		if (da == xatom[XembedInfo] && dl == 2)
-			atom = ((Atom *)p)[1];
-		XFree(p);
-	}
-	return atom;
+void focusin(XEvent *e) {
+  XFocusChangeEvent *ev = &e->xfocus;
+
+  if (selmon->sel && ev->window != selmon->sel->win)
+    setfocus(selmon->sel);
+}
+
+void focusmon(const Arg *arg) {
+  Monitor *m;
+
+  if (!mons->next)
+    return;
+  if ((m = dirtomon(arg->i)) == selmon)
+    return;
+  unfocus(selmon->sel, 0);
+  selmon = m;
+  focus(NULL);
+}
+
+void focusstack(const Arg *arg) {
+  Client *c = NULL, *i;
+
+  if (!selmon->sel || (selmon->sel->isfullscreen && lockfullscreen))
+    return;
+  if (arg->i > 0) {
+    for (c = selmon->sel->next; c && !ISVISIBLE(c); c = c->next)
+      ;
+    if (!c)
+      for (c = selmon->clients; c && !ISVISIBLE(c); c = c->next)
+        ;
+  } else {
+    for (i = selmon->clients; i != selmon->sel; i = i->next)
+      if (ISVISIBLE(i))
+        c = i;
+    if (!c)
+      for (; i; i = i->next)
+        if (ISVISIBLE(i))
+          c = i;
+  }
+  if (c) {
+    focus(c);
+    restack(selmon);
+  }
+}
+
+Atom getatomprop(Client *c, Atom prop) {
+  int di;
+  unsigned long dl;
+  unsigned char *p = NULL;
+  Atom da, atom = None;
+
+  /* FIXME getatomprop should return the number of items and a pointer to
+   * the stored data instead of this workaround */
+  Atom req = XA_ATOM;
+  if (prop == xatom[XembedInfo])
+    req = xatom[XembedInfo];
+
+  if (XGetWindowProperty(dpy, c->win, prop, 0L, sizeof atom, False, req, &da,
+                         &di, &dl, &dl, &p) == Success &&
+      p) {
+    atom = *(Atom *)p;
+    if (da == xatom[XembedInfo] && dl == 2)
+      atom = ((Atom *)p)[1];
+    XFree(p);
+  }
+  return atom;
 }
 
 static uint32_t prealpha(uint32_t p) {
-	uint8_t a = p >> 24u;
-	uint32_t rb = (a * (p & 0xFF00FFu)) >> 8u;
-	uint32_t g = (a * (p & 0x00FF00u)) >> 8u;
-	return (rb & 0xFF00FFu) | (g & 0x00FF00u) | (a << 24u);
-}
-
-Picture
-geticonprop(Window win, unsigned int *picw, unsigned int *pich)
-{
-	int format;
-	unsigned long n, extra, *p = NULL;
-	Atom real;
-
-	if (XGetWindowProperty(dpy, win, netatom[NetWMIcon], 0L, LONG_MAX, False, AnyPropertyType, 
-						   &real, &format, &n, &extra, (unsigned char **)&p) != Success)
-		return None; 
-	if (n == 0 || format != 32) { XFree(p); return None; }
-
-	unsigned long *bstp = NULL;
-	uint32_t w, h, sz;
-	{
-		unsigned long *i; const unsigned long *end = p + n;
-		uint32_t bstd = UINT32_MAX, d, m;
-		for (i = p; i < end - 1; i += sz) {
-			if ((w = *i++) >= 16384 || (h = *i++) >= 16384) { XFree(p); return None; }
-			if ((sz = w * h) > end - i) break;
-			if ((m = w > h ? w : h) >= ICONSIZE && (d = m - ICONSIZE) < bstd) { bstd = d; bstp = i; }
-		}
-		if (!bstp) {
-			for (i = p; i < end - 1; i += sz) {
-				if ((w = *i++) >= 16384 || (h = *i++) >= 16384) { XFree(p); return None; }
-				if ((sz = w * h) > end - i) break;
-				if ((d = ICONSIZE - (w > h ? w : h)) < bstd) { bstd = d; bstp = i; }
-			}
-		}
-		if (!bstp) { XFree(p); return None; }
-	}
-
-	if ((w = *(bstp - 2)) == 0 || (h = *(bstp - 1)) == 0) { XFree(p); return None; }
-
-	uint32_t icw, ich;
-	if (w <= h) {
-		ich = ICONSIZE; icw = w * ICONSIZE / h;
-		if (icw == 0) icw = 1;
-	}
-	else {
-		icw = ICONSIZE; ich = h * ICONSIZE / w;
-		if (ich == 0) ich = 1;
-	}
-	*picw = icw; *pich = ich;
-
-	uint32_t i, *bstp32 = (uint32_t *)bstp;
-	for (sz = w * h, i = 0; i < sz; ++i) bstp32[i] = prealpha(bstp[i]);
-
-	Picture ret = drw_picture_create_resized(drw, (char *)bstp, w, h, icw, ich);
-	XFree(p);
-
-	return ret;
-}
-
-int
-getrootptr(int *x, int *y)
-{
-	int di;
-	unsigned int dui;
-	Window dummy;
-
-	return XQueryPointer(dpy, root, &dummy, &dummy, x, y, &di, &di, &dui);
-}
-
-long
-getstate(Window w)
-{
-	int format;
-	long result = -1;
-	unsigned char *p = NULL;
-	unsigned long n, extra;
-	Atom real;
-
-	if (XGetWindowProperty(dpy, w, wmatom[WMState], 0L, 2L, False, wmatom[WMState],
-		&real, &format, &n, &extra, (unsigned char **)&p) != Success)
-		return -1;
-	if (n != 0)
-		result = *p;
-	XFree(p);
-	return result;
-}
-
-unsigned int
-getsystraywidth()
-{
-	unsigned int w = 0;
-	Client *i;
-	if(showsystray)
-		for(i = systray->icons; i; w += i->w + systrayspacing, i = i->next) ;
-	return w ? w + systrayspacing : 1;
-}
-
-int
-gettextprop(Window w, Atom atom, char *text, unsigned int size)
-{
-	char **list = NULL;
-	int n;
-	XTextProperty name;
-
-	if (!text || size == 0)
-		return 0;
-	text[0] = '\0';
-	if (!XGetTextProperty(dpy, w, &name, atom) || !name.nitems)
-		return 0;
-	if (name.encoding == XA_STRING) {
-		strncpy(text, (char *)name.value, size - 1);
-	} else if (XmbTextPropertyToTextList(dpy, &name, &list, &n) >= Success && n > 0 && *list) {
-		strncpy(text, *list, size - 1);
-		XFreeStringList(list);
-	}
-	text[size - 1] = '\0';
-	XFree(name.value);
-	return 1;
-}
-
-void
-grabbuttons(Client *c, int focused)
-{
-	updatenumlockmask();
-	{
-		unsigned int i, j;
-		unsigned int modifiers[] = { 0, LockMask, numlockmask, numlockmask|LockMask };
-		XUngrabButton(dpy, AnyButton, AnyModifier, c->win);
-		if (!focused)
-			XGrabButton(dpy, AnyButton, AnyModifier, c->win, False,
-				BUTTONMASK, GrabModeSync, GrabModeSync, None, None);
-		for (i = 0; i < LENGTH(buttons); i++)
-			if (buttons[i].click == ClkClientWin)
-				for (j = 0; j < LENGTH(modifiers); j++)
-					XGrabButton(dpy, buttons[i].button,
-						buttons[i].mask | modifiers[j],
-						c->win, False, BUTTONMASK,
-						GrabModeAsync, GrabModeSync, None, None);
-	}
-}
-
-void
-grabkeys(void)
-{
-	updatenumlockmask();
-	{
-		unsigned int i, j, k;
-		unsigned int modifiers[] = { 0, LockMask, numlockmask, numlockmask|LockMask };
-		int start, end, skip;
-		KeySym *syms;
-
-		XUngrabKey(dpy, AnyKey, AnyModifier, root);
-		XDisplayKeycodes(dpy, &start, &end);
-		syms = XGetKeyboardMapping(dpy, start, end - start + 1, &skip);
-		if (!syms)
-			return;
-		for (k = start; k <= end; k++)
-			for (i = 0; i < LENGTH(keys); i++)
-				/* skip modifier codes, we do that ourselves */
-				if (keys[i].keysym == syms[(k - start) * skip])
-					for (j = 0; j < LENGTH(modifiers); j++)
-						XGrabKey(dpy, k,
-							 keys[i].mod | modifiers[j],
-							 root, True,
-							 GrabModeAsync, GrabModeAsync);
-		XFree(syms);
-	}
-}
-
-void
-incnmaster(const Arg *arg)
-{
-	selmon->nmaster = MAX(selmon->nmaster + arg->i, 0);
-	arrange(selmon);
+  uint8_t a = p >> 24u;
+  uint32_t rb = (a * (p & 0xFF00FFu)) >> 8u;
+  uint32_t g = (a * (p & 0x00FF00u)) >> 8u;
+  return (rb & 0xFF00FFu) | (g & 0x00FF00u) | (a << 24u);
+}
+
+Picture geticonprop(Window win, unsigned int *picw, unsigned int *pich) {
+  int format;
+  unsigned long n, extra, *p = NULL;
+  Atom real;
+
+  if (XGetWindowProperty(dpy, win, netatom[NetWMIcon], 0L, LONG_MAX, False,
+                         AnyPropertyType, &real, &format, &n, &extra,
+                         (unsigned char **)&p) != Success)
+    return None;
+  if (n == 0 || format != 32) {
+    XFree(p);
+    return None;
+  }
+
+  unsigned long *bstp = NULL;
+  uint32_t w, h, sz;
+  {
+    unsigned long *i;
+    const unsigned long *end = p + n;
+    uint32_t bstd = UINT32_MAX, d, m;
+    for (i = p; i < end - 1; i += sz) {
+      if ((w = *i++) >= 16384 || (h = *i++) >= 16384) {
+        XFree(p);
+        return None;
+      }
+      if ((sz = w * h) > end - i)
+        break;
+      if ((m = w > h ? w : h) >= ICONSIZE && (d = m - ICONSIZE) < bstd) {
+        bstd = d;
+        bstp = i;
+      }
+    }
+    if (!bstp) {
+      for (i = p; i < end - 1; i += sz) {
+        if ((w = *i++) >= 16384 || (h = *i++) >= 16384) {
+          XFree(p);
+          return None;
+        }
+        if ((sz = w * h) > end - i)
+          break;
+        if ((d = ICONSIZE - (w > h ? w : h)) < bstd) {
+          bstd = d;
+          bstp = i;
+        }
+      }
+    }
+    if (!bstp) {
+      XFree(p);
+      return None;
+    }
+  }
+
+  if ((w = *(bstp - 2)) == 0 || (h = *(bstp - 1)) == 0) {
+    XFree(p);
+    return None;
+  }
+
+  uint32_t icw, ich;
+  if (w <= h) {
+    ich = ICONSIZE;
+    icw = w * ICONSIZE / h;
+    if (icw == 0)
+      icw = 1;
+  } else {
+    icw = ICONSIZE;
+    ich = h * ICONSIZE / w;
+    if (ich == 0)
+      ich = 1;
+  }
+  *picw = icw;
+  *pich = ich;
+
+  uint32_t i, *bstp32 = (uint32_t *)bstp;
+  for (sz = w * h, i = 0; i < sz; ++i)
+    bstp32[i] = prealpha(bstp[i]);
+
+  Picture ret = drw_picture_create_resized(drw, (char *)bstp, w, h, icw, ich);
+  XFree(p);
+
+  return ret;
+}
+
+int getrootptr(int *x, int *y) {
+  int di;
+  unsigned int dui;
+  Window dummy;
+
+  return XQueryPointer(dpy, root, &dummy, &dummy, x, y, &di, &di, &dui);
+}
+
+long getstate(Window w) {
+  int format;
+  long result = -1;
+  unsigned char *p = NULL;
+  unsigned long n, extra;
+  Atom real;
+
+  if (XGetWindowProperty(dpy, w, wmatom[WMState], 0L, 2L, False,
+                         wmatom[WMState], &real, &format, &n, &extra,
+                         (unsigned char **)&p) != Success)
+    return -1;
+  if (n != 0)
+    result = *p;
+  XFree(p);
+  return result;
+}
+
+unsigned int getsystraywidth() {
+  unsigned int w = 0;
+  Client *i;
+  if (showsystray)
+    for (i = systray->icons; i; w += i->w + systrayspacing, i = i->next)
+      ;
+  return w ? w + systrayspacing : 1;
+}
+
+int gettextprop(Window w, Atom atom, char *text, unsigned int size) {
+  char **list = NULL;
+  int n;
+  XTextProperty name;
+
+  if (!text || size == 0)
+    return 0;
+  text[0] = '\0';
+  if (!XGetTextProperty(dpy, w, &name, atom) || !name.nitems)
+    return 0;
+  if (name.encoding == XA_STRING) {
+    strncpy(text, (char *)name.value, size - 1);
+  } else if (XmbTextPropertyToTextList(dpy, &name, &list, &n) >= Success &&
+             n > 0 && *list) {
+    strncpy(text, *list, size - 1);
+    XFreeStringList(list);
+  }
+  text[size - 1] = '\0';
+  XFree(name.value);
+  return 1;
+}
+
+void grabbuttons(Client *c, int focused) {
+  updatenumlockmask();
+  {
+    unsigned int i, j;
+    unsigned int modifiers[] = {0, LockMask, numlockmask,
+                                numlockmask | LockMask};
+    XUngrabButton(dpy, AnyButton, AnyModifier, c->win);
+    if (!focused)
+      XGrabButton(dpy, AnyButton, AnyModifier, c->win, False, BUTTONMASK,
+                  GrabModeSync, GrabModeSync, None, None);
+    for (i = 0; i < LENGTH(buttons); i++)
+      if (buttons[i].click == ClkClientWin)
+        for (j = 0; j < LENGTH(modifiers); j++)
+          XGrabButton(dpy, buttons[i].button, buttons[i].mask | modifiers[j],
+                      c->win, False, BUTTONMASK, GrabModeAsync, GrabModeSync,
+                      None, None);
+  }
+}
+
+void grabkeys(void) {
+  updatenumlockmask();
+  {
+    unsigned int i, j, k;
+    unsigned int modifiers[] = {0, LockMask, numlockmask,
+                                numlockmask | LockMask};
+    int start, end, skip;
+    KeySym *syms;
+
+    XUngrabKey(dpy, AnyKey, AnyModifier, root);
+    XDisplayKeycodes(dpy, &start, &end);
+    syms = XGetKeyboardMapping(dpy, start, end - start + 1, &skip);
+    if (!syms)
+      return;
+    for (k = start; k <= end; k++)
+      for (i = 0; i < LENGTH(keys); i++)
+        /* skip modifier codes, we do that ourselves */
+        if (keys[i].keysym == syms[(k - start) * skip])
+          for (j = 0; j < LENGTH(modifiers); j++)
+            XGrabKey(dpy, k, keys[i].mod | modifiers[j], root, True,
+                     GrabModeAsync, GrabModeAsync);
+    XFree(syms);
+  }
+}
+
+void incnmaster(const Arg *arg) {
+  selmon->nmaster = MAX(selmon->nmaster + arg->i, 0);
+  arrange(selmon);
 }
 
 #ifdef XINERAMA
-static int
-isuniquegeom(XineramaScreenInfo *unique, size_t n, XineramaScreenInfo *info)
-{
-	while (n--)
-		if (unique[n].x_org == info->x_org && unique[n].y_org == info->y_org
-		&& unique[n].width == info->width && unique[n].height == info->height)
-			return 0;
-	return 1;
+static int isuniquegeom(XineramaScreenInfo *unique, size_t n,
+                        XineramaScreenInfo *info) {
+  while (n--)
+    if (unique[n].x_org == info->x_org && unique[n].y_org == info->y_org &&
+        unique[n].width == info->width && unique[n].height == info->height)
+      return 0;
+  return 1;
 }
 #endif /* XINERAMA */
 
-void
-keypress(XEvent *e)
-{
-	unsigned int i;
-	KeySym keysym;
-	XKeyEvent *ev;
-
-	ev = &e->xkey;
-	keysym = XKeycodeToKeysym(dpy, (KeyCode)ev->keycode, 0);
-	for (i = 0; i < LENGTH(keys); i++)
-		if (keysym == keys[i].keysym
-		&& CLEANMASK(keys[i].mod) == CLEANMASK(ev->state)
-		&& keys[i].func)
-			keys[i].func(&(keys[i].arg));
-}
-
-void
-killclient(const Arg *arg)
-{
-	if (!selmon->sel)
-		return;
-
-	if (!sendevent(selmon->sel->win, wmatom[WMDelete], NoEventMask, wmatom[WMDelete], CurrentTime, 0 , 0, 0)) {
-		XGrabServer(dpy);
-		XSetErrorHandler(xerrordummy);
-		XSetCloseDownMode(dpy, DestroyAll);
-		XKillClient(dpy, selmon->sel->win);
-		XSync(dpy, False);
-		XSetErrorHandler(xerror);
-		XUngrabServer(dpy);
-	}
-}
-
-void
-manage(Window w, XWindowAttributes *wa)
-{
-	Client *c, *t = NULL;
-	Window trans = None;
-	XWindowChanges wc;
-
-	c = ecalloc(1, sizeof(Client));
-	c->win = w;
-	/* geometry */
-	c->x = c->oldx = wa->x;
-	c->y = c->oldy = wa->y;
-	c->w = c->oldw = wa->width;
-	c->h = c->oldh = wa->height;
-	c->oldbw = wa->border_width;
-
-	updateicon(c);
-	updatetitle(c);
-	if (XGetTransientForHint(dpy, w, &trans) && (t = wintoclient(trans))) {
-		c->mon = t->mon;
-		c->tags = t->tags;
-	} else {
-		c->mon = selmon;
-		applyrules(c);
-	}
-
-	if (c->x + WIDTH(c) > c->mon->wx + c->mon->ww)
-		c->x = c->mon->wx + c->mon->ww - WIDTH(c);
-	if (c->y + HEIGHT(c) > c->mon->wy + c->mon->wh)
-		c->y = c->mon->wy + c->mon->wh - HEIGHT(c);
-	c->x = MAX(c->x, c->mon->wx);
-	c->y = MAX(c->y, c->mon->wy);
-	c->bw = borderpx;
-
-	wc.border_width = c->bw;
-	XConfigureWindow(dpy, w, CWBorderWidth, &wc);
-	XSetWindowBorder(dpy, w, scheme[SchemeNorm][ColBorder].pixel);
-	configure(c); /* propagates border_width, if size doesn't change */
-	updatewindowtype(c);
-	updatesizehints(c);
-	updatewmhints(c);
-	XSelectInput(dpy, w, EnterWindowMask|FocusChangeMask|PropertyChangeMask|StructureNotifyMask);
-	grabbuttons(c, 0);
-	if (!c->isfloating)
-		c->isfloating = c->oldstate = trans != None || c->isfixed;
-	if (c->isfloating)
-		XRaiseWindow(dpy, c->win);
-	attachaside(c);
-	attachstack(c);
-	XChangeProperty(dpy, root, netatom[NetClientList], XA_WINDOW, 32, PropModeAppend,
-		(unsigned char *) &(c->win), 1);
-	XMoveResizeWindow(dpy, c->win, c->x + 2 * sw, c->y, c->w, c->h); /* some windows require this */
-	setclientstate(c, NormalState);
-	if (c->mon == selmon)
-		unfocus(selmon->sel, 0);
-	c->mon->sel = c;
-	arrange(c->mon);
-	XMapWindow(dpy, c->win);
-	focus(NULL);
-}
-
-void
-mappingnotify(XEvent *e)
-{
-	XMappingEvent *ev = &e->xmapping;
-
-	XRefreshKeyboardMapping(ev);
-	if (ev->request == MappingKeyboard)
-		grabkeys();
-}
-
-void
-maprequest(XEvent *e)
-{
-	static XWindowAttributes wa;
-	XMapRequestEvent *ev = &e->xmaprequest;
-
-	Client *i;
-	if ((i = wintosystrayicon(ev->window))) {
-		sendevent(i->win, netatom[Xembed], StructureNotifyMask, CurrentTime, XEMBED_WINDOW_ACTIVATE, 0, systray->win, XEMBED_EMBEDDED_VERSION);
-		resizebarwin(selmon);
-		updatesystray();
-	}
-
-	if (!XGetWindowAttributes(dpy, ev->window, &wa) || wa.override_redirect)
-		return;
-	if (!wintoclient(ev->window))
-		manage(ev->window, &wa);
-}
-
-void
-monocle(Monitor *m)
-{
-	unsigned int n = 0;
-	Client *c;
-
-	for (c = m->clients; c; c = c->next)
-		if (ISVISIBLE(c))
-			n++;
-	if (n > 0) /* override layout symbol */
-		snprintf(m->ltsymbol, sizeof m->ltsymbol, "Monocole [%d]", n);
-	for (c = nexttiled(m->clients); c; c = nexttiled(c->next))
-		resize(c, m->wx, m->wy, m->ww - 2 * c->bw, m->wh - 2 * c->bw, 0);
-}
-
-void
-movemouse(const Arg *arg)
-{
-	int x, y, ocx, ocy, nx, ny;
-	Client *c;
-	Monitor *m;
-	XEvent ev;
-	Time lasttime = 0;
-
-	if (!(c = selmon->sel))
-		return;
-	if (c->isfullscreen) /* no support moving fullscreen windows by mouse */
-		return;
-	restack(selmon);
-	ocx = c->x;
-	ocy = c->y;
-	if (XGrabPointer(dpy, root, False, MOUSEMASK, GrabModeAsync, GrabModeAsync,
-		None, cursor[CurMove]->cursor, CurrentTime) != GrabSuccess)
-		return;
-	if (!getrootptr(&x, &y))
-		return;
-	do {
-		XMaskEvent(dpy, MOUSEMASK|ExposureMask|SubstructureRedirectMask, &ev);
-		switch(ev.type) {
-		case ConfigureRequest:
-		case Expose:
-		case MapRequest:
-			handler[ev.type](&ev);
-			break;
-		case MotionNotify:
-			if ((ev.xmotion.time - lasttime) <= (1000 / 60))
-				continue;
-			lasttime = ev.xmotion.time;
-
-			nx = ocx + (ev.xmotion.x - x);
-			ny = ocy + (ev.xmotion.y - y);
-			if (abs(selmon->wx - nx) < snap)
-				nx = selmon->wx;
-			else if (abs((selmon->wx + selmon->ww) - (nx + WIDTH(c))) < snap)
-				nx = selmon->wx + selmon->ww - WIDTH(c);
-			if (abs(selmon->wy - ny) < snap)
-				ny = selmon->wy;
-			else if (abs((selmon->wy + selmon->wh) - (ny + HEIGHT(c))) < snap)
-				ny = selmon->wy + selmon->wh - HEIGHT(c);
-			if (!c->isfloating && selmon->lt[selmon->sellt]->arrange
-			&& (abs(nx - c->x) > snap || abs(ny - c->y) > snap))
-				togglefloating(NULL);
-			if (!selmon->lt[selmon->sellt]->arrange || c->isfloating)
-				resize(c, nx, ny, c->w, c->h, 1);
-			break;
-		}
-	} while (ev.type != ButtonRelease);
-	XUngrabPointer(dpy, CurrentTime);
-	if ((m = recttomon(c->x, c->y, c->w, c->h)) != selmon) {
-		sendmon(c, m);
-		selmon = m;
-		focus(NULL);
-	}
-}
-
-Client *
-nexttagged(Client *c) {
-	Client *walked = c->mon->clients;
-	for(;
-		walked && (walked->isfloating || !ISVISIBLEONTAG(walked, c->tags));
-		walked = walked->next
-	);
-	return walked;
-}
-
-Client *
-nexttiled(Client *c)
-{
-	for (; c && (c->isfloating || !ISVISIBLE(c)); c = c->next);
-	return c;
-}
-
-void
-pop(Client *c)
-{
-	detach(c);
-	attach(c);
-	focus(c);
-	arrange(c->mon);
-}
-
-void
-propertynotify(XEvent *e)
-{
-	Client *c;
-	Window trans;
-	XPropertyEvent *ev = &e->xproperty;
-
-	if ((c = wintosystrayicon(ev->window))) {
-		if (ev->atom == XA_WM_NORMAL_HINTS) {
-			updatesizehints(c);
-			updatesystrayicongeom(c, c->w, c->h);
-		}
-		else
-			updatesystrayiconstate(c, ev);
-		resizebarwin(selmon);
-		updatesystray();
-	}
-
-    if ((ev->window == root) && (ev->atom == XA_WM_NAME))
-		updatestatus();
-	else if (ev->state == PropertyDelete)
-		return; /* ignore */
-	else if ((c = wintoclient(ev->window))) {
-		switch(ev->atom) {
-		default: break;
-		case XA_WM_TRANSIENT_FOR:
-			if (!c->isfloating && (XGetTransientForHint(dpy, c->win, &trans)) &&
-				(c->isfloating = (wintoclient(trans)) != NULL))
-				arrange(c->mon);
-			break;
-		case XA_WM_NORMAL_HINTS:
-			c->hintsvalid = 0;
-			break;
-		case XA_WM_HINTS:
-			updatewmhints(c);
-			drawbars();
-			break;
-		}
-		if (ev->atom == XA_WM_NAME || ev->atom == netatom[NetWMName]) {
-			updatetitle(c);
-			if (c == c->mon->sel)
-				drawbar(c->mon);
-		}
-		else if (ev->atom == netatom[NetWMIcon]) {
-			updateicon(c);
-			if (c == c->mon->sel)
-				drawbar(c->mon);
-		}
-		if (ev->atom == netatom[NetWMWindowType])
-			updatewindowtype(c);
-	}
-}
-
-void
-quit(const Arg *arg)
-{
-	running = 0;
-}
-
-Monitor *
-recttomon(int x, int y, int w, int h)
-{
-	Monitor *m, *r = selmon;
-	int a, area = 0;
-
-	for (m = mons; m; m = m->next)
-		if ((a = INTERSECT(x, y, w, h, m)) > area) {
-			area = a;
-			r = m;
-		}
-	return r;
-}
-
-void
-removesystrayicon(Client *i)
-{
-	Client **ii;
-
-	if (!showsystray || !i)
-		return;
-	for (ii = &systray->icons; *ii && *ii != i; ii = &(*ii)->next);
-	if (ii)
-		*ii = i->next;
-	free(i);
-}
-
-void
-resize(Client *c, int x, int y, int w, int h, int interact)
-{
-	if (applysizehints(c, &x, &y, &w, &h, interact))
-		resizeclient(c, x, y, w, h);
-}
-
-void
-resizebarwin(Monitor *m) {
-	unsigned int w = m->ww;
-	if (showsystray && m == systraytomon(m) && !systrayonleft)
-		w -= getsystraywidth();
-	XMoveResizeWindow(dpy, m->barwin, m->wx, m->by, w, bh);
-}
-
-void
-resizeclient(Client *c, int x, int y, int w, int h)
-{
-	XWindowChanges wc;
-
-	c->oldx = c->x; c->x = wc.x = x;
-	c->oldy = c->y; c->y = wc.y = y;
-	c->oldw = c->w; c->w = wc.width = w;
-	c->oldh = c->h; c->h = wc.height = h;
-	wc.border_width = c->bw;
-	XConfigureWindow(dpy, c->win, CWX|CWY|CWWidth|CWHeight|CWBorderWidth, &wc);
-	configure(c);
-	XSync(dpy, False);
-}
-
-void
-resizemouse(const Arg *arg)
-{
-	int ocx, ocy, nw, nh;
-	Client *c;
-	Monitor *m;
-	XEvent ev;
-	Time lasttime = 0;
-
-	if (!(c = selmon->sel))
-		return;
-	if (c->isfullscreen) /* no support resizing fullscreen windows by mouse */
-		return;
-	restack(selmon);
-	ocx = c->x;
-	ocy = c->y;
-	if (XGrabPointer(dpy, root, False, MOUSEMASK, GrabModeAsync, GrabModeAsync,
-		None, cursor[CurResize]->cursor, CurrentTime) != GrabSuccess)
-		return;
-	XWarpPointer(dpy, None, c->win, 0, 0, 0, 0, c->w + c->bw - 1, c->h + c->bw - 1);
-	do {
-		XMaskEvent(dpy, MOUSEMASK|ExposureMask|SubstructureRedirectMask, &ev);
-		switch(ev.type) {
-		case ConfigureRequest:
-		case Expose:
-		case MapRequest:
-			handler[ev.type](&ev);
-			break;
-		case MotionNotify:
-			if ((ev.xmotion.time - lasttime) <= (1000 / 60))
-				continue;
-			lasttime = ev.xmotion.time;
-
-			nw = MAX(ev.xmotion.x - ocx - 2 * c->bw + 1, 1);
-			nh = MAX(ev.xmotion.y - ocy - 2 * c->bw + 1, 1);
-			if (c->mon->wx + nw >= selmon->wx && c->mon->wx + nw <= selmon->wx + selmon->ww
-			&& c->mon->wy + nh >= selmon->wy && c->mon->wy + nh <= selmon->wy + selmon->wh)
-			{
-				if (!c->isfloating && selmon->lt[selmon->sellt]->arrange
-				&& (abs(nw - c->w) > snap || abs(nh - c->h) > snap))
-					togglefloating(NULL);
-			}
-			if (!selmon->lt[selmon->sellt]->arrange || c->isfloating)
-				resize(c, c->x, c->y, nw, nh, 1);
-			break;
-		}
-	} while (ev.type != ButtonRelease);
-	XWarpPointer(dpy, None, c->win, 0, 0, 0, 0, c->w + c->bw - 1, c->h + c->bw - 1);
-	XUngrabPointer(dpy, CurrentTime);
-	while (XCheckMaskEvent(dpy, EnterWindowMask, &ev));
-	if ((m = recttomon(c->x, c->y, c->w, c->h)) != selmon) {
-		sendmon(c, m);
-		selmon = m;
-		focus(NULL);
-	}
-}
-
-void
-resizerequest(XEvent *e)
-{
-	XResizeRequestEvent *ev = &e->xresizerequest;
-	Client *i;
-
-	if ((i = wintosystrayicon(ev->window))) {
-		updatesystrayicongeom(i, ev->width, ev->height);
-		resizebarwin(selmon);
-		updatesystray();
-	}
-}
-
-void
-restack(Monitor *m)
-{
-	Client *c;
-	XEvent ev;
-	XWindowChanges wc;
-
-	drawbar(m);
-	if (!m->sel)
-		return;
-	if (m->sel->isfloating || !m->lt[m->sellt]->arrange)
-		XRaiseWindow(dpy, m->sel->win);
-	if (m->lt[m->sellt]->arrange) {
-		wc.stack_mode = Below;
-		wc.sibling = m->barwin;
-		for (c = m->stack; c; c = c->snext)
-			if (!c->isfloating && ISVISIBLE(c)) {
-				XConfigureWindow(dpy, c->win, CWSibling|CWStackMode, &wc);
-				wc.sibling = c->win;
-			}
-	}
-	XSync(dpy, False);
-	while (XCheckMaskEvent(dpy, EnterWindowMask, &ev));
-}
-
-void
-run(void)
-{
-	XEvent ev;
-	/* main event loop */
-	XSync(dpy, False);
-	while (running && !XNextEvent(dpy, &ev))
-		if (handler[ev.type])
-			handler[ev.type](&ev); /* call handler */
-}
-
-void
-runAutostart(void) {
-	system("cd ~/.dwm; ./autostart_blocking.sh");
-	system("cd ~/.dwm; ./autostart.sh &");
-}
-
-void
-scan(void)
-{
-	unsigned int i, num;
-	Window d1, d2, *wins = NULL;
-	XWindowAttributes wa;
-
-	if (XQueryTree(dpy, root, &d1, &d2, &wins, &num)) {
-		for (i = 0; i < num; i++) {
-			if (!XGetWindowAttributes(dpy, wins[i], &wa)
-			|| wa.override_redirect || XGetTransientForHint(dpy, wins[i], &d1))
-				continue;
-			if (wa.map_state == IsViewable || getstate(wins[i]) == IconicState)
-				manage(wins[i], &wa);
-		}
-		for (i = 0; i < num; i++) { /* now the transients */
-			if (!XGetWindowAttributes(dpy, wins[i], &wa))
-				continue;
-			if (XGetTransientForHint(dpy, wins[i], &d1)
-			&& (wa.map_state == IsViewable || getstate(wins[i]) == IconicState))
-				manage(wins[i], &wa);
-		}
-		if (wins)
-			XFree(wins);
-	}
-}
-
-void
-sendmon(Client *c, Monitor *m)
-{
-	if (c->mon == m)
-		return;
-	unfocus(c, 1);
-	detach(c);
-	detachstack(c);
-	c->mon = m;
-	c->tags = m->tagset[m->seltags]; /* assign tags of target monitor */
-	attachaside(c);
-	attachstack(c);
-	focus(NULL);
-	arrange(NULL);
-}
-
-void
-setclientstate(Client *c, long state)
-{
-	long data[] = { state, None };
-
-	XChangeProperty(dpy, c->win, wmatom[WMState], wmatom[WMState], 32,
-		PropModeReplace, (unsigned char *)data, 2);
-}
-
-int
-sendevent(Window w, Atom proto, int mask, long d0, long d1, long d2, long d3, long d4)
-{
-	int n;
-	Atom *protocols, mt;
-	int exists = 0;
-	XEvent ev;
-
-	if (proto == wmatom[WMTakeFocus] || proto == wmatom[WMDelete]) {
-		mt = wmatom[WMProtocols];
-		if (XGetWMProtocols(dpy, w, &protocols, &n)) {
-			while (!exists && n--)
-				exists = protocols[n] == proto;
-			XFree(protocols);
-		}
-	}
-	else {
-		exists = True;
-		mt = proto;
+void keypress(XEvent *e) {
+  unsigned int i;
+  KeySym keysym;
+  XKeyEvent *ev;
+
+  ev = &e->xkey;
+  keysym = XKeycodeToKeysym(dpy, (KeyCode)ev->keycode, 0);
+  for (i = 0; i < LENGTH(keys); i++)
+    if (keysym == keys[i].keysym &&
+        CLEANMASK(keys[i].mod) == CLEANMASK(ev->state) && keys[i].func)
+      keys[i].func(&(keys[i].arg));
+}
+
+void killclient(const Arg *arg) {
+  if (!selmon->sel)
+    return;
+
+  if (!sendevent(selmon->sel->win, wmatom[WMDelete], NoEventMask,
+                 wmatom[WMDelete], CurrentTime, 0, 0, 0)) {
+    XGrabServer(dpy);
+    XSetErrorHandler(xerrordummy);
+    XSetCloseDownMode(dpy, DestroyAll);
+    XKillClient(dpy, selmon->sel->win);
+    XSync(dpy, False);
+    XSetErrorHandler(xerror);
+    XUngrabServer(dpy);
+  }
+}
+
+void manage(Window w, XWindowAttributes *wa) {
+  Client *c, *t = NULL;
+  Window trans = None;
+  XWindowChanges wc;
+
+  c = ecalloc(1, sizeof(Client));
+  c->win = w;
+  /* geometry */
+  c->x = c->oldx = wa->x;
+  c->y = c->oldy = wa->y;
+  c->w = c->oldw = wa->width;
+  c->h = c->oldh = wa->height;
+  c->oldbw = wa->border_width;
+
+  updateicon(c);
+  updatetitle(c);
+  if (XGetTransientForHint(dpy, w, &trans) && (t = wintoclient(trans))) {
+    c->mon = t->mon;
+    c->tags = t->tags;
+  } else {
+    c->mon = selmon;
+    applyrules(c);
+  }
+
+  if (c->x + WIDTH(c) > c->mon->wx + c->mon->ww)
+    c->x = c->mon->wx + c->mon->ww - WIDTH(c);
+  if (c->y + HEIGHT(c) > c->mon->wy + c->mon->wh)
+    c->y = c->mon->wy + c->mon->wh - HEIGHT(c);
+  c->x = MAX(c->x, c->mon->wx);
+  c->y = MAX(c->y, c->mon->wy);
+  c->bw = borderpx;
+
+  wc.border_width = c->bw;
+  XConfigureWindow(dpy, w, CWBorderWidth, &wc);
+  XSetWindowBorder(dpy, w, scheme[SchemeNorm][ColBorder].pixel);
+  configure(c); /* propagates border_width, if size doesn't change */
+  updatewindowtype(c);
+  updatesizehints(c);
+  updatewmhints(c);
+  XSelectInput(dpy, w,
+               EnterWindowMask | FocusChangeMask | PropertyChangeMask |
+                   StructureNotifyMask);
+  grabbuttons(c, 0);
+  if (!c->isfloating)
+    c->isfloating = c->oldstate = trans != None || c->isfixed;
+  if (c->isfloating)
+    XRaiseWindow(dpy, c->win);
+  attachaside(c);
+  attachstack(c);
+  XChangeProperty(dpy, root, netatom[NetClientList], XA_WINDOW, 32,
+                  PropModeAppend, (unsigned char *)&(c->win), 1);
+  XMoveResizeWindow(dpy, c->win, c->x + 2 * sw, c->y, c->w,
+                    c->h); /* some windows require this */
+  setclientstate(c, NormalState);
+  if (c->mon == selmon)
+    unfocus(selmon->sel, 0);
+  c->mon->sel = c;
+  arrange(c->mon);
+  XMapWindow(dpy, c->win);
+  focus(NULL);
+}
+
+void mappingnotify(XEvent *e) {
+  XMappingEvent *ev = &e->xmapping;
+
+  XRefreshKeyboardMapping(ev);
+  if (ev->request == MappingKeyboard)
+    grabkeys();
+}
+
+void maprequest(XEvent *e) {
+  static XWindowAttributes wa;
+  XMapRequestEvent *ev = &e->xmaprequest;
+
+  Client *i;
+  if ((i = wintosystrayicon(ev->window))) {
+    sendevent(i->win, netatom[Xembed], StructureNotifyMask, CurrentTime,
+              XEMBED_WINDOW_ACTIVATE, 0, systray->win, XEMBED_EMBEDDED_VERSION);
+    resizebarwin(selmon);
+    updatesystray();
+  }
+
+  if (!XGetWindowAttributes(dpy, ev->window, &wa) || wa.override_redirect)
+    return;
+  if (!wintoclient(ev->window))
+    manage(ev->window, &wa);
+}
+
+void monocle(Monitor *m) {
+  unsigned int n = 0;
+  Client *c;
+
+  for (c = m->clients; c; c = c->next)
+    if (ISVISIBLE(c))
+      n++;
+  if (n > 0) /* override layout symbol */
+    snprintf(m->ltsymbol, sizeof m->ltsymbol, "Monocole [%d]", n);
+  for (c = nexttiled(m->clients); c; c = nexttiled(c->next))
+    resize(c, m->wx, m->wy, m->ww - 2 * c->bw, m->wh - 2 * c->bw, 0);
+}
+
+void movemouse(const Arg *arg) {
+  int x, y, ocx, ocy, nx, ny;
+  Client *c;
+  Monitor *m;
+  XEvent ev;
+  Time lasttime = 0;
+
+  if (!(c = selmon->sel))
+    return;
+  if (c->isfullscreen) /* no support moving fullscreen windows by mouse */
+    return;
+  restack(selmon);
+  ocx = c->x;
+  ocy = c->y;
+  if (XGrabPointer(dpy, root, False, MOUSEMASK, GrabModeAsync, GrabModeAsync,
+                   None, cursor[CurMove]->cursor, CurrentTime) != GrabSuccess)
+    return;
+  if (!getrootptr(&x, &y))
+    return;
+  do {
+    XMaskEvent(dpy, MOUSEMASK | ExposureMask | SubstructureRedirectMask, &ev);
+    switch (ev.type) {
+    case ConfigureRequest:
+    case Expose:
+    case MapRequest:
+      handler[ev.type](&ev);
+      break;
+    case MotionNotify:
+      if ((ev.xmotion.time - lasttime) <= (1000 / 60))
+        continue;
+      lasttime = ev.xmotion.time;
+
+      nx = ocx + (ev.xmotion.x - x);
+      ny = ocy + (ev.xmotion.y - y);
+      if (abs(selmon->wx - nx) < snap)
+        nx = selmon->wx;
+      else if (abs((selmon->wx + selmon->ww) - (nx + WIDTH(c))) < snap)
+        nx = selmon->wx + selmon->ww - WIDTH(c);
+      if (abs(selmon->wy - ny) < snap)
+        ny = selmon->wy;
+      else if (abs((selmon->wy + selmon->wh) - (ny + HEIGHT(c))) < snap)
+        ny = selmon->wy + selmon->wh - HEIGHT(c);
+      if (!c->isfloating && selmon->lt[selmon->sellt]->arrange &&
+          (abs(nx - c->x) > snap || abs(ny - c->y) > snap))
+        togglefloating(NULL);
+      if (!selmon->lt[selmon->sellt]->arrange || c->isfloating)
+        resize(c, nx, ny, c->w, c->h, 1);
+      break;
+    }
+  } while (ev.type != ButtonRelease);
+  XUngrabPointer(dpy, CurrentTime);
+  if ((m = recttomon(c->x, c->y, c->w, c->h)) != selmon) {
+    sendmon(c, m);
+    selmon = m;
+    focus(NULL);
+  }
+}
+
+Client *nexttagged(Client *c) {
+  Client *walked = c->mon->clients;
+  for (; walked && (walked->isfloating || !ISVISIBLEONTAG(walked, c->tags));
+       walked = walked->next)
+    ;
+  return walked;
+}
+
+Client *nexttiled(Client *c) {
+  for (; c && (c->isfloating || !ISVISIBLE(c)); c = c->next)
+    ;
+  return c;
+}
+
+void pop(Client *c) {
+  detach(c);
+  attach(c);
+  focus(c);
+  arrange(c->mon);
+}
+
+void propertynotify(XEvent *e) {
+  Client *c;
+  Window trans;
+  XPropertyEvent *ev = &e->xproperty;
+
+  if ((c = wintosystrayicon(ev->window))) {
+    if (ev->atom == XA_WM_NORMAL_HINTS) {
+      updatesizehints(c);
+      updatesystrayicongeom(c, c->w, c->h);
+    } else
+      updatesystrayiconstate(c, ev);
+    resizebarwin(selmon);
+    updatesystray();
+  }
+
+  if ((ev->window == root) && (ev->atom == XA_WM_NAME))
+    updatestatus();
+  else if (ev->state == PropertyDelete)
+    return; /* ignore */
+  else if ((c = wintoclient(ev->window))) {
+    switch (ev->atom) {
+    default:
+      break;
+    case XA_WM_TRANSIENT_FOR:
+      if (!c->isfloating && (XGetTransientForHint(dpy, c->win, &trans)) &&
+          (c->isfloating = (wintoclient(trans)) != NULL))
+        arrange(c->mon);
+      break;
+    case XA_WM_NORMAL_HINTS:
+      c->hintsvalid = 0;
+      break;
+    case XA_WM_HINTS:
+      updatewmhints(c);
+      drawbars();
+      break;
+    }
+    if (ev->atom == XA_WM_NAME || ev->atom == netatom[NetWMName]) {
+      updatetitle(c);
+      if (c == c->mon->sel)
+        drawbar(c->mon);
+    } else if (ev->atom == netatom[NetWMIcon]) {
+      updateicon(c);
+      if (c == c->mon->sel)
+        drawbar(c->mon);
+    }
+    if (ev->atom == netatom[NetWMWindowType])
+      updatewindowtype(c);
+  }
+}
+
+void quit(const Arg *arg) { running = 0; }
+
+Monitor *recttomon(int x, int y, int w, int h) {
+  Monitor *m, *r = selmon;
+  int a, area = 0;
+
+  for (m = mons; m; m = m->next)
+    if ((a = INTERSECT(x, y, w, h, m)) > area) {
+      area = a;
+      r = m;
     }
+  return r;
+}
+
+void removesystrayicon(Client *i) {
+  Client **ii;
+
+  if (!showsystray || !i)
+    return;
+  for (ii = &systray->icons; *ii && *ii != i; ii = &(*ii)->next)
+    ;
+  if (ii)
+    *ii = i->next;
+  free(i);
+}
+
+void resize(Client *c, int x, int y, int w, int h, int interact) {
+  if (applysizehints(c, &x, &y, &w, &h, interact))
+    resizeclient(c, x, y, w, h);
+}
+
+void resizebarwin(Monitor *m) {
+  unsigned int w = m->ww;
+  if (showsystray && m == systraytomon(m) && !systrayonleft)
+    w -= getsystraywidth();
+  XMoveResizeWindow(dpy, m->barwin, m->wx, m->by, w, bh);
+}
+
+void resizeclient(Client *c, int x, int y, int w, int h) {
+  XWindowChanges wc;
+
+  c->oldx = c->x;
+  c->x = wc.x = x;
+  c->oldy = c->y;
+  c->y = wc.y = y;
+  c->oldw = c->w;
+  c->w = wc.width = w;
+  c->oldh = c->h;
+  c->h = wc.height = h;
+  wc.border_width = c->bw;
+  XConfigureWindow(dpy, c->win, CWX | CWY | CWWidth | CWHeight | CWBorderWidth,
+                   &wc);
+  configure(c);
+  XSync(dpy, False);
+}
+
+void resizemouse(const Arg *arg) {
+  int ocx, ocy, nw, nh;
+  Client *c;
+  Monitor *m;
+  XEvent ev;
+  Time lasttime = 0;
+
+  if (!(c = selmon->sel))
+    return;
+  if (c->isfullscreen) /* no support resizing fullscreen windows by mouse */
+    return;
+  restack(selmon);
+  ocx = c->x;
+  ocy = c->y;
+  if (XGrabPointer(dpy, root, False, MOUSEMASK, GrabModeAsync, GrabModeAsync,
+                   None, cursor[CurResize]->cursor, CurrentTime) != GrabSuccess)
+    return;
+  XWarpPointer(dpy, None, c->win, 0, 0, 0, 0, c->w + c->bw - 1,
+               c->h + c->bw - 1);
+  do {
+    XMaskEvent(dpy, MOUSEMASK | ExposureMask | SubstructureRedirectMask, &ev);
+    switch (ev.type) {
+    case ConfigureRequest:
+    case Expose:
+    case MapRequest:
+      handler[ev.type](&ev);
+      break;
+    case MotionNotify:
+      if ((ev.xmotion.time - lasttime) <= (1000 / 60))
+        continue;
+      lasttime = ev.xmotion.time;
+
+      nw = MAX(ev.xmotion.x - ocx - 2 * c->bw + 1, 1);
+      nh = MAX(ev.xmotion.y - ocy - 2 * c->bw + 1, 1);
+      if (c->mon->wx + nw >= selmon->wx &&
+          c->mon->wx + nw <= selmon->wx + selmon->ww &&
+          c->mon->wy + nh >= selmon->wy &&
+          c->mon->wy + nh <= selmon->wy + selmon->wh) {
+        if (!c->isfloating && selmon->lt[selmon->sellt]->arrange &&
+            (abs(nw - c->w) > snap || abs(nh - c->h) > snap))
+          togglefloating(NULL);
+      }
+      if (!selmon->lt[selmon->sellt]->arrange || c->isfloating)
+        resize(c, c->x, c->y, nw, nh, 1);
+      break;
+    }
+  } while (ev.type != ButtonRelease);
+  XWarpPointer(dpy, None, c->win, 0, 0, 0, 0, c->w + c->bw - 1,
+               c->h + c->bw - 1);
+  XUngrabPointer(dpy, CurrentTime);
+  while (XCheckMaskEvent(dpy, EnterWindowMask, &ev))
+    ;
+  if ((m = recttomon(c->x, c->y, c->w, c->h)) != selmon) {
+    sendmon(c, m);
+    selmon = m;
+    focus(NULL);
+  }
+}
+
+void resizerequest(XEvent *e) {
+  XResizeRequestEvent *ev = &e->xresizerequest;
+  Client *i;
+
+  if ((i = wintosystrayicon(ev->window))) {
+    updatesystrayicongeom(i, ev->width, ev->height);
+    resizebarwin(selmon);
+    updatesystray();
+  }
+}
+
+void restack(Monitor *m) {
+  Client *c;
+  XEvent ev;
+  XWindowChanges wc;
+
+  drawbar(m);
+  if (!m->sel)
+    return;
+  if (m->sel->isfloating || !m->lt[m->sellt]->arrange)
+    XRaiseWindow(dpy, m->sel->win);
+  if (m->lt[m->sellt]->arrange) {
+    wc.stack_mode = Below;
+    wc.sibling = m->barwin;
+    for (c = m->stack; c; c = c->snext)
+      if (!c->isfloating && ISVISIBLE(c)) {
+        XConfigureWindow(dpy, c->win, CWSibling | CWStackMode, &wc);
+        wc.sibling = c->win;
+      }
+  }
+  XSync(dpy, False);
+  while (XCheckMaskEvent(dpy, EnterWindowMask, &ev))
+    ;
+}
+
+void run(void) {
+  XEvent ev;
+  /* main event loop */
+  XSync(dpy, False);
+  while (running && !XNextEvent(dpy, &ev))
+    if (handler[ev.type])
+      handler[ev.type](&ev); /* call handler */
+}
+
+void runAutostart(void) {
+  system("cd ~/.dwm; ./autostart_blocking.sh");
+  system("cd ~/.dwm; ./autostart.sh &");
+}
+
+void scan(void) {
+  unsigned int i, num;
+  Window d1, d2, *wins = NULL;
+  XWindowAttributes wa;
+
+  if (XQueryTree(dpy, root, &d1, &d2, &wins, &num)) {
+    for (i = 0; i < num; i++) {
+      if (!XGetWindowAttributes(dpy, wins[i], &wa) || wa.override_redirect ||
+          XGetTransientForHint(dpy, wins[i], &d1))
+        continue;
+      if (wa.map_state == IsViewable || getstate(wins[i]) == IconicState)
+        manage(wins[i], &wa);
+    }
+    for (i = 0; i < num; i++) { /* now the transients */
+      if (!XGetWindowAttributes(dpy, wins[i], &wa))
+        continue;
+      if (XGetTransientForHint(dpy, wins[i], &d1) &&
+          (wa.map_state == IsViewable || getstate(wins[i]) == IconicState))
+        manage(wins[i], &wa);
+    }
+    if (wins)
+      XFree(wins);
+  }
+}
+
+void sendmon(Client *c, Monitor *m) {
+  if (c->mon == m)
+    return;
+  unfocus(c, 1);
+  detach(c);
+  detachstack(c);
+  c->mon = m;
+  c->tags = m->tagset[m->seltags]; /* assign tags of target monitor */
+  attachaside(c);
+  attachstack(c);
+  focus(NULL);
+  arrange(NULL);
+}
+
+void setclientstate(Client *c, long state) {
+  long data[] = {state, None};
+
+  XChangeProperty(dpy, c->win, wmatom[WMState], wmatom[WMState], 32,
+                  PropModeReplace, (unsigned char *)data, 2);
+}
+
+int sendevent(Window w, Atom proto, int mask, long d0, long d1, long d2,
+              long d3, long d4) {
+  int n;
+  Atom *protocols, mt;
+  int exists = 0;
+  XEvent ev;
+
+  if (proto == wmatom[WMTakeFocus] || proto == wmatom[WMDelete]) {
+    mt = wmatom[WMProtocols];
+    if (XGetWMProtocols(dpy, w, &protocols, &n)) {
+      while (!exists && n--)
+        exists = protocols[n] == proto;
+      XFree(protocols);
+    }
+  } else {
+    exists = True;
+    mt = proto;
+  }
 
-	if (exists) {
-		ev.type = ClientMessage;
-		ev.xclient.window = w;
-		ev.xclient.message_type = mt;
-		ev.xclient.format = 32;
-		ev.xclient.data.l[0] = d0;
-		ev.xclient.data.l[1] = d1;
-		ev.xclient.data.l[2] = d2;
-		ev.xclient.data.l[3] = d3;
-		ev.xclient.data.l[4] = d4;
-		XSendEvent(dpy, w, False, mask, &ev);
-	}
-	return exists;
-}
-
-void
-setfocus(Client *c)
-{
-	if (!c->neverfocus) {
-		XSetInputFocus(dpy, c->win, RevertToPointerRoot, CurrentTime);
-		XChangeProperty(dpy, root, netatom[NetActiveWindow],
-			XA_WINDOW, 32, PropModeReplace,
-			(unsigned char *) &(c->win), 1);
-	}
-	sendevent(c->win, wmatom[WMTakeFocus], NoEventMask, wmatom[WMTakeFocus], CurrentTime, 0, 0, 0);
-}
-
-void
-setfullscreen(Client *c, int fullscreen)
-{
-	if (fullscreen && !c->isfullscreen) {
-		XChangeProperty(dpy, c->win, netatom[NetWMState], XA_ATOM, 32,
-			PropModeReplace, (unsigned char*)&netatom[NetWMFullscreen], 1);
-		c->isfullscreen = 1;
-		c->oldstate = c->isfloating;
-		c->oldbw = c->bw;
-		c->bw = 0;
-		c->isfloating = 1;
-		resizeclient(c, c->mon->mx, c->mon->my, c->mon->mw, c->mon->mh);
-		XRaiseWindow(dpy, c->win);
-	} else if (!fullscreen && c->isfullscreen){
-		XChangeProperty(dpy, c->win, netatom[NetWMState], XA_ATOM, 32,
-			PropModeReplace, (unsigned char*)0, 0);
-		c->isfullscreen = 0;
-		c->isfloating = c->oldstate;
-		c->bw = c->oldbw;
-		c->x = c->oldx;
-		c->y = c->oldy;
-		c->w = c->oldw;
-		c->h = c->oldh;
-		resizeclient(c, c->x, c->y, c->w, c->h);
-		arrange(c->mon);
-	}
-}
-
-void
-setgaps(int oh, int ov, int ih, int iv)
-{
-	if (oh < 0) oh = 0;
-	if (ov < 0) ov = 0;
-	if (ih < 0) ih = 0;
-	if (iv < 0) iv = 0;
-
-	selmon->gappoh = oh;
-	selmon->gappov = ov;
-	selmon->gappih = ih;
-	selmon->gappiv = iv;
-	arrange(selmon);
-}
-
-void
-togglegaps(const Arg *arg)
-{
-	enablegaps = !enablegaps;
-	arrange(selmon);
-}
-
-void
-defaultgaps(const Arg *arg)
-{
-	setgaps(gappoh, gappov, gappih, gappiv);
-}
-
-void
-incrgaps(const Arg *arg)
-{
-	setgaps(
-		selmon->gappoh + arg->i,
-		selmon->gappov + arg->i,
-		selmon->gappih + arg->i,
-		selmon->gappiv + arg->i
-	);
-}
-
-void
-incrigaps(const Arg *arg)
-{
-	setgaps(
-		selmon->gappoh,
-		selmon->gappov,
-		selmon->gappih + arg->i,
-		selmon->gappiv + arg->i
-	);
-}
-
-void
-incrogaps(const Arg *arg)
-{
-	setgaps(
-		selmon->gappoh + arg->i,
-		selmon->gappov + arg->i,
-		selmon->gappih,
-		selmon->gappiv
-	);
-}
-
-void
-incrohgaps(const Arg *arg)
-{
-	setgaps(
-		selmon->gappoh + arg->i,
-		selmon->gappov,
-		selmon->gappih,
-		selmon->gappiv
-	);
-}
-
-void
-incrovgaps(const Arg *arg)
-{
-	setgaps(
-		selmon->gappoh,
-		selmon->gappov + arg->i,
-		selmon->gappih,
-		selmon->gappiv
-	);
-}
-
-void
-incrihgaps(const Arg *arg)
-{
-	setgaps(
-		selmon->gappoh,
-		selmon->gappov,
-		selmon->gappih + arg->i,
-		selmon->gappiv
-	);
-}
-
-void
-incrivgaps(const Arg *arg)
-{
-	setgaps(
-		selmon->gappoh,
-		selmon->gappov,
-		selmon->gappih,
-		selmon->gappiv + arg->i
-	);
-}
-
-void
-setlayout(const Arg *arg)
-{
-	if (!arg || !arg->v || arg->v != selmon->lt[selmon->sellt])
-		selmon->sellt ^= 1;
-	if (arg && arg->v)
-		selmon->lt[selmon->sellt] = (Layout *)arg->v;
-	strncpy(selmon->ltsymbol, selmon->lt[selmon->sellt]->symbol, sizeof selmon->ltsymbol);
-	if (selmon->sel)
-		arrange(selmon);
-	else
-		drawbar(selmon);
+  if (exists) {
+    ev.type = ClientMessage;
+    ev.xclient.window = w;
+    ev.xclient.message_type = mt;
+    ev.xclient.format = 32;
+    ev.xclient.data.l[0] = d0;
+    ev.xclient.data.l[1] = d1;
+    ev.xclient.data.l[2] = d2;
+    ev.xclient.data.l[3] = d3;
+    ev.xclient.data.l[4] = d4;
+    XSendEvent(dpy, w, False, mask, &ev);
+  }
+  return exists;
+}
+
+void setfocus(Client *c) {
+  if (!c->neverfocus) {
+    XSetInputFocus(dpy, c->win, RevertToPointerRoot, CurrentTime);
+    XChangeProperty(dpy, root, netatom[NetActiveWindow], XA_WINDOW, 32,
+                    PropModeReplace, (unsigned char *)&(c->win), 1);
+  }
+  sendevent(c->win, wmatom[WMTakeFocus], NoEventMask, wmatom[WMTakeFocus],
+            CurrentTime, 0, 0, 0);
+}
+
+void setfullscreen(Client *c, int fullscreen) {
+  if (fullscreen && !c->isfullscreen) {
+    XChangeProperty(dpy, c->win, netatom[NetWMState], XA_ATOM, 32,
+                    PropModeReplace, (unsigned char *)&netatom[NetWMFullscreen],
+                    1);
+    c->isfullscreen = 1;
+    c->oldstate = c->isfloating;
+    c->oldbw = c->bw;
+    c->bw = 0;
+    c->isfloating = 1;
+    resizeclient(c, c->mon->mx, c->mon->my, c->mon->mw, c->mon->mh);
+    XRaiseWindow(dpy, c->win);
+  } else if (!fullscreen && c->isfullscreen) {
+    XChangeProperty(dpy, c->win, netatom[NetWMState], XA_ATOM, 32,
+                    PropModeReplace, (unsigned char *)0, 0);
+    c->isfullscreen = 0;
+    c->isfloating = c->oldstate;
+    c->bw = c->oldbw;
+    c->x = c->oldx;
+    c->y = c->oldy;
+    c->w = c->oldw;
+    c->h = c->oldh;
+    resizeclient(c, c->x, c->y, c->w, c->h);
+    arrange(c->mon);
+  }
+}
+
+void setgaps(int oh, int ov, int ih, int iv) {
+  if (oh < 0)
+    oh = 0;
+  if (ov < 0)
+    ov = 0;
+  if (ih < 0)
+    ih = 0;
+  if (iv < 0)
+    iv = 0;
+
+  selmon->gappoh = oh;
+  selmon->gappov = ov;
+  selmon->gappih = ih;
+  selmon->gappiv = iv;
+  arrange(selmon);
+}
+
+void togglegaps(const Arg *arg) {
+  enablegaps = !enablegaps;
+  arrange(selmon);
+}
+
+void defaultgaps(const Arg *arg) { setgaps(gappoh, gappov, gappih, gappiv); }
+
+void incrgaps(const Arg *arg) {
+  setgaps(selmon->gappoh + arg->i, selmon->gappov + arg->i,
+          selmon->gappih + arg->i, selmon->gappiv + arg->i);
+}
+
+void incrigaps(const Arg *arg) {
+  setgaps(selmon->gappoh, selmon->gappov, selmon->gappih + arg->i,
+          selmon->gappiv + arg->i);
+}
+
+void incrogaps(const Arg *arg) {
+  setgaps(selmon->gappoh + arg->i, selmon->gappov + arg->i, selmon->gappih,
+          selmon->gappiv);
+}
+
+void incrohgaps(const Arg *arg) {
+  setgaps(selmon->gappoh + arg->i, selmon->gappov, selmon->gappih,
+          selmon->gappiv);
+}
+
+void incrovgaps(const Arg *arg) {
+  setgaps(selmon->gappoh, selmon->gappov + arg->i, selmon->gappih,
+          selmon->gappiv);
+}
+
+void incrihgaps(const Arg *arg) {
+  setgaps(selmon->gappoh, selmon->gappov, selmon->gappih + arg->i,
+          selmon->gappiv);
+}
+
+void incrivgaps(const Arg *arg) {
+  setgaps(selmon->gappoh, selmon->gappov, selmon->gappih,
+          selmon->gappiv + arg->i);
+}
+
+void setlayout(const Arg *arg) {
+  if (!arg || !arg->v || arg->v != selmon->lt[selmon->sellt])
+    selmon->sellt ^= 1;
+  if (arg && arg->v)
+    selmon->lt[selmon->sellt] = (Layout *)arg->v;
+  strncpy(selmon->ltsymbol, selmon->lt[selmon->sellt]->symbol,
+          sizeof selmon->ltsymbol);
+  if (selmon->sel)
+    arrange(selmon);
+  else
+    drawbar(selmon);
 }
 
 /* arg > 1.0 will set mfact absolutely */
-void
-setmfact(const Arg *arg)
-{
-	float f;
-
-	if (!arg || !selmon->lt[selmon->sellt]->arrange)
-		return;
-	f = arg->f < 1.0 ? arg->f + selmon->mfact : arg->f - 1.0;
-	if (f < 0.05 || f > 0.95)
-		return;
-	selmon->mfact = f;
-	arrange(selmon);
-}
-
-void
-setup(void)
-{
-	int i;
-	XSetWindowAttributes wa;
-	Atom utf8string;
-	struct sigaction sa;
-
-	/* do not transform children into zombies when they terminate */
-	sigemptyset(&sa.sa_mask);
-	sa.sa_flags = SA_NOCLDSTOP | SA_NOCLDWAIT | SA_RESTART;
-	sa.sa_handler = SIG_IGN;
-	sigaction(SIGCHLD, &sa, NULL);
-
-	/* clean up any zombies (inherited from .xinitrc etc) immediately */
-	while (waitpid(-1, NULL, WNOHANG) > 0);
-
-	/* init screen */
-	screen = DefaultScreen(dpy);
-	sw = DisplayWidth(dpy, screen);
-	sh = DisplayHeight(dpy, screen);
-	root = RootWindow(dpy, screen);
-	drw = drw_create(dpy, screen, root, sw, sh);
-	if (!drw_fontset_create(drw, fonts, LENGTH(fonts)))
-		die("no fonts could be loaded.");
-	lrpad = drw->fonts->h;
-	bh = drw->fonts->h + 2 + barpadding * 2;
-	updategeom();
-	/* init atoms */
-	utf8string = XInternAtom(dpy, "UTF8_STRING", False);
-	wmatom[WMProtocols] = XInternAtom(dpy, "WM_PROTOCOLS", False);
-	wmatom[WMDelete] = XInternAtom(dpy, "WM_DELETE_WINDOW", False);
-	wmatom[WMState] = XInternAtom(dpy, "WM_STATE", False);
-	wmatom[WMTakeFocus] = XInternAtom(dpy, "WM_TAKE_FOCUS", False);
-	netatom[NetActiveWindow] = XInternAtom(dpy, "_NET_ACTIVE_WINDOW", False);
-	netatom[NetSupported] = XInternAtom(dpy, "_NET_SUPPORTED", False);
-	netatom[NetSystemTray] = XInternAtom(dpy, "_NET_SYSTEM_TRAY_S0", False);
-	netatom[NetSystemTrayOP] = XInternAtom(dpy, "_NET_SYSTEM_TRAY_OPCODE", False);
-	netatom[NetSystemTrayOrientation] = XInternAtom(dpy, "_NET_SYSTEM_TRAY_ORIENTATION", False);
-	netatom[NetSystemTrayOrientationHorz] = XInternAtom(dpy, "_NET_SYSTEM_TRAY_ORIENTATION_HORZ", False);
-	netatom[NetWMName] = XInternAtom(dpy, "_NET_WM_NAME", False);
-	netatom[NetWMIcon] = XInternAtom(dpy, "_NET_WM_ICON", False);
-	netatom[NetWMState] = XInternAtom(dpy, "_NET_WM_STATE", False);
-	netatom[NetWMCheck] = XInternAtom(dpy, "_NET_SUPPORTING_WM_CHECK", False);
-	netatom[NetWMFullscreen] = XInternAtom(dpy, "_NET_WM_STATE_FULLSCREEN", False);
-	netatom[NetWMWindowType] = XInternAtom(dpy, "_NET_WM_WINDOW_TYPE", False);
-	netatom[NetWMWindowTypeDialog] = XInternAtom(dpy, "_NET_WM_WINDOW_TYPE_DIALOG", False);
-	netatom[NetClientList] = XInternAtom(dpy, "_NET_CLIENT_LIST", False);
-	xatom[Manager] = XInternAtom(dpy, "MANAGER", False);
-	xatom[Xembed] = XInternAtom(dpy, "_XEMBED", False);
-	xatom[XembedInfo] = XInternAtom(dpy, "_XEMBED_INFO", False);
-	/* init cursors */
-	cursor[CurNormal] = drw_cur_create(drw, XC_left_ptr);
-	cursor[CurResize] = drw_cur_create(drw, XC_sizing);
-	cursor[CurMove] = drw_cur_create(drw, XC_fleur);
-	/* init appearance */
-	scheme = ecalloc(LENGTH(colors) + 1, sizeof(Clr *));
-	scheme[LENGTH(colors)] = drw_scm_create(drw, colors[0], 3);
-	for (i = 0; i < LENGTH(colors); i++)
-		scheme[i] = drw_scm_create(drw, colors[i], 3);
-	drw_clr_create(drw, &clrborder, col_borderbar);
-	/* init system tray */
-	updatesystray();
-	/* init bars */
-	updatebars();
-	updatestatus();
-	/* supporting window for NetWMCheck */
-	wmcheckwin = XCreateSimpleWindow(dpy, root, 0, 0, 1, 1, 0, 0, 0);
-	XChangeProperty(dpy, wmcheckwin, netatom[NetWMCheck], XA_WINDOW, 32,
-		PropModeReplace, (unsigned char *) &wmcheckwin, 1);
-	XChangeProperty(dpy, wmcheckwin, netatom[NetWMName], utf8string, 8,
-		PropModeReplace, (unsigned char *) "dwm", 3);
-	XChangeProperty(dpy, root, netatom[NetWMCheck], XA_WINDOW, 32,
-		PropModeReplace, (unsigned char *) &wmcheckwin, 1);
-	/* EWMH support per view */
-	XChangeProperty(dpy, root, netatom[NetSupported], XA_ATOM, 32,
-		PropModeReplace, (unsigned char *) netatom, NetLast);
-	XDeleteProperty(dpy, root, netatom[NetClientList]);
-	/* select events */
-	wa.cursor = cursor[CurNormal]->cursor;
-	wa.event_mask = SubstructureRedirectMask|SubstructureNotifyMask
-		|ButtonPressMask|PointerMotionMask|EnterWindowMask
-		|LeaveWindowMask|StructureNotifyMask|PropertyChangeMask;
-	XChangeWindowAttributes(dpy, root, CWEventMask|CWCursor, &wa);
-	XSelectInput(dpy, root, wa.event_mask);
-	grabkeys();
-	focus(NULL);
-}
-
-void
-seturgent(Client *c, int urg)
-{
-	XWMHints *wmh;
-
-	c->isurgent = urg;
-	if (!(wmh = XGetWMHints(dpy, c->win)))
-		return;
-	wmh->flags = urg ? (wmh->flags | XUrgencyHint) : (wmh->flags & ~XUrgencyHint);
-	XSetWMHints(dpy, c->win, wmh);
-	XFree(wmh);
-}
-
-void
-showhide(Client *c)
-{
-	if (!c)
-		return;
-	if (ISVISIBLE(c)) {
-		/* show clients top down */
-		XMoveWindow(dpy, c->win, c->x, c->y);
-		if ((!c->mon->lt[c->mon->sellt]->arrange || c->isfloating) && !c->isfullscreen)
-			resize(c, c->x, c->y, c->w, c->h, 0);
-		showhide(c->snext);
-	} else {
-		/* hide clients bottom up */
-		showhide(c->snext);
-		XMoveWindow(dpy, c->win, WIDTH(c) * -2, c->y);
-	}
-}
-
-void
-spawn(const Arg *arg)
-{
-	struct sigaction sa;
-
-	if (arg->v == dmenucmd)
-		dmenumon[0] = '0' + selmon->num;
-	if (fork() == 0) {
-		if (dpy)
-			close(ConnectionNumber(dpy));
-		setsid();
-
-		sigemptyset(&sa.sa_mask);
-		sa.sa_flags = 0;
-		sa.sa_handler = SIG_DFL;
-		sigaction(SIGCHLD, &sa, NULL);
-
-		execvp(((char **)arg->v)[0], (char **)arg->v);
-		die("dwm: execvp '%s' failed:", ((char **)arg->v)[0]);
-	}
-}
-
-void
-tag(const Arg *arg)
-{
-	if (selmon->sel && arg->ui & TAGMASK) {
-		selmon->sel->tags = arg->ui & TAGMASK;
-		focus(NULL);
-		arrange(selmon);
-	}
-}
-
-void
-tagmon(const Arg *arg)
-{
-	if (!selmon->sel || !mons->next)
-		return;
-	sendmon(selmon->sel, dirtomon(arg->i));
-}
-
-void
-tile(Monitor *m)
-{
-	unsigned int i, n, h, r, oe = enablegaps, ie = enablegaps, mw, my, ty;
-	Client *c;
-
-	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++);
-	if (n == 0)
-		return;
-
-	if (smartgaps == n) {
-		oe = 0; // outer gaps disabled
-	}
-
-	if (n > m->nmaster)
-		mw = m->nmaster ? (m->ww + m->gappiv*ie) * m->mfact : 0;
-	else
-		mw = m->ww - 2*m->gappov*oe + m->gappiv*ie;
-	for (i = 0, my = ty = m->gappoh*oe, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
-		if (i < m->nmaster) {
-			r = MIN(n, m->nmaster) - i;
-			h = (m->wh - my - m->gappoh*oe - m->gappih*ie * (r - 1)) / r;
-			resize(c, m->wx + m->gappov*oe, m->wy + my, mw - (2*c->bw) - m->gappiv*ie, h - (2*c->bw), 0);
-			if (my + HEIGHT(c) + m->gappih*ie < m->wh)
-			  my += HEIGHT(c) + m->gappih*ie;
-		} else {
-			r = n - i;
-			h = (m->wh - ty - m->gappoh*oe - m->gappih*ie * (r - 1)) / r;
-			resize(c, m->wx + mw + m->gappov*oe, m->wy + ty, m->ww - mw - (2*c->bw) - 2*m->gappov*oe, h - (2*c->bw), 0);
-			if (ty + HEIGHT(c) + m->gappih*ie < m->wh)
-			  ty += HEIGHT(c) + m->gappih*ie;
-		}
-}
-
-void
-togglebar(const Arg *arg)
-{
-	selmon->showbar = !selmon->showbar;
-	updatebarpos(selmon);
-	resizebarwin(selmon);
-	if (showsystray) {
-		XWindowChanges wc;
-		if (!selmon->showbar)
-			wc.y = -bh;
-		else if (selmon->showbar) {
-			wc.y = 0;
-			if (!selmon->topbar)
-				wc.y = selmon->mh - bh;
-		}
-		XConfigureWindow(dpy, systray->win, CWY, &wc);
-	}
-	arrange(selmon);
-}
-
-void
-togglefloating(const Arg *arg)
-{
-	if (!selmon->sel)
-		return;
-	if (selmon->sel->isfullscreen) /* no support for fullscreen windows */
-		return;
-	selmon->sel->isfloating = !selmon->sel->isfloating || selmon->sel->isfixed;
-	if (selmon->sel->isfloating)
-		resize(selmon->sel, selmon->sel->x, selmon->sel->y,
-			selmon->sel->w, selmon->sel->h, 0);
-	arrange(selmon);
-}
-
-void
-toggletag(const Arg *arg)
-{
-	unsigned int newtags;
-
-	if (!selmon->sel)
-		return;
-	newtags = selmon->sel->tags ^ (arg->ui & TAGMASK);
-	if (newtags) {
-		selmon->sel->tags = newtags;
-		focus(NULL);
-		arrange(selmon);
-	}
-}
-
-void
-toggleview(const Arg *arg)
-{
-	unsigned int newtagset = selmon->tagset[selmon->seltags] ^ (arg->ui & TAGMASK);
-
-	if (newtagset) {
-		selmon->tagset[selmon->seltags] = newtagset;
-		focus(NULL);
-		arrange(selmon);
-	}
-}
-
-void
-freeicon(Client *c)
-{
-	if (c->icon) {
-		XRenderFreePicture(dpy, c->icon);
-		c->icon = None;
-	}
-}
-
-void
-unfocus(Client *c, int setfocus)
-{
-	if (!c)
-		return;
-	grabbuttons(c, 0);
-	XSetWindowBorder(dpy, c->win, scheme[SchemeNorm][ColBorder].pixel);
-	if (setfocus) {
-		XSetInputFocus(dpy, root, RevertToPointerRoot, CurrentTime);
-		XDeleteProperty(dpy, root, netatom[NetActiveWindow]);
-	}
-}
-
-void
-unmanage(Client *c, int destroyed)
-{
-	Monitor *m = c->mon;
-	XWindowChanges wc;
-
-	detach(c);
-	detachstack(c);
-	freeicon(c);
-	if (!destroyed) {
-		wc.border_width = c->oldbw;
-		XGrabServer(dpy); /* avoid race conditions */
-		XSetErrorHandler(xerrordummy);
-		XSelectInput(dpy, c->win, NoEventMask);
-		XConfigureWindow(dpy, c->win, CWBorderWidth, &wc); /* restore border */
-		XUngrabButton(dpy, AnyButton, AnyModifier, c->win);
-		setclientstate(c, WithdrawnState);
-		XSync(dpy, False);
-		XSetErrorHandler(xerror);
-		XUngrabServer(dpy);
-	}
-	free(c);
-	focus(NULL);
-	updateclientlist();
-	arrange(m);
-}
-
-void
-unmapnotify(XEvent *e)
-{
-	Client *c;
-	XUnmapEvent *ev = &e->xunmap;
-
-	if ((c = wintoclient(ev->window))) {
-		if (ev->send_event)
-			setclientstate(c, WithdrawnState);
-		else
-			unmanage(c, 0);
-	}
-	else if ((c = wintosystrayicon(ev->window))) {
-		/* KLUDGE! sometimes icons occasionally unmap their windows, but do
-		 * _not_ destroy them. We map those windows back */
-		XMapRaised(dpy, c->win);
-		updatesystray();
-	}
-}
-
-void
-updatebars(void)
-{
-	unsigned int w;
-	Monitor *m;
-	XSetWindowAttributes wa = {
-		.override_redirect = True,
-		.background_pixmap = ParentRelative,
-		.event_mask = ButtonPressMask|ExposureMask
-	};
-	XClassHint ch = {"dwm", "dwm"};
-	for (m = mons; m; m = m->next) {
-		if (m->barwin)
-			continue;
-		w = m->ww;
-		if (showsystray && m == systraytomon(m))
-			w -= getsystraywidth();
-		m->barwin = XCreateWindow(dpy, root, m->wx, m->by, w, bh, 0, DefaultDepth(dpy, screen),
-				CopyFromParent, DefaultVisual(dpy, screen),
-				CWOverrideRedirect|CWBackPixmap|CWEventMask, &wa);
-		XDefineCursor(dpy, m->barwin, cursor[CurNormal]->cursor);
-		if (showsystray && m == systraytomon(m))
-			XMapRaised(dpy, systray->win);
-		XMapRaised(dpy, m->barwin);
-		XSetClassHint(dpy, m->barwin, &ch);
-	}
-}
-
-void
-updatebarpos(Monitor *m)
-{
-	m->wy = m->my;
-	m->wh = m->mh;
-	if (m->showbar) {
-		m->wh -= bh;
-		m->by = m->topbar ? m->wy : m->wy + m->wh;
-		m->wy = m->topbar ? m->wy + bh : m->wy;
-	} else
-		m->by = -bh;
-}
-
-void
-updateclientlist()
-{
-	Client *c;
-	Monitor *m;
-
-	XDeleteProperty(dpy, root, netatom[NetClientList]);
-	for (m = mons; m; m = m->next)
-		for (c = m->clients; c; c = c->next)
-			XChangeProperty(dpy, root, netatom[NetClientList],
-				XA_WINDOW, 32, PropModeAppend,
-				(unsigned char *) &(c->win), 1);
-}
-
-int
-updategeom(void)
-{
-	int dirty = 0;
+void setmfact(const Arg *arg) {
+  float f;
+
+  if (!arg || !selmon->lt[selmon->sellt]->arrange)
+    return;
+  f = arg->f < 1.0 ? arg->f + selmon->mfact : arg->f - 1.0;
+  if (f < 0.05 || f > 0.95)
+    return;
+  selmon->mfact = f;
+  arrange(selmon);
+}
+
+void setup(void) {
+  int i;
+  XSetWindowAttributes wa;
+  Atom utf8string;
+  struct sigaction sa;
+
+  /* do not transform children into zombies when they terminate */
+  sigemptyset(&sa.sa_mask);
+  sa.sa_flags = SA_NOCLDSTOP | SA_NOCLDWAIT | SA_RESTART;
+  sa.sa_handler = SIG_IGN;
+  sigaction(SIGCHLD, &sa, NULL);
+
+  /* clean up any zombies (inherited from .xinitrc etc) immediately */
+  while (waitpid(-1, NULL, WNOHANG) > 0)
+    ;
+
+  /* init screen */
+  screen = DefaultScreen(dpy);
+  sw = DisplayWidth(dpy, screen);
+  sh = DisplayHeight(dpy, screen);
+  root = RootWindow(dpy, screen);
+  drw = drw_create(dpy, screen, root, sw, sh);
+  if (!drw_fontset_create(drw, fonts, LENGTH(fonts)))
+    die("no fonts could be loaded.");
+  lrpad = drw->fonts->h;
+  bh = drw->fonts->h + 2 + barpadding * 2;
+  updategeom();
+  /* init atoms */
+  utf8string = XInternAtom(dpy, "UTF8_STRING", False);
+  wmatom[WMProtocols] = XInternAtom(dpy, "WM_PROTOCOLS", False);
+  wmatom[WMDelete] = XInternAtom(dpy, "WM_DELETE_WINDOW", False);
+  wmatom[WMState] = XInternAtom(dpy, "WM_STATE", False);
+  wmatom[WMTakeFocus] = XInternAtom(dpy, "WM_TAKE_FOCUS", False);
+  netatom[NetActiveWindow] = XInternAtom(dpy, "_NET_ACTIVE_WINDOW", False);
+  netatom[NetSupported] = XInternAtom(dpy, "_NET_SUPPORTED", False);
+  netatom[NetSystemTray] = XInternAtom(dpy, "_NET_SYSTEM_TRAY_S0", False);
+  netatom[NetSystemTrayOP] = XInternAtom(dpy, "_NET_SYSTEM_TRAY_OPCODE", False);
+  netatom[NetSystemTrayOrientation] =
+      XInternAtom(dpy, "_NET_SYSTEM_TRAY_ORIENTATION", False);
+  netatom[NetSystemTrayOrientationHorz] =
+      XInternAtom(dpy, "_NET_SYSTEM_TRAY_ORIENTATION_HORZ", False);
+  netatom[NetWMName] = XInternAtom(dpy, "_NET_WM_NAME", False);
+  netatom[NetWMIcon] = XInternAtom(dpy, "_NET_WM_ICON", False);
+  netatom[NetWMState] = XInternAtom(dpy, "_NET_WM_STATE", False);
+  netatom[NetWMCheck] = XInternAtom(dpy, "_NET_SUPPORTING_WM_CHECK", False);
+  netatom[NetWMFullscreen] =
+      XInternAtom(dpy, "_NET_WM_STATE_FULLSCREEN", False);
+  netatom[NetWMWindowType] = XInternAtom(dpy, "_NET_WM_WINDOW_TYPE", False);
+  netatom[NetWMWindowTypeDialog] =
+      XInternAtom(dpy, "_NET_WM_WINDOW_TYPE_DIALOG", False);
+  netatom[NetClientList] = XInternAtom(dpy, "_NET_CLIENT_LIST", False);
+  xatom[Manager] = XInternAtom(dpy, "MANAGER", False);
+  xatom[Xembed] = XInternAtom(dpy, "_XEMBED", False);
+  xatom[XembedInfo] = XInternAtom(dpy, "_XEMBED_INFO", False);
+  /* init cursors */
+  cursor[CurNormal] = drw_cur_create(drw, XC_left_ptr);
+  cursor[CurResize] = drw_cur_create(drw, XC_sizing);
+  cursor[CurMove] = drw_cur_create(drw, XC_fleur);
+  /* init appearance */
+  scheme = ecalloc(LENGTH(colors) + 1, sizeof(Clr *));
+  scheme[LENGTH(colors)] = drw_scm_create(drw, colors[0], 3);
+  for (i = 0; i < LENGTH(colors); i++)
+    scheme[i] = drw_scm_create(drw, colors[i], 3);
+  drw_clr_create(drw, &clrborder, col_borderbar);
+  /* init system tray */
+  updatesystray();
+  /* init bars */
+  updatebars();
+  updatestatus();
+  /* supporting window for NetWMCheck */
+  wmcheckwin = XCreateSimpleWindow(dpy, root, 0, 0, 1, 1, 0, 0, 0);
+  XChangeProperty(dpy, wmcheckwin, netatom[NetWMCheck], XA_WINDOW, 32,
+                  PropModeReplace, (unsigned char *)&wmcheckwin, 1);
+  XChangeProperty(dpy, wmcheckwin, netatom[NetWMName], utf8string, 8,
+                  PropModeReplace, (unsigned char *)"dwm", 3);
+  XChangeProperty(dpy, root, netatom[NetWMCheck], XA_WINDOW, 32,
+                  PropModeReplace, (unsigned char *)&wmcheckwin, 1);
+  /* EWMH support per view */
+  XChangeProperty(dpy, root, netatom[NetSupported], XA_ATOM, 32,
+                  PropModeReplace, (unsigned char *)netatom, NetLast);
+  XDeleteProperty(dpy, root, netatom[NetClientList]);
+  /* select events */
+  wa.cursor = cursor[CurNormal]->cursor;
+  wa.event_mask = SubstructureRedirectMask | SubstructureNotifyMask |
+                  ButtonPressMask | PointerMotionMask | EnterWindowMask |
+                  LeaveWindowMask | StructureNotifyMask | PropertyChangeMask;
+  XChangeWindowAttributes(dpy, root, CWEventMask | CWCursor, &wa);
+  XSelectInput(dpy, root, wa.event_mask);
+  grabkeys();
+  focus(NULL);
+}
+
+void seturgent(Client *c, int urg) {
+  XWMHints *wmh;
+
+  c->isurgent = urg;
+  if (!(wmh = XGetWMHints(dpy, c->win)))
+    return;
+  wmh->flags = urg ? (wmh->flags | XUrgencyHint) : (wmh->flags & ~XUrgencyHint);
+  XSetWMHints(dpy, c->win, wmh);
+  XFree(wmh);
+}
+
+void showhide(Client *c) {
+  if (!c)
+    return;
+  if (ISVISIBLE(c)) {
+    /* show clients top down */
+    XMoveWindow(dpy, c->win, c->x, c->y);
+    if ((!c->mon->lt[c->mon->sellt]->arrange || c->isfloating) &&
+        !c->isfullscreen)
+      resize(c, c->x, c->y, c->w, c->h, 0);
+    showhide(c->snext);
+  } else {
+    /* hide clients bottom up */
+    showhide(c->snext);
+    XMoveWindow(dpy, c->win, WIDTH(c) * -2, c->y);
+  }
+}
+
+void spawn(const Arg *arg) {
+  struct sigaction sa;
+
+  if (arg->v == dmenucmd)
+    dmenumon[0] = '0' + selmon->num;
+  if (fork() == 0) {
+    if (dpy)
+      close(ConnectionNumber(dpy));
+    setsid();
+
+    sigemptyset(&sa.sa_mask);
+    sa.sa_flags = 0;
+    sa.sa_handler = SIG_DFL;
+    sigaction(SIGCHLD, &sa, NULL);
+
+    execvp(((char **)arg->v)[0], (char **)arg->v);
+    die("dwm: execvp '%s' failed:", ((char **)arg->v)[0]);
+  }
+}
+
+void tag(const Arg *arg) {
+  if (selmon->sel && arg->ui & TAGMASK) {
+    selmon->sel->tags = arg->ui & TAGMASK;
+    focus(NULL);
+    arrange(selmon);
+  }
+}
+
+void tagmon(const Arg *arg) {
+  if (!selmon->sel || !mons->next)
+    return;
+  sendmon(selmon->sel, dirtomon(arg->i));
+}
+
+void tile(Monitor *m) {
+  unsigned int i, n, h, r, oe = enablegaps, ie = enablegaps, mw, my, ty;
+  Client *c;
+
+  for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++)
+    ;
+  if (n == 0)
+    return;
+
+  if (smartgaps == n) {
+    oe = 0; // outer gaps disabled
+  }
+
+  if (n > m->nmaster)
+    mw = m->nmaster ? (m->ww + m->gappiv * ie) * m->mfact : 0;
+  else
+    mw = m->ww - 2 * m->gappov * oe + m->gappiv * ie;
+  for (i = 0, my = ty = m->gappoh * oe, c = nexttiled(m->clients); c;
+       c = nexttiled(c->next), i++)
+    if (i < m->nmaster) {
+      r = MIN(n, m->nmaster) - i;
+      h = (m->wh - my - m->gappoh * oe - m->gappih * ie * (r - 1)) / r;
+      resize(c, m->wx + m->gappov * oe, m->wy + my,
+             mw - (2 * c->bw) - m->gappiv * ie, h - (2 * c->bw), 0);
+      if (my + HEIGHT(c) + m->gappih * ie < m->wh)
+        my += HEIGHT(c) + m->gappih * ie;
+    } else {
+      r = n - i;
+      h = (m->wh - ty - m->gappoh * oe - m->gappih * ie * (r - 1)) / r;
+      resize(c, m->wx + mw + m->gappov * oe, m->wy + ty,
+             m->ww - mw - (2 * c->bw) - 2 * m->gappov * oe, h - (2 * c->bw), 0);
+      if (ty + HEIGHT(c) + m->gappih * ie < m->wh)
+        ty += HEIGHT(c) + m->gappih * ie;
+    }
+}
+
+void togglebar(const Arg *arg) {
+  selmon->showbar = !selmon->showbar;
+  updatebarpos(selmon);
+  resizebarwin(selmon);
+  if (showsystray) {
+    XWindowChanges wc;
+    if (!selmon->showbar)
+      wc.y = -bh;
+    else if (selmon->showbar) {
+      wc.y = 0;
+      if (!selmon->topbar)
+        wc.y = selmon->mh - bh;
+    }
+    XConfigureWindow(dpy, systray->win, CWY, &wc);
+  }
+  arrange(selmon);
+}
+
+void togglefloating(const Arg *arg) {
+  if (!selmon->sel)
+    return;
+  if (selmon->sel->isfullscreen) /* no support for fullscreen windows */
+    return;
+  selmon->sel->isfloating = !selmon->sel->isfloating || selmon->sel->isfixed;
+  if (selmon->sel->isfloating)
+    resize(selmon->sel, selmon->sel->x, selmon->sel->y, selmon->sel->w,
+           selmon->sel->h, 0);
+  arrange(selmon);
+}
+
+void toggletag(const Arg *arg) {
+  unsigned int newtags;
+
+  if (!selmon->sel)
+    return;
+  newtags = selmon->sel->tags ^ (arg->ui & TAGMASK);
+  if (newtags) {
+    selmon->sel->tags = newtags;
+    focus(NULL);
+    arrange(selmon);
+  }
+}
+
+void toggleview(const Arg *arg) {
+  unsigned int newtagset =
+      selmon->tagset[selmon->seltags] ^ (arg->ui & TAGMASK);
+
+  if (newtagset) {
+    selmon->tagset[selmon->seltags] = newtagset;
+    focus(NULL);
+    arrange(selmon);
+  }
+}
+
+void freeicon(Client *c) {
+  if (c->icon) {
+    XRenderFreePicture(dpy, c->icon);
+    c->icon = None;
+  }
+}
+
+void unfocus(Client *c, int setfocus) {
+  if (!c)
+    return;
+  grabbuttons(c, 0);
+  XSetWindowBorder(dpy, c->win, scheme[SchemeNorm][ColBorder].pixel);
+  if (setfocus) {
+    XSetInputFocus(dpy, root, RevertToPointerRoot, CurrentTime);
+    XDeleteProperty(dpy, root, netatom[NetActiveWindow]);
+  }
+}
+
+void unmanage(Client *c, int destroyed) {
+  Monitor *m = c->mon;
+  XWindowChanges wc;
+
+  detach(c);
+  detachstack(c);
+  freeicon(c);
+  if (!destroyed) {
+    wc.border_width = c->oldbw;
+    XGrabServer(dpy); /* avoid race conditions */
+    XSetErrorHandler(xerrordummy);
+    XSelectInput(dpy, c->win, NoEventMask);
+    XConfigureWindow(dpy, c->win, CWBorderWidth, &wc); /* restore border */
+    XUngrabButton(dpy, AnyButton, AnyModifier, c->win);
+    setclientstate(c, WithdrawnState);
+    XSync(dpy, False);
+    XSetErrorHandler(xerror);
+    XUngrabServer(dpy);
+  }
+  free(c);
+  focus(NULL);
+  updateclientlist();
+  arrange(m);
+}
+
+void unmapnotify(XEvent *e) {
+  Client *c;
+  XUnmapEvent *ev = &e->xunmap;
+
+  if ((c = wintoclient(ev->window))) {
+    if (ev->send_event)
+      setclientstate(c, WithdrawnState);
+    else
+      unmanage(c, 0);
+  } else if ((c = wintosystrayicon(ev->window))) {
+    /* KLUDGE! sometimes icons occasionally unmap their windows, but do
+     * _not_ destroy them. We map those windows back */
+    XMapRaised(dpy, c->win);
+    updatesystray();
+  }
+}
+
+void updatebars(void) {
+  unsigned int w;
+  Monitor *m;
+  XSetWindowAttributes wa = {.override_redirect = True,
+                             .background_pixmap = ParentRelative,
+                             .event_mask = ButtonPressMask | ExposureMask};
+  XClassHint ch = {"dwm", "dwm"};
+  for (m = mons; m; m = m->next) {
+    if (m->barwin)
+      continue;
+    w = m->ww;
+    if (showsystray && m == systraytomon(m))
+      w -= getsystraywidth();
+    m->barwin = XCreateWindow(
+        dpy, root, m->wx, m->by, w, bh, 0, DefaultDepth(dpy, screen),
+        CopyFromParent, DefaultVisual(dpy, screen),
+        CWOverrideRedirect | CWBackPixmap | CWEventMask, &wa);
+    XDefineCursor(dpy, m->barwin, cursor[CurNormal]->cursor);
+    if (showsystray && m == systraytomon(m))
+      XMapRaised(dpy, systray->win);
+    XMapRaised(dpy, m->barwin);
+    XSetClassHint(dpy, m->barwin, &ch);
+  }
+}
+
+void updatebarpos(Monitor *m) {
+  m->wy = m->my;
+  m->wh = m->mh;
+  if (m->showbar) {
+    m->wh -= bh;
+    m->by = m->topbar ? m->wy : m->wy + m->wh;
+    m->wy = m->topbar ? m->wy + bh : m->wy;
+  } else
+    m->by = -bh;
+}
+
+void updateclientlist() {
+  Client *c;
+  Monitor *m;
+
+  XDeleteProperty(dpy, root, netatom[NetClientList]);
+  for (m = mons; m; m = m->next)
+    for (c = m->clients; c; c = c->next)
+      XChangeProperty(dpy, root, netatom[NetClientList], XA_WINDOW, 32,
+                      PropModeAppend, (unsigned char *)&(c->win), 1);
+}
+
+int updategeom(void) {
+  int dirty = 0;
 
 #ifdef XINERAMA
-	if (XineramaIsActive(dpy)) {
-		int i, j, n, nn;
-		Client *c;
-		Monitor *m;
-		XineramaScreenInfo *info = XineramaQueryScreens(dpy, &nn);
-		XineramaScreenInfo *unique = NULL;
-
-		for (n = 0, m = mons; m; m = m->next, n++);
-		/* only consider unique geometries as separate screens */
-		unique = ecalloc(nn, sizeof(XineramaScreenInfo));
-		for (i = 0, j = 0; i < nn; i++)
-			if (isuniquegeom(unique, j, &info[i]))
-				memcpy(&unique[j++], &info[i], sizeof(XineramaScreenInfo));
-		XFree(info);
-		nn = j;
-
-		/* new monitors if nn > n */
-		for (i = n; i < nn; i++) {
-			for (m = mons; m && m->next; m = m->next);
-			if (m)
-				m->next = createmon();
-			else
-				mons = createmon();
-		}
-		for (i = 0, m = mons; i < nn && m; m = m->next, i++)
-			if (i >= n
-			|| unique[i].x_org != m->mx || unique[i].y_org != m->my
-			|| unique[i].width != m->mw || unique[i].height != m->mh)
-			{
-				dirty = 1;
-				m->num = i;
-				m->mx = m->wx = unique[i].x_org;
-				m->my = m->wy = unique[i].y_org;
-				m->mw = m->ww = unique[i].width;
-				m->mh = m->wh = unique[i].height;
-				updatebarpos(m);
-			}
-		/* removed monitors if n > nn */
-		for (i = nn; i < n; i++) {
-			for (m = mons; m && m->next; m = m->next);
-			while ((c = m->clients)) {
-				dirty = 1;
-				m->clients = c->next;
-				detachstack(c);
-				c->mon = mons;
-				attachaside(c);
-				attachstack(c);
-			}
-			if (m == selmon)
-				selmon = mons;
-			cleanupmon(m);
-		}
-		free(unique);
-	} else
+  if (XineramaIsActive(dpy)) {
+    int i, j, n, nn;
+    Client *c;
+    Monitor *m;
+    XineramaScreenInfo *info = XineramaQueryScreens(dpy, &nn);
+    XineramaScreenInfo *unique = NULL;
+
+    for (n = 0, m = mons; m; m = m->next, n++)
+      ;
+    /* only consider unique geometries as separate screens */
+    unique = ecalloc(nn, sizeof(XineramaScreenInfo));
+    for (i = 0, j = 0; i < nn; i++)
+      if (isuniquegeom(unique, j, &info[i]))
+        memcpy(&unique[j++], &info[i], sizeof(XineramaScreenInfo));
+    XFree(info);
+    nn = j;
+
+    /* new monitors if nn > n */
+    for (i = n; i < nn; i++) {
+      for (m = mons; m && m->next; m = m->next)
+        ;
+      if (m)
+        m->next = createmon();
+      else
+        mons = createmon();
+    }
+    for (i = 0, m = mons; i < nn && m; m = m->next, i++)
+      if (i >= n || unique[i].x_org != m->mx || unique[i].y_org != m->my ||
+          unique[i].width != m->mw || unique[i].height != m->mh) {
+        dirty = 1;
+        m->num = i;
+        m->mx = m->wx = unique[i].x_org;
+        m->my = m->wy = unique[i].y_org;
+        m->mw = m->ww = unique[i].width;
+        m->mh = m->wh = unique[i].height;
+        updatebarpos(m);
+      }
+    /* removed monitors if n > nn */
+    for (i = nn; i < n; i++) {
+      for (m = mons; m && m->next; m = m->next)
+        ;
+      while ((c = m->clients)) {
+        dirty = 1;
+        m->clients = c->next;
+        detachstack(c);
+        c->mon = mons;
+        attachaside(c);
+        attachstack(c);
+      }
+      if (m == selmon)
+        selmon = mons;
+      cleanupmon(m);
+    }
+    free(unique);
+  } else
 #endif /* XINERAMA */
-	{ /* default monitor setup */
-		if (!mons)
-			mons = createmon();
-		if (mons->mw != sw || mons->mh != sh) {
-			dirty = 1;
-			mons->mw = mons->ww = sw;
-			mons->mh = mons->wh = sh;
-			updatebarpos(mons);
-		}
-	}
-	if (dirty) {
-		selmon = mons;
-		selmon = wintomon(root);
-	}
-	return dirty;
-}
-
-void
-updatenumlockmask(void)
-{
-	unsigned int i, j;
-	XModifierKeymap *modmap;
-
-	numlockmask = 0;
-	modmap = XGetModifierMapping(dpy);
-	for (i = 0; i < 8; i++)
-		for (j = 0; j < modmap->max_keypermod; j++)
-			if (modmap->modifiermap[i * modmap->max_keypermod + j]
-				== XKeysymToKeycode(dpy, XK_Num_Lock))
-				numlockmask = (1 << i);
-	XFreeModifiermap(modmap);
-}
-
-void
-updatesizehints(Client *c)
-{
-	long msize;
-	XSizeHints size;
-
-	if (!XGetWMNormalHints(dpy, c->win, &size, &msize))
-		/* size is uninitialized, ensure that size.flags aren't used */
-		size.flags = PSize;
-	if (size.flags & PBaseSize) {
-		c->basew = size.base_width;
-		c->baseh = size.base_height;
-	} else if (size.flags & PMinSize) {
-		c->basew = size.min_width;
-		c->baseh = size.min_height;
-	} else
-		c->basew = c->baseh = 0;
-	if (size.flags & PResizeInc) {
-		c->incw = size.width_inc;
-		c->inch = size.height_inc;
-	} else
-		c->incw = c->inch = 0;
-	if (size.flags & PMaxSize) {
-		c->maxw = size.max_width;
-		c->maxh = size.max_height;
-	} else
-		c->maxw = c->maxh = 0;
-	if (size.flags & PMinSize) {
-		c->minw = size.min_width;
-		c->minh = size.min_height;
-	} else if (size.flags & PBaseSize) {
-		c->minw = size.base_width;
-		c->minh = size.base_height;
-	} else
-		c->minw = c->minh = 0;
-	if (size.flags & PAspect) {
-		c->mina = (float)size.min_aspect.y / size.min_aspect.x;
-		c->maxa = (float)size.max_aspect.x / size.max_aspect.y;
-	} else
-		c->maxa = c->mina = 0.0;
-	c->isfixed = (c->maxw && c->maxh && c->maxw == c->minw && c->maxh == c->minh);
-	c->hintsvalid = 1;
-}
-
-void
-updatestatus(void)
-{
-	if (!gettextprop(root, XA_WM_NAME, stext, sizeof(stext)))
-		strcpy(stext, "dwm-"VERSION);
-	drawbar(selmon);
-	updatesystray();
-}
-
-
-void
-updatesystrayicongeom(Client *i, int w, int h)
-{
+  {    /* default monitor setup */
+    if (!mons)
+      mons = createmon();
+    if (mons->mw != sw || mons->mh != sh) {
+      dirty = 1;
+      mons->mw = mons->ww = sw;
+      mons->mh = mons->wh = sh;
+      updatebarpos(mons);
+    }
+  }
+  if (dirty) {
+    selmon = mons;
+    selmon = wintomon(root);
+  }
+  return dirty;
+}
+
+void updatenumlockmask(void) {
+  unsigned int i, j;
+  XModifierKeymap *modmap;
+
+  numlockmask = 0;
+  modmap = XGetModifierMapping(dpy);
+  for (i = 0; i < 8; i++)
+    for (j = 0; j < modmap->max_keypermod; j++)
+      if (modmap->modifiermap[i * modmap->max_keypermod + j] ==
+          XKeysymToKeycode(dpy, XK_Num_Lock))
+        numlockmask = (1 << i);
+  XFreeModifiermap(modmap);
+}
+
+void updatesizehints(Client *c) {
+  long msize;
+  XSizeHints size;
+
+  if (!XGetWMNormalHints(dpy, c->win, &size, &msize))
+    /* size is uninitialized, ensure that size.flags aren't used */
+    size.flags = PSize;
+  if (size.flags & PBaseSize) {
+    c->basew = size.base_width;
+    c->baseh = size.base_height;
+  } else if (size.flags & PMinSize) {
+    c->basew = size.min_width;
+    c->baseh = size.min_height;
+  } else
+    c->basew = c->baseh = 0;
+  if (size.flags & PResizeInc) {
+    c->incw = size.width_inc;
+    c->inch = size.height_inc;
+  } else
+    c->incw = c->inch = 0;
+  if (size.flags & PMaxSize) {
+    c->maxw = size.max_width;
+    c->maxh = size.max_height;
+  } else
+    c->maxw = c->maxh = 0;
+  if (size.flags & PMinSize) {
+    c->minw = size.min_width;
+    c->minh = size.min_height;
+  } else if (size.flags & PBaseSize) {
+    c->minw = size.base_width;
+    c->minh = size.base_height;
+  } else
+    c->minw = c->minh = 0;
+  if (size.flags & PAspect) {
+    c->mina = (float)size.min_aspect.y / size.min_aspect.x;
+    c->maxa = (float)size.max_aspect.x / size.max_aspect.y;
+  } else
+    c->maxa = c->mina = 0.0;
+  c->isfixed = (c->maxw && c->maxh && c->maxw == c->minw && c->maxh == c->minh);
+  c->hintsvalid = 1;
+}
+
+void updatestatus(void) {
+  if (!gettextprop(root, XA_WM_NAME, stext, sizeof(stext)))
+    strcpy(stext, "dwm-" VERSION);
+  drawbar(selmon);
+  updatesystray();
+}
+
+void updatesystrayicongeom(Client *i, int w, int h) {
   if (!i)
     return;
   applysizehints(i, &(i->x), &(i->y), &(i->w), &(i->h), False);
   if (systrayiconsize >= bh) {
     i->w = bh;
-		i->h = bh;
+    i->h = bh;
   } else {
     i->w = systrayiconsize;
     i->h = systrayiconsize;
   }
 }
 
-void
-updatesystrayiconstate(Client *i, XPropertyEvent *ev)
-{
-	long flags;
-	int code = 0;
-
-	if (!showsystray || !i || ev->atom != xatom[XembedInfo] ||
-			!(flags = getatomprop(i, xatom[XembedInfo])))
-		return;
-
-	if (flags & XEMBED_MAPPED && !i->tags) {
-		i->tags = 1;
-		code = XEMBED_WINDOW_ACTIVATE;
-		XMapRaised(dpy, i->win);
-		setclientstate(i, NormalState);
-	}
-	else if (!(flags & XEMBED_MAPPED) && i->tags) {
-		i->tags = 0;
-		code = XEMBED_WINDOW_DEACTIVATE;
-		XUnmapWindow(dpy, i->win);
-		setclientstate(i, WithdrawnState);
-	}
-	else
-		return;
-	sendevent(i->win, xatom[Xembed], StructureNotifyMask, CurrentTime, code, 0,
-			systray->win, XEMBED_EMBEDDED_VERSION);
-}
-
-void
-updatesystray(void)
-{
-	XSetWindowAttributes wa;
-	XWindowChanges wc;
-	Client *i;
-	Monitor *m = systraytomon(NULL);
-	unsigned int x = m->mx + m->mw;
-	unsigned int sw = TEXTW(stext) - lrpad + systrayspacing;
-	unsigned int w = 1;
-
-	if (!showsystray)
-		return;
-	if (systrayonleft)
-		x -= sw + lrpad / 2;
-	if (!systray) {
-		/* init systray */
-		if (!(systray = (Systray *)calloc(1, sizeof(Systray))))
-			die("fatal: could not malloc() %u bytes\n", sizeof(Systray));
-		systray->win = XCreateSimpleWindow(dpy, root, x, m->by, w, bh, 0, 0, scheme[SchemeSel][ColBg].pixel);
-		wa.event_mask        = ButtonPressMask | ExposureMask;
-		wa.override_redirect = True;
-		wa.background_pixel  = scheme[SchemeNorm][ColBg].pixel;
-		XSelectInput(dpy, systray->win, SubstructureNotifyMask);
-		XChangeProperty(dpy, systray->win, netatom[NetSystemTrayOrientation], XA_CARDINAL, 32,
-				PropModeReplace, (unsigned char *)&netatom[NetSystemTrayOrientationHorz], 1);
-		XChangeWindowAttributes(dpy, systray->win, CWEventMask|CWOverrideRedirect|CWBackPixel, &wa);
-		XMapRaised(dpy, systray->win);
-		XSetSelectionOwner(dpy, netatom[NetSystemTray], systray->win, CurrentTime);
-		if (XGetSelectionOwner(dpy, netatom[NetSystemTray]) == systray->win) {
-			sendevent(root, xatom[Manager], StructureNotifyMask, CurrentTime, netatom[NetSystemTray], systray->win, 0, 0);
-			XSync(dpy, False);
-		}
-		else {
-			fprintf(stderr, "dwm: unable to obtain system tray.\n");
-			free(systray);
-			systray = NULL;
-			return;
-		}
-	}
-	for (w = 0, i = systray->icons; i; i = i->next) {
-		/* make sure the background color stays the same */
-		wa.background_pixel  = scheme[SchemeNorm][ColBg].pixel;
-		XChangeWindowAttributes(dpy, i->win, CWBackPixel, &wa);
-		XMapRaised(dpy, i->win);
-		w += systrayspacing;
-		i->x = w;
+void updatesystrayiconstate(Client *i, XPropertyEvent *ev) {
+  long flags;
+  int code = 0;
+
+  if (!showsystray || !i || ev->atom != xatom[XembedInfo] ||
+      !(flags = getatomprop(i, xatom[XembedInfo])))
+    return;
+
+  if (flags & XEMBED_MAPPED && !i->tags) {
+    i->tags = 1;
+    code = XEMBED_WINDOW_ACTIVATE;
+    XMapRaised(dpy, i->win);
+    setclientstate(i, NormalState);
+  } else if (!(flags & XEMBED_MAPPED) && i->tags) {
+    i->tags = 0;
+    code = XEMBED_WINDOW_DEACTIVATE;
+    XUnmapWindow(dpy, i->win);
+    setclientstate(i, WithdrawnState);
+  } else
+    return;
+  sendevent(i->win, xatom[Xembed], StructureNotifyMask, CurrentTime, code, 0,
+            systray->win, XEMBED_EMBEDDED_VERSION);
+}
+
+void updatesystray(void) {
+  XSetWindowAttributes wa;
+  XWindowChanges wc;
+  Client *i;
+  Monitor *m = systraytomon(NULL);
+  unsigned int x = m->mx + m->mw;
+  unsigned int sw = TEXTW(stext) - lrpad + systrayspacing;
+  unsigned int w = 1;
+
+  if (!showsystray)
+    return;
+  if (systrayonleft)
+    x -= sw + lrpad / 2;
+  if (!systray) {
+    /* init systray */
+    if (!(systray = (Systray *)calloc(1, sizeof(Systray))))
+      die("fatal: could not malloc() %u bytes\n", sizeof(Systray));
+    systray->win = XCreateSimpleWindow(dpy, root, x, m->by, w, bh, 0, 0,
+                                       scheme[SchemeSel][ColBg].pixel);
+    wa.event_mask = ButtonPressMask | ExposureMask;
+    wa.override_redirect = True;
+    wa.background_pixel = scheme[SchemeNorm][ColBg].pixel;
+    XSelectInput(dpy, systray->win, SubstructureNotifyMask);
+    XChangeProperty(dpy, systray->win, netatom[NetSystemTrayOrientation],
+                    XA_CARDINAL, 32, PropModeReplace,
+                    (unsigned char *)&netatom[NetSystemTrayOrientationHorz], 1);
+    XChangeWindowAttributes(
+        dpy, systray->win, CWEventMask | CWOverrideRedirect | CWBackPixel, &wa);
+    XMapRaised(dpy, systray->win);
+    XSetSelectionOwner(dpy, netatom[NetSystemTray], systray->win, CurrentTime);
+    if (XGetSelectionOwner(dpy, netatom[NetSystemTray]) == systray->win) {
+      sendevent(root, xatom[Manager], StructureNotifyMask, CurrentTime,
+                netatom[NetSystemTray], systray->win, 0, 0);
+      XSync(dpy, False);
+    } else {
+      fprintf(stderr, "dwm: unable to obtain system tray.\n");
+      free(systray);
+      systray = NULL;
+      return;
+    }
+  }
+  for (w = 0, i = systray->icons; i; i = i->next) {
+    /* make sure the background color stays the same */
+    wa.background_pixel = scheme[SchemeNorm][ColBg].pixel;
+    XChangeWindowAttributes(dpy, i->win, CWBackPixel, &wa);
+    XMapRaised(dpy, i->win);
+    w += systrayspacing;
+    i->x = w;
     if (systrayiconsize >= bh)
-    i->y = 0;
+      i->y = 0;
     else
-    i->y = (bh - systrayiconsize) / 2;
+      i->y = (bh - systrayiconsize) / 2;
     XMoveResizeWindow(dpy, i->win, i->x, i->y, i->w, i->h);
-		w += i->w;
-		if (i->mon != m)
-			i->mon = m;
-	}
-	w = w ? w + systrayspacing : 1;
-	x -= w;
-	XMoveResizeWindow(dpy, systray->win, x, m->by, w, bh);
-	wc.x = x; wc.y = m->by; wc.width = w; wc.height = bh;
-	wc.stack_mode = Above; wc.sibling = m->barwin;
-	XConfigureWindow(dpy, systray->win, CWX|CWY|CWWidth|CWHeight|CWSibling|CWStackMode, &wc);
-	XMapWindow(dpy, systray->win);
-	XMapSubwindows(dpy, systray->win);
-	/* redraw background */
-	XSetForeground(dpy, drw->gc, scheme[SchemeNorm][ColBg].pixel);
-	XFillRectangle(dpy, systray->win, drw->gc, 0, 0, w, bh);
-	XSync(dpy, False);
-}
-
-void
-updatetitle(Client *c)
-{
-	if (!gettextprop(c->win, netatom[NetWMName], c->name, sizeof c->name))
-		gettextprop(c->win, XA_WM_NAME, c->name, sizeof c->name);
-	if (c->name[0] == '\0') /* hack to mark broken clients */
-		strcpy(c->name, broken);
-}
-
-void
-updateicon(Client *c)
-{
-	freeicon(c);
-	c->icon = geticonprop(c->win, &c->icw, &c->ich);
-}
-
-void
-updatewindowtype(Client *c)
-{
-	Atom state = getatomprop(c, netatom[NetWMState]);
-	Atom wtype = getatomprop(c, netatom[NetWMWindowType]);
-
-	if (state == netatom[NetWMFullscreen])
-		setfullscreen(c, 1);
-	if (wtype == netatom[NetWMWindowTypeDialog])
-		c->isfloating = 1;
-}
-
-void
-updatewmhints(Client *c)
-{
-	XWMHints *wmh;
-
-	if ((wmh = XGetWMHints(dpy, c->win))) {
-		if (c == selmon->sel && wmh->flags & XUrgencyHint) {
-			wmh->flags &= ~XUrgencyHint;
-			XSetWMHints(dpy, c->win, wmh);
-		} else
-			c->isurgent = (wmh->flags & XUrgencyHint) ? 1 : 0;
-		if (wmh->flags & InputHint)
-			c->neverfocus = !wmh->input;
-		else
-			c->neverfocus = 0;
-		XFree(wmh);
-	}
-}
-
-void
-view(const Arg *arg)
-{
-	if ((arg->ui & TAGMASK) == selmon->tagset[selmon->seltags])
-		return;
-	selmon->seltags ^= 1; /* toggle sel tagset */
-	if (arg->ui & TAGMASK)
-		selmon->tagset[selmon->seltags] = arg->ui & TAGMASK;
-	focus(NULL);
-	arrange(selmon);
-}
-
-Client *
-wintoclient(Window w)
-{
-	Client *c;
-	Monitor *m;
-
-	for (m = mons; m; m = m->next)
-		for (c = m->clients; c; c = c->next)
-			if (c->win == w)
-				return c;
-	return NULL;
-}
-
-Client *
-wintosystrayicon(Window w) {
-	Client *i = NULL;
-
-	if (!showsystray || !w)
-		return i;
-	for (i = systray->icons; i && i->win != w; i = i->next) ;
-	return i;
-}
-
-Monitor *
-wintomon(Window w)
-{
-	int x, y;
-	Client *c;
-	Monitor *m;
-
-	if (w == root && getrootptr(&x, &y))
-		return recttomon(x, y, 1, 1);
-	for (m = mons; m; m = m->next)
-		if (w == m->barwin)
-			return m;
-	if ((c = wintoclient(w)))
-		return c->mon;
-	return selmon;
+    w += i->w;
+    if (i->mon != m)
+      i->mon = m;
+  }
+  w = w ? w + systrayspacing : 1;
+  x -= w;
+  XMoveResizeWindow(dpy, systray->win, x, m->by, w, bh);
+  wc.x = x;
+  wc.y = m->by;
+  wc.width = w;
+  wc.height = bh;
+  wc.stack_mode = Above;
+  wc.sibling = m->barwin;
+  XConfigureWindow(dpy, systray->win,
+                   CWX | CWY | CWWidth | CWHeight | CWSibling | CWStackMode,
+                   &wc);
+  XMapWindow(dpy, systray->win);
+  XMapSubwindows(dpy, systray->win);
+  /* redraw background */
+  XSetForeground(dpy, drw->gc, scheme[SchemeNorm][ColBg].pixel);
+  XFillRectangle(dpy, systray->win, drw->gc, 0, 0, w, bh);
+  XSync(dpy, False);
+}
+
+void updatetitle(Client *c) {
+  if (!gettextprop(c->win, netatom[NetWMName], c->name, sizeof c->name))
+    gettextprop(c->win, XA_WM_NAME, c->name, sizeof c->name);
+  if (c->name[0] == '\0') /* hack to mark broken clients */
+    strcpy(c->name, broken);
+}
+
+void updateicon(Client *c) {
+  freeicon(c);
+  c->icon = geticonprop(c->win, &c->icw, &c->ich);
+}
+
+void updatewindowtype(Client *c) {
+  Atom state = getatomprop(c, netatom[NetWMState]);
+  Atom wtype = getatomprop(c, netatom[NetWMWindowType]);
+
+  if (state == netatom[NetWMFullscreen])
+    setfullscreen(c, 1);
+  if (wtype == netatom[NetWMWindowTypeDialog])
+    c->isfloating = 1;
+}
+
+void updatewmhints(Client *c) {
+  XWMHints *wmh;
+
+  if ((wmh = XGetWMHints(dpy, c->win))) {
+    if (c == selmon->sel && wmh->flags & XUrgencyHint) {
+      wmh->flags &= ~XUrgencyHint;
+      XSetWMHints(dpy, c->win, wmh);
+    } else
+      c->isurgent = (wmh->flags & XUrgencyHint) ? 1 : 0;
+    if (wmh->flags & InputHint)
+      c->neverfocus = !wmh->input;
+    else
+      c->neverfocus = 0;
+    XFree(wmh);
+  }
+}
+
+void view(const Arg *arg) {
+  if ((arg->ui & TAGMASK) == selmon->tagset[selmon->seltags])
+    return;
+  selmon->seltags ^= 1; /* toggle sel tagset */
+  if (arg->ui & TAGMASK)
+    selmon->tagset[selmon->seltags] = arg->ui & TAGMASK;
+  focus(NULL);
+  arrange(selmon);
+}
+
+Client *wintoclient(Window w) {
+  Client *c;
+  Monitor *m;
+
+  for (m = mons; m; m = m->next)
+    for (c = m->clients; c; c = c->next)
+      if (c->win == w)
+        return c;
+  return NULL;
+}
+
+Client *wintosystrayicon(Window w) {
+  Client *i = NULL;
+
+  if (!showsystray || !w)
+    return i;
+  for (i = systray->icons; i && i->win != w; i = i->next)
+    ;
+  return i;
+}
+
+Monitor *wintomon(Window w) {
+  int x, y;
+  Client *c;
+  Monitor *m;
+
+  if (w == root && getrootptr(&x, &y))
+    return recttomon(x, y, 1, 1);
+  for (m = mons; m; m = m->next)
+    if (w == m->barwin)
+      return m;
+  if ((c = wintoclient(w)))
+    return c->mon;
+  return selmon;
 }
 
 /* There's no way to check accesses to destroyed windows, thus those cases are
  * ignored (especially on UnmapNotify's). Other types of errors call Xlibs
  * default error handler, which may call exit. */
-int
-xerror(Display *dpy, XErrorEvent *ee)
-{
-	if (ee->error_code == BadWindow
-	|| (ee->request_code == X_SetInputFocus && ee->error_code == BadMatch)
-	|| (ee->request_code == X_PolyText8 && ee->error_code == BadDrawable)
-	|| (ee->request_code == X_PolyFillRectangle && ee->error_code == BadDrawable)
-	|| (ee->request_code == X_PolySegment && ee->error_code == BadDrawable)
-	|| (ee->request_code == X_ConfigureWindow && ee->error_code == BadMatch)
-	|| (ee->request_code == X_GrabButton && ee->error_code == BadAccess)
-	|| (ee->request_code == X_GrabKey && ee->error_code == BadAccess)
-	|| (ee->request_code == X_CopyArea && ee->error_code == BadDrawable))
-		return 0;
-	fprintf(stderr, "dwm: fatal error: request code=%d, error code=%d\n",
-		ee->request_code, ee->error_code);
-	return xerrorxlib(dpy, ee); /* may call exit */
-}
-
-int
-xerrordummy(Display *dpy, XErrorEvent *ee)
-{
-	return 0;
-}
+int xerror(Display *dpy, XErrorEvent *ee) {
+  if (ee->error_code == BadWindow ||
+      (ee->request_code == X_SetInputFocus && ee->error_code == BadMatch) ||
+      (ee->request_code == X_PolyText8 && ee->error_code == BadDrawable) ||
+      (ee->request_code == X_PolyFillRectangle &&
+       ee->error_code == BadDrawable) ||
+      (ee->request_code == X_PolySegment && ee->error_code == BadDrawable) ||
+      (ee->request_code == X_ConfigureWindow && ee->error_code == BadMatch) ||
+      (ee->request_code == X_GrabButton && ee->error_code == BadAccess) ||
+      (ee->request_code == X_GrabKey && ee->error_code == BadAccess) ||
+      (ee->request_code == X_CopyArea && ee->error_code == BadDrawable))
+    return 0;
+  fprintf(stderr, "dwm: fatal error: request code=%d, error code=%d\n",
+          ee->request_code, ee->error_code);
+  return xerrorxlib(dpy, ee); /* may call exit */
+}
+
+int xerrordummy(Display *dpy, XErrorEvent *ee) { return 0; }
 
 /* Startup Error handler to check if another window manager
  * is already running. */
-int
-xerrorstart(Display *dpy, XErrorEvent *ee)
-{
-	die("dwm: another window manager is already running");
-	return -1;
-}
-
-Monitor *
-systraytomon(Monitor *m) {
-	Monitor *t;
-	int i, n;
-	if(!systraypinning) {
-		if(!m)
-			return selmon;
-		return m == selmon ? m : NULL;
-	}
-	for(n = 1, t = mons; t && t->next; n++, t = t->next) ;
-	for(i = 1, t = mons; t && t->next && i < systraypinning; i++, t = t->next) ;
-	if(systraypinningfailfirst && n < systraypinning)
-		return mons;
-	return t;
-}
-
-void
-zoom(const Arg *arg)
-{
-	Client *c = selmon->sel;
-
-	if (!selmon->lt[selmon->sellt]->arrange || !c || c->isfloating)
-		return;
-	if (c == nexttiled(selmon->clients) && !(c = nexttiled(c->next)))
-		return;
-	pop(c);
-}
-
-int
-main(int argc, char *argv[])
-{
-	if (argc == 2 && !strcmp("-v", argv[1]))
-		die("dwm-"VERSION);
-	else if (argc != 1)
-		die("usage: dwm [-v]");
-	if (!setlocale(LC_CTYPE, "") || !XSupportsLocale())
-		fputs("warning: no locale support\n", stderr);
-	if (!(dpy = XOpenDisplay(NULL)))
-		die("dwm: cannot open display");
-	checkotherwm();
-	setup();
+int xerrorstart(Display *dpy, XErrorEvent *ee) {
+  die("dwm: another window manager is already running");
+  return -1;
+}
+
+Monitor *systraytomon(Monitor *m) {
+  Monitor *t;
+  int i, n;
+  if (!systraypinning) {
+    if (!m)
+      return selmon;
+    return m == selmon ? m : NULL;
+  }
+  for (n = 1, t = mons; t && t->next; n++, t = t->next)
+    ;
+  for (i = 1, t = mons; t && t->next && i < systraypinning; i++, t = t->next)
+    ;
+  if (systraypinningfailfirst && n < systraypinning)
+    return mons;
+  return t;
+}
+
+void zoom(const Arg *arg) {
+  Client *c = selmon->sel;
+
+  if (!selmon->lt[selmon->sellt]->arrange || !c || c->isfloating)
+    return;
+  if (c == nexttiled(selmon->clients) && !(c = nexttiled(c->next)))
+    return;
+  pop(c);
+}
+
+int main(int argc, char *argv[]) {
+  if (argc == 2 && !strcmp("-v", argv[1]))
+    die("dwm-" VERSION);
+  else if (argc != 1)
+    die("usage: dwm [-v]");
+  if (!setlocale(LC_CTYPE, "") || !XSupportsLocale())
+    fputs("warning: no locale support\n", stderr);
+  if (!(dpy = XOpenDisplay(NULL)))
+    die("dwm: cannot open display");
+  checkotherwm();
+  setup();
 #ifdef __OpenBSD__
-	if (pledge("stdio rpath proc exec", NULL) == -1)
-		die("pledge");
+  if (pledge("stdio rpath proc exec", NULL) == -1)
+    die("pledge");
 #endif /* __OpenBSD__ */
-	scan();
-	runAutostart();
-	run();
-	cleanup();
-	XCloseDisplay(dpy);
-	return EXIT_SUCCESS;
+  scan();
+  runAutostart();
+  run();
+  cleanup();
+  XCloseDisplay(dpy);
+  return EXIT_SUCCESS;
 }
diff --git a/dwm.c.orig b/dwm.c.orig
deleted file mode 100644
index b1435c6..0000000
--- a/dwm.c.orig
+++ /dev/null
@@ -1,2774 +0,0 @@
-/* See LICENSE file for copyright and license details.
- *
- * dynamic window manager is designed like any other X client as well. It is
- * driven through handling X events. In contrast to other X clients, a window
- * manager selects for SubstructureRedirectMask on the root window, to receive
- * events about window (dis-)appearance. Only one X connection at a time is
- * allowed to select for this event mask.
- *
- * The event handlers of dwm are organized in an array which is accessed
- * whenever a new event has been fetched. This allows event dispatching
- * in O(1) time.
- *
- * Each child of the root window is called a client, except windows which have
- * set the override_redirect flag. Clients are organized in a linked client
- * list on each monitor, the focus history is remembered through a stack list
- * on each monitor. Each client contains a bit array to indicate the tags of a
- * client.
- *
- * Keys and tagging rules are organized as arrays and defined in config.h.
- *
- * To understand everything else, start reading main().
- */
-#include <errno.h>
-#include <locale.h>
-#include <signal.h>
-#include <stdarg.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <unistd.h>
-#include <sys/types.h>
-#include <sys/wait.h>
-#include <X11/cursorfont.h>
-#include <X11/keysym.h>
-#include <X11/Xatom.h>
-#include <X11/Xlib.h>
-#include <X11/Xproto.h>
-#include <X11/Xutil.h>
-#ifdef XINERAMA
-#include <X11/extensions/Xinerama.h>
-#endif /* XINERAMA */
-#include <X11/Xft/Xft.h>
-
-#include "drw.h"
-#include "util.h"
-
-/* macros */
-#define BUTTONMASK              (ButtonPressMask|ButtonReleaseMask)
-#define CLEANMASK(mask)         (mask & ~(numlockmask|LockMask) & (ShiftMask|ControlMask|Mod1Mask|Mod2Mask|Mod3Mask|Mod4Mask|Mod5Mask))
-#define INTERSECT(x,y,w,h,m)    (MAX(0, MIN((x)+(w),(m)->wx+(m)->ww) - MAX((x),(m)->wx)) \
-                               * MAX(0, MIN((y)+(h),(m)->wy+(m)->wh) - MAX((y),(m)->wy)))
-#define ISVISIBLEONTAG(C, T)    ((C->tags & T))
-#define ISVISIBLE(C)            ISVISIBLEONTAG(C, C->mon->tagset[C->mon->seltags])
-#define LENGTH(X)               (sizeof X / sizeof X[0])
-#define MOUSEMASK               (BUTTONMASK|PointerMotionMask)
-#define WIDTH(X)                ((X)->w + 2 * (X)->bw)
-#define HEIGHT(X)               ((X)->h + 2 * (X)->bw)
-#define TAGMASK                 ((1 << LENGTH(tags)) - 1)
-#define TEXTW(X)                (drw_fontset_getwidth(drw, (X)) + lrpad)
-
-#define SYSTEM_TRAY_REQUEST_DOCK    0
-/* XEMBED messages */
-#define XEMBED_EMBEDDED_NOTIFY      0
-#define XEMBED_WINDOW_ACTIVATE      1
-#define XEMBED_FOCUS_IN             4
-#define XEMBED_MODALITY_ON         10
-#define XEMBED_MAPPED              (1 << 0)
-#define XEMBED_WINDOW_ACTIVATE      1
-#define XEMBED_WINDOW_DEACTIVATE    2
-#define VERSION_MAJOR               0
-#define VERSION_MINOR               0
-#define XEMBED_EMBEDDED_VERSION (VERSION_MAJOR << 16) | VERSION_MINOR
-
-/* enums */
-enum { CurNormal, CurResize, CurMove, CurLast }; /* cursor */
-enum {
-  SchemeNorm,
-  SchemeSel,
-  SchemeTag,
-  SchemeTag1,
-  SchemeTag2,
-  SchemeTag3,
-  SchemeTag4,
-  SchemeTag5,
-  SchemeLayout
-}; /* color schemes */
-enum { NetSupported, NetWMName, NetWMState, NetWMCheck,
-       NetSystemTray, NetSystemTrayOP, NetSystemTrayOrientation, NetSystemTrayOrientationHorz,
-       NetWMFullscreen, NetActiveWindow, NetWMWindowType,
-       NetWMWindowTypeDialog, NetClientList, NetLast }; /* EWMH atoms */
-enum { Manager, Xembed, XembedInfo, XLast }; /* Xembed atoms */
-enum { WMProtocols, WMDelete, WMState, WMTakeFocus, WMLast }; /* default atoms */
-enum { ClkTagBar, ClkLtSymbol, ClkStatusText, ClkWinTitle,
-       ClkClientWin, ClkRootWin, ClkLast }; /* clicks */
-
-typedef union {
-	int i;
-	unsigned int ui;
-	float f;
-	const void *v;
-} Arg;
-
-typedef struct {
-	unsigned int click;
-	unsigned int mask;
-	unsigned int button;
-	void (*func)(const Arg *arg);
-	const Arg arg;
-} Button;
-
-typedef struct Monitor Monitor;
-typedef struct Client Client;
-struct Client {
-	char name[256];
-	float mina, maxa;
-	int x, y, w, h;
-	int oldx, oldy, oldw, oldh;
-	int basew, baseh, incw, inch, maxw, maxh, minw, minh, hintsvalid;
-	int bw, oldbw;
-	unsigned int tags;
-	int isfixed, isfloating, isurgent, neverfocus, oldstate, isfullscreen;
-	Client *next;
-	Client *snext;
-	Monitor *mon;
-	Window win;
-};
-
-typedef struct {
-	unsigned int mod;
-	KeySym keysym;
-	void (*func)(const Arg *);
-	const Arg arg;
-} Key;
-
-typedef struct {
-	const char *symbol;
-	void (*arrange)(Monitor *);
-} Layout;
-
-struct Monitor {
-	char ltsymbol[16];
-	float mfact;
-	int nmaster;
-	int num;
-	int by;               /* bar geometry */
-	int mx, my, mw, mh;   /* screen size */
-	int wx, wy, ww, wh;   /* window area  */
-	int gappih;           /* horizontal gap between windows */
-	int gappiv;           /* vertical gap between windows */
-	int gappoh;           /* horizontal outer gaps */
-	int gappov;           /* vertical outer gaps */
-	unsigned int seltags;
-	unsigned int sellt;
-	unsigned int tagset[2];
-  unsigned int colorfultag;
-	int showbar;
-	int topbar;
-	Client *clients;
-	Client *sel;
-	Client *stack;
-	Monitor *next;
-	Window barwin;
-	const Layout *lt[2];
-};
-
-typedef struct {
-	const char *class;
-	const char *instance;
-	const char *title;
-	unsigned int tags;
-	int isfloating;
-	int monitor;
-} Rule;
-
-typedef struct Systray   Systray;
-struct Systray {
-	Window win;
-	Client *icons;
-};
-
-/* function declarations */
-static void applyrules(Client *c);
-static int applysizehints(Client *c, int *x, int *y, int *w, int *h, int interact);
-static void arrange(Monitor *m);
-static void arrangemon(Monitor *m);
-static void attach(Client *c);
-static void attachaside(Client *c);
-static void attachstack(Client *c);
-static void buttonpress(XEvent *e);
-static void checkotherwm(void);
-static void cleanup(void);
-static void cleanupmon(Monitor *mon);
-static void clientmessage(XEvent *e);
-static void configure(Client *c);
-static void configurenotify(XEvent *e);
-static void configurerequest(XEvent *e);
-static Monitor *createmon(void);
-static void destroynotify(XEvent *e);
-static void detach(Client *c);
-static void detachstack(Client *c);
-static Monitor *dirtomon(int dir);
-static void drawbar(Monitor *m);
-static void drawbars(void);
-static int drawstatusbar(Monitor *m, int bh, char* text);
-static void expose(XEvent *e);
-static void focus(Client *c);
-static void focusin(XEvent *e);
-static void focusmon(const Arg *arg);
-static void focusstack(const Arg *arg);
-static Atom getatomprop(Client *c, Atom prop);
-static int getrootptr(int *x, int *y);
-static long getstate(Window w);
-static unsigned int getsystraywidth();
-static int gettextprop(Window w, Atom atom, char *text, unsigned int size);
-static void grabbuttons(Client *c, int focused);
-static void grabkeys(void);
-static void incnmaster(const Arg *arg);
-static void keypress(XEvent *e);
-static void killclient(const Arg *arg);
-static void manage(Window w, XWindowAttributes *wa);
-static void mappingnotify(XEvent *e);
-static void maprequest(XEvent *e);
-static void monocle(Monitor *m);
-static void movemouse(const Arg *arg);
-static Client *nexttagged(Client *c);
-static Client *nexttiled(Client *c);
-static void pop(Client *c);
-static void propertynotify(XEvent *e);
-static void quit(const Arg *arg);
-static Monitor *recttomon(int x, int y, int w, int h);
-static void removesystrayicon(Client *i);
-static void resize(Client *c, int x, int y, int w, int h, int interact);
-static void resizebarwin(Monitor *m);
-static void resizeclient(Client *c, int x, int y, int w, int h);
-static void resizemouse(const Arg *arg);
-static void resizerequest(XEvent *e);
-static void restack(Monitor *m);
-static void run(void);
-static void runAutostart(void);
-static void scan(void);
-static int sendevent(Window w, Atom proto, int m, long d0, long d1, long d2, long d3, long d4);
-static void sendmon(Client *c, Monitor *m);
-static void setclientstate(Client *c, long state);
-static void setfocus(Client *c);
-static void setfullscreen(Client *c, int fullscreen);
-static void setgaps(int oh, int ov, int ih, int iv);
-static void incrgaps(const Arg *arg);
-static void incrigaps(const Arg *arg);
-static void incrogaps(const Arg *arg);
-static void incrohgaps(const Arg *arg);
-static void incrovgaps(const Arg *arg);
-static void incrihgaps(const Arg *arg);
-static void incrivgaps(const Arg *arg);
-static void togglegaps(const Arg *arg);
-static void defaultgaps(const Arg *arg);
-static void setlayout(const Arg *arg);
-static void setmfact(const Arg *arg);
-static void setup(void);
-static void seturgent(Client *c, int urg);
-static void showhide(Client *c);
-static void spawn(const Arg *arg);
-static Monitor *systraytomon(Monitor *m);
-static void tag(const Arg *arg);
-static void tagmon(const Arg *arg);
-static void tile(Monitor *m);
-static void togglebar(const Arg *arg);
-static void togglefloating(const Arg *arg);
-static void toggletag(const Arg *arg);
-static void toggleview(const Arg *arg);
-static void unfocus(Client *c, int setfocus);
-static void unmanage(Client *c, int destroyed);
-static void unmapnotify(XEvent *e);
-static void updatebarpos(Monitor *m);
-static void updatebars(void);
-static void updateclientlist(void);
-static int updategeom(void);
-static void updatenumlockmask(void);
-static void updatesizehints(Client *c);
-static void updatestatus(void);
-static void updatesystray(void);
-static void updatesystrayicongeom(Client *i, int w, int h);
-static void updatesystrayiconstate(Client *i, XPropertyEvent *ev);
-static void updatetitle(Client *c);
-static void updatewindowtype(Client *c);
-static void updatewmhints(Client *c);
-static void view(const Arg *arg);
-static Client *wintoclient(Window w);
-static Monitor *wintomon(Window w);
-static Client *wintosystrayicon(Window w);
-static int xerror(Display *dpy, XErrorEvent *ee);
-static int xerrordummy(Display *dpy, XErrorEvent *ee);
-static int xerrorstart(Display *dpy, XErrorEvent *ee);
-static void zoom(const Arg *arg);
-
-/* variables */
-static Systray *systray = NULL;
-static const char broken[] = "broken";
-static char stext[1024];
-static int screen;
-static int sw, sh;           /* X display screen geometry width, height */
-static int bh;               /* bar height */
-static int enablegaps = 1;   /* enables gaps, used by togglegaps */
-static int lrpad;            /* sum of left and right padding for text */
-static int (*xerrorxlib)(Display *, XErrorEvent *);
-static unsigned int numlockmask = 0;
-static void (*handler[LASTEvent]) (XEvent *) = {
-	[ButtonPress] = buttonpress,
-	[ClientMessage] = clientmessage,
-	[ConfigureRequest] = configurerequest,
-	[ConfigureNotify] = configurenotify,
-	[DestroyNotify] = destroynotify,
-	[Expose] = expose,
-	[FocusIn] = focusin,
-	[KeyPress] = keypress,
-	[MappingNotify] = mappingnotify,
-	[MapRequest] = maprequest,
-	[PropertyNotify] = propertynotify,
-    [ResizeRequest] = resizerequest,
-	[UnmapNotify] = unmapnotify
-};
-static Atom wmatom[WMLast], netatom[NetLast], xatom[XLast];
-static int running = 1;
-static Cur *cursor[CurLast];
-static Clr **scheme, clrborder;
-static Display *dpy;
-static Drw *drw;
-static Monitor *mons, *selmon;
-static Window root, wmcheckwin;
-
-/* configuration, allows nested code to access above variables */
-#include "config.h"
-
-/* compile-time check if all tags fit into an unsigned int bit array. */
-struct NumTags { char limitexceeded[LENGTH(tags) > 31 ? -1 : 1]; };
-
-/* function implementations */
-void
-applyrules(Client *c)
-{
-	const char *class, *instance;
-	unsigned int i;
-	const Rule *r;
-	Monitor *m;
-	XClassHint ch = { NULL, NULL };
-
-	/* rule matching */
-	c->isfloating = 0;
-	c->tags = 0;
-	XGetClassHint(dpy, c->win, &ch);
-	class    = ch.res_class ? ch.res_class : broken;
-	instance = ch.res_name  ? ch.res_name  : broken;
-
-	for (i = 0; i < LENGTH(rules); i++) {
-		r = &rules[i];
-		if ((!r->title || strstr(c->name, r->title))
-		&& (!r->class || strstr(class, r->class))
-		&& (!r->instance || strstr(instance, r->instance)))
-		{
-			c->isfloating = r->isfloating;
-			c->tags |= r->tags;
-			for (m = mons; m && m->num != r->monitor; m = m->next);
-			if (m)
-				c->mon = m;
-		}
-	}
-	if (ch.res_class)
-		XFree(ch.res_class);
-	if (ch.res_name)
-		XFree(ch.res_name);
-	c->tags = c->tags & TAGMASK ? c->tags & TAGMASK : c->mon->tagset[c->mon->seltags];
-}
-
-int
-applysizehints(Client *c, int *x, int *y, int *w, int *h, int interact)
-{
-	int baseismin;
-	Monitor *m = c->mon;
-
-	/* set minimum possible */
-	*w = MAX(1, *w);
-	*h = MAX(1, *h);
-	if (interact) {
-		if (*x > sw)
-			*x = sw - WIDTH(c);
-		if (*y > sh)
-			*y = sh - HEIGHT(c);
-		if (*x + *w + 2 * c->bw < 0)
-			*x = 0;
-		if (*y + *h + 2 * c->bw < 0)
-			*y = 0;
-	} else {
-		if (*x >= m->wx + m->ww)
-			*x = m->wx + m->ww - WIDTH(c);
-		if (*y >= m->wy + m->wh)
-			*y = m->wy + m->wh - HEIGHT(c);
-		if (*x + *w + 2 * c->bw <= m->wx)
-			*x = m->wx;
-		if (*y + *h + 2 * c->bw <= m->wy)
-			*y = m->wy;
-	}
-	if (*h < bh)
-		*h = bh;
-	if (*w < bh)
-		*w = bh;
-	if (resizehints || c->isfloating || !c->mon->lt[c->mon->sellt]->arrange) {
-		if (!c->hintsvalid)
-			updatesizehints(c);
-		/* see last two sentences in ICCCM 4.1.2.3 */
-		baseismin = c->basew == c->minw && c->baseh == c->minh;
-		if (!baseismin) { /* temporarily remove base dimensions */
-			*w -= c->basew;
-			*h -= c->baseh;
-		}
-		/* adjust for aspect limits */
-		if (c->mina > 0 && c->maxa > 0) {
-			if (c->maxa < (float)*w / *h)
-				*w = *h * c->maxa + 0.5;
-			else if (c->mina < (float)*h / *w)
-				*h = *w * c->mina + 0.5;
-		}
-		if (baseismin) { /* increment calculation requires this */
-			*w -= c->basew;
-			*h -= c->baseh;
-		}
-		/* adjust for increment value */
-		if (c->incw)
-			*w -= *w % c->incw;
-		if (c->inch)
-			*h -= *h % c->inch;
-		/* restore base dimensions */
-		*w = MAX(*w + c->basew, c->minw);
-		*h = MAX(*h + c->baseh, c->minh);
-		if (c->maxw)
-			*w = MIN(*w, c->maxw);
-		if (c->maxh)
-			*h = MIN(*h, c->maxh);
-	}
-	return *x != c->x || *y != c->y || *w != c->w || *h != c->h;
-}
-
-void
-arrange(Monitor *m)
-{
-	if (m)
-		showhide(m->stack);
-	else for (m = mons; m; m = m->next)
-		showhide(m->stack);
-	if (m) {
-		arrangemon(m);
-		restack(m);
-	} else for (m = mons; m; m = m->next)
-		arrangemon(m);
-}
-
-void
-arrangemon(Monitor *m)
-{
-	strncpy(m->ltsymbol, m->lt[m->sellt]->symbol, sizeof m->ltsymbol);
-	if (m->lt[m->sellt]->arrange)
-		m->lt[m->sellt]->arrange(m);
-}
-
-void
-attach(Client *c)
-{
-	c->next = c->mon->clients;
-	c->mon->clients = c;
-}
-
-void
-attachaside(Client *c) {
-	Client *at = nexttagged(c);
-	if(!at) {
-		attach(c);
-		return;
-	}
-	c->next = at->next;
-	at->next = c;
-}
-
-void
-attachstack(Client *c)
-{
-	c->snext = c->mon->stack;
-	c->mon->stack = c;
-}
-
-void
-buttonpress(XEvent *e)
-{
-	unsigned int i, x, click, occ;
-	Arg arg = {0};
-	Client *c;
-	Monitor *m;
-	XButtonPressedEvent *ev = &e->xbutton;
-
-	click = ClkRootWin;
-	/* focus monitor if necessary */
-	if ((m = wintomon(ev->window)) && m != selmon
-	    && (focusonwheel || (ev->button != Button4 && ev->button != Button5))) {
-		unfocus(selmon->sel, 1);
-		selmon = m;
-		focus(NULL);
-	}
-	if (ev->window == selmon->barwin) {
-		i = x = occ = 0;
-		/* Bitmask of occupied tags */
-		for (c = m->clients; c; c = c->next)
-			occ |= c->tags;
-
-		do
-			x += TEXTW(occ & 1 << i ? alttags[i] : tags[i]);
-		while (ev->x >= x && ++i < LENGTH(tags));
-		if (i < LENGTH(tags)) {
-			click = ClkTagBar;
-			arg.ui = 1 << i;
-		} else if (ev->x < x + TEXTW(selmon->ltsymbol))
-			click = ClkLtSymbol;
-		else if (ev->x > selmon->ww - (int)TEXTW(stext) - getsystraywidth())
-			click = ClkStatusText;
-		else
-			click = ClkWinTitle;
-	} else if ((c = wintoclient(ev->window))) {
-		if (focusonwheel || (ev->button != Button4 && ev->button != Button5))
-			focus(c);
-		XAllowEvents(dpy, ReplayPointer, CurrentTime);
-		click = ClkClientWin;
-	}
-	for (i = 0; i < LENGTH(buttons); i++)
-		if (click == buttons[i].click && buttons[i].func && buttons[i].button == ev->button
-		&& CLEANMASK(buttons[i].mask) == CLEANMASK(ev->state))
-			buttons[i].func(click == ClkTagBar && buttons[i].arg.i == 0 ? &arg : &buttons[i].arg);
-}
-
-void
-checkotherwm(void)
-{
-	xerrorxlib = XSetErrorHandler(xerrorstart);
-	/* this causes an error if some other window manager is running */
-	XSelectInput(dpy, DefaultRootWindow(dpy), SubstructureRedirectMask);
-	XSync(dpy, False);
-	XSetErrorHandler(xerror);
-	XSync(dpy, False);
-}
-
-void
-cleanup(void)
-{
-	Arg a = {.ui = ~0};
-	Layout foo = { "", NULL };
-	Monitor *m;
-	size_t i;
-
-	view(&a);
-	selmon->lt[selmon->sellt] = &foo;
-	for (m = mons; m; m = m->next)
-		while (m->stack)
-			unmanage(m->stack, 0);
-	XUngrabKey(dpy, AnyKey, AnyModifier, root);
-	while (mons)
-		cleanupmon(mons);
-
-	if (showsystray) {
-		XUnmapWindow(dpy, systray->win);
-		XDestroyWindow(dpy, systray->win);
-		free(systray);
-	}
-
-    for (i = 0; i < CurLast; i++)
-		drw_cur_free(drw, cursor[i]);
-	for (i = 0; i < LENGTH(colors) + 1; i++)
-		free(scheme[i]);
-	free(scheme);
-	XDestroyWindow(dpy, wmcheckwin);
-	drw_free(drw);
-	XSync(dpy, False);
-	XSetInputFocus(dpy, PointerRoot, RevertToPointerRoot, CurrentTime);
-	XDeleteProperty(dpy, root, netatom[NetActiveWindow]);
-}
-
-void
-cleanupmon(Monitor *mon)
-{
-	Monitor *m;
-
-	if (mon == mons)
-		mons = mons->next;
-	else {
-		for (m = mons; m && m->next != mon; m = m->next);
-		m->next = mon->next;
-	}
-	XUnmapWindow(dpy, mon->barwin);
-	XDestroyWindow(dpy, mon->barwin);
-	free(mon);
-}
-
-void
-clientmessage(XEvent *e)
-{
-	XWindowAttributes wa;
-	XSetWindowAttributes swa;
-	XClientMessageEvent *cme = &e->xclient;
-	Client *c = wintoclient(cme->window);
-
-	if (showsystray && cme->window == systray->win && cme->message_type == netatom[NetSystemTrayOP]) {
-		/* add systray icons */
-		if (cme->data.l[1] == SYSTEM_TRAY_REQUEST_DOCK) {
-			if (!(c = (Client *)calloc(1, sizeof(Client))))
-				die("fatal: could not malloc() %u bytes\n", sizeof(Client));
-			if (!(c->win = cme->data.l[2])) {
-				free(c);
-				return;
-			}
-			c->mon = selmon;
-			c->next = systray->icons;
-			systray->icons = c;
-			if (!XGetWindowAttributes(dpy, c->win, &wa)) {
-				/* use sane defaults */
-				wa.width = bh;
-				wa.height = bh;
-				wa.border_width = 0;
-			}
-			c->x = c->oldx = c->y = c->oldy = 0;
-			c->w = c->oldw = wa.width;
-			c->h = c->oldh = wa.height;
-			c->oldbw = wa.border_width;
-			c->bw = 0;
-			c->isfloating = True;
-			/* reuse tags field as mapped status */
-			c->tags = 1;
-			updatesizehints(c);
-			updatesystrayicongeom(c, wa.width, wa.height);
-			XAddToSaveSet(dpy, c->win);
-			XSelectInput(dpy, c->win, StructureNotifyMask | PropertyChangeMask | ResizeRedirectMask);
-			XReparentWindow(dpy, c->win, systray->win, 0, 0);
-			/* use parents background color */
-			swa.background_pixel  = scheme[SchemeNorm][ColBg].pixel;
-			XChangeWindowAttributes(dpy, c->win, CWBackPixel, &swa);
-			sendevent(c->win, netatom[Xembed], StructureNotifyMask, CurrentTime, XEMBED_EMBEDDED_NOTIFY, 0 , systray->win, XEMBED_EMBEDDED_VERSION);
-			/* FIXME not sure if I have to send these events, too */
-			sendevent(c->win, netatom[Xembed], StructureNotifyMask, CurrentTime, XEMBED_FOCUS_IN, 0 , systray->win, XEMBED_EMBEDDED_VERSION);
-			sendevent(c->win, netatom[Xembed], StructureNotifyMask, CurrentTime, XEMBED_WINDOW_ACTIVATE, 0 , systray->win, XEMBED_EMBEDDED_VERSION);
-			sendevent(c->win, netatom[Xembed], StructureNotifyMask, CurrentTime, XEMBED_MODALITY_ON, 0 , systray->win, XEMBED_EMBEDDED_VERSION);
-			XSync(dpy, False);
-			resizebarwin(selmon);
-			updatesystray();
-			setclientstate(c, NormalState);
-		}
-		return;
-	}
-
-	if (!c)
-		return;
-	if (cme->message_type == netatom[NetWMState]) {
-		if (cme->data.l[1] == netatom[NetWMFullscreen]
-		|| cme->data.l[2] == netatom[NetWMFullscreen])
-			setfullscreen(c, (cme->data.l[0] == 1 /* _NET_WM_STATE_ADD    */
-				|| (cme->data.l[0] == 2 /* _NET_WM_STATE_TOGGLE */ && !c->isfullscreen)));
-	} else if (cme->message_type == netatom[NetActiveWindow]) {
-		if (c != selmon->sel && !c->isurgent)
-			seturgent(c, 1);
-	}
-}
-
-void
-configure(Client *c)
-{
-	XConfigureEvent ce;
-
-	ce.type = ConfigureNotify;
-	ce.display = dpy;
-	ce.event = c->win;
-	ce.window = c->win;
-	ce.x = c->x;
-	ce.y = c->y;
-	ce.width = c->w;
-	ce.height = c->h;
-	ce.border_width = c->bw;
-	ce.above = None;
-	ce.override_redirect = False;
-	XSendEvent(dpy, c->win, False, StructureNotifyMask, (XEvent *)&ce);
-}
-
-void
-configurenotify(XEvent *e)
-{
-	Monitor *m;
-	Client *c;
-	XConfigureEvent *ev = &e->xconfigure;
-	int dirty;
-
-	/* TODO: updategeom handling sucks, needs to be simplified */
-	if (ev->window == root) {
-		dirty = (sw != ev->width || sh != ev->height);
-		sw = ev->width;
-		sh = ev->height;
-		if (updategeom() || dirty) {
-			drw_resize(drw, sw, bh);
-			updatebars();
-			for (m = mons; m; m = m->next) {
-				for (c = m->clients; c; c = c->next)
-					if (c->isfullscreen)
-						resizeclient(c, m->mx, m->my, m->mw, m->mh);
-				resizebarwin(m);
-			}
-			focus(NULL);
-			arrange(NULL);
-		}
-	}
-}
-
-void
-configurerequest(XEvent *e)
-{
-	Client *c;
-	Monitor *m;
-	XConfigureRequestEvent *ev = &e->xconfigurerequest;
-	XWindowChanges wc;
-
-	if ((c = wintoclient(ev->window))) {
-		if (ev->value_mask & CWBorderWidth)
-			c->bw = ev->border_width;
-		else if (c->isfloating || !selmon->lt[selmon->sellt]->arrange) {
-			m = c->mon;
-			if (ev->value_mask & CWX) {
-				c->oldx = c->x;
-				c->x = m->mx + ev->x;
-			}
-			if (ev->value_mask & CWY) {
-				c->oldy = c->y;
-				c->y = m->my + ev->y;
-			}
-			if (ev->value_mask & CWWidth) {
-				c->oldw = c->w;
-				c->w = ev->width;
-			}
-			if (ev->value_mask & CWHeight) {
-				c->oldh = c->h;
-				c->h = ev->height;
-			}
-			if ((c->x + c->w) > m->mx + m->mw && c->isfloating)
-				c->x = m->mx + (m->mw / 2 - WIDTH(c) / 2); /* center in x direction */
-			if ((c->y + c->h) > m->my + m->mh && c->isfloating)
-				c->y = m->my + (m->mh / 2 - HEIGHT(c) / 2); /* center in y direction */
-			if ((ev->value_mask & (CWX|CWY)) && !(ev->value_mask & (CWWidth|CWHeight)))
-				configure(c);
-			if (ISVISIBLE(c))
-				XMoveResizeWindow(dpy, c->win, c->x, c->y, c->w, c->h);
-		} else
-			configure(c);
-	} else {
-		wc.x = ev->x;
-		wc.y = ev->y;
-		wc.width = ev->width;
-		wc.height = ev->height;
-		wc.border_width = ev->border_width;
-		wc.sibling = ev->above;
-		wc.stack_mode = ev->detail;
-		XConfigureWindow(dpy, ev->window, ev->value_mask, &wc);
-	}
-	XSync(dpy, False);
-}
-
-Monitor *
-createmon(void)
-{
-	Monitor *m;
-
-	m = ecalloc(1, sizeof(Monitor));
-	m->tagset[0] = m->tagset[1] = 1;
-	m->mfact = mfact;
-	m->nmaster = nmaster;
-	m->showbar = showbar;
-	m->topbar = topbar;
-  m->colorfultag = colorfultag ? colorfultag : 0;
-	m->gappih = gappih;
-	m->gappiv = gappiv;
-	m->gappoh = gappoh;
-	m->gappov = gappov;
-	m->lt[0] = &layouts[0];
-	m->lt[1] = &layouts[1 % LENGTH(layouts)];
-	strncpy(m->ltsymbol, layouts[0].symbol, sizeof m->ltsymbol);
-	return m;
-}
-
-void
-destroynotify(XEvent *e)
-{
-	Client *c;
-	XDestroyWindowEvent *ev = &e->xdestroywindow;
-
-	if ((c = wintoclient(ev->window)))
-		unmanage(c, 1);
-	else if ((c = wintosystrayicon(ev->window))) {
-		removesystrayicon(c);
-		resizebarwin(selmon);
-		updatesystray();
-	}
-}
-
-void
-detach(Client *c)
-{
-	Client **tc;
-
-	for (tc = &c->mon->clients; *tc && *tc != c; tc = &(*tc)->next);
-	*tc = c->next;
-}
-
-void
-detachstack(Client *c)
-{
-	Client **tc, *t;
-
-	for (tc = &c->mon->stack; *tc && *tc != c; tc = &(*tc)->snext);
-	*tc = c->snext;
-
-	if (c == c->mon->sel) {
-		for (t = c->mon->stack; t && !ISVISIBLE(t); t = t->snext);
-		c->mon->sel = t;
-	}
-}
-
-Monitor *
-dirtomon(int dir)
-{
-	Monitor *m = NULL;
-
-	if (dir > 0) {
-		if (!(m = selmon->next))
-			m = mons;
-	} else if (selmon == mons)
-		for (m = mons; m->next; m = m->next);
-	else
-		for (m = mons; m->next != selmon; m = m->next);
-	return m;
-}
-
-int
-drawstatusbar(Monitor *m, int bh, char* stext) {
-	int ret, i, w, x, len;
-	short isCode = 0;
-	char *text;
-	char *p;
-
-	len = strlen(stext) + 1 ;
-	if (!(text = (char*) malloc(sizeof(char)*len)))
-		die("malloc");
-	p = text;
-	memcpy(text, stext, len);
-
-	/* compute width of the status text */
-	w = 0;
-	i = -1;
-	while (text[++i]) {
-		if (text[i] == '^') {
-			if (!isCode) {
-				isCode = 1;
-				text[i] = '\0';
-				w += TEXTW(text) - lrpad;
-				text[i] = '^';
-				if (text[++i] == 'f')
-					w += atoi(text + ++i);
-			} else {
-				isCode = 0;
-				text = text + i + 1;
-				i = -1;
-			}
-		}
-	}
-	if (!isCode)
-		w += TEXTW(text) - lrpad;
-	else
-		isCode = 0;
-	text = p;
-
-	w += 2; /* 1px padding on both sides */
-	ret = m->ww - w - barpadding;
-	x = m->ww - w - getsystraywidth();
-
-	drw_setscheme(drw, scheme[LENGTH(colors)]);
-	drw->scheme[ColFg] = scheme[SchemeNorm][ColFg];
-	drw->scheme[ColBg] = scheme[SchemeNorm][ColBg];
-	drw_rect(drw, x, barpadding, w, bh, 1, 1);
-	x++;
-
-	/* process status text */
-	i = -1;
-	while (text[++i]) {
-		if (text[i] == '^' && !isCode) {
-			isCode = 1;
-
-			text[i] = '\0';
-			w = TEXTW(text) - lrpad;
-			drw_text(drw, x, barpadding, w, bh, 0, text, 0);
-
-			x += w;
-
-			/* process code */
-			while (text[++i] != '^') {
-				if (text[i] == 'c') {
-					char buf[8];
-					memcpy(buf, (char*)text+i+1, 7);
-					buf[7] = '\0';
-					drw_clr_create(drw, &drw->scheme[ColFg], buf);
-					i += 7;
-				} else if (text[i] == 'b') {
-					char buf[8];
-					memcpy(buf, (char*)text+i+1, 7);
-					buf[7] = '\0';
-					drw_clr_create(drw, &drw->scheme[ColBg], buf);
-					i += 7;
-				} else if (text[i] == 'd') {
-					drw->scheme[ColFg] = scheme[SchemeNorm][ColFg];
-					drw->scheme[ColBg] = scheme[SchemeNorm][ColBg];
-				} else if (text[i] == 'r') {
-					int rx = atoi(text + ++i);
-					while (text[++i] != ',');
-					int ry = atoi(text + ++i);
-					while (text[++i] != ',');
-					int rw = atoi(text + ++i);
-					while (text[++i] != ',');
-					int rh = atoi(text + ++i);
-
-					drw_rect(drw, rx + x, ry + barpadding, rw, rh, 1, 0);
-				} else if (text[i] == 'f') {
-					x += atoi(text + ++i);
-				}
-			}
-
-			text = text + i + 1;
-			i=-1;
-			isCode = 0;
-		}
-	}
-
-	if (!isCode) {
-		w = TEXTW(text) - lrpad;
-		drw_text(drw, x, barpadding, w, bh, 0, text, 0);
-	}
-
-	drw_setscheme(drw, scheme[SchemeNorm]);
-	free(p);
-
-	return ret;
-}
-
-void
-drawbar(Monitor *m)
-{
-	int x, y = barpadding, w, tw = 0, stw = 0;
-	int th = bh - barpadding * 2;
-	int mw = m->ww - barpadding * 2;
-	int boxs = drw->fonts->h / 9;
-	int boxw = drw->fonts->h / 6 + 2;
-	unsigned int i, occ = 0, urg = 0;
-	const char *tagtext;
-	Client *c;
-
-	XSetForeground(drw->dpy, drw->gc, clrborder.pixel);
-	XFillRectangle(drw->dpy, drw->drawable, drw->gc, 0, 0, m->ww, bh);
-
-	if (!m->showbar)
-		return;
-
-	if(showsystray && m == systraytomon(m) && !systrayonleft)
-		stw = getsystraywidth();
-
-	/* draw status first so it can be overdrawn by tags later */
-	if (m == selmon) { /* status is only drawn on selected monitor */
-		tw = mw - drawstatusbar(m, th, stext);
-	}
-
-	resizebarwin(m);
-	for (c = m->clients; c; c = c->next) {
-		occ |= c->tags;
-		if (c->isurgent)
-			urg |= c->tags;
-	}
-	x = barpadding;
-	for (i = 0; i < LENGTH(tags); i++) {
-		tagtext = occ & 1 << i ? alttags[i] : tags[i];
-		w = TEXTW(tagtext);
-    drw_setscheme(drw, scheme[occ & 1 << i ? (m->colorfultag ? tagschemes[i] : SchemeSel) : SchemeTag]);
-		drw_text(drw, x + barpadding, y, w - 2 * barpadding, bh - 2 * barpadding, barpadding, tagtext, urg & 1 << i);
-		if (ulineall || m->tagset[m->seltags] & 1 << i)
-			drw_rect(drw, x + ulinepad, bh - ulinestroke - ulinevoffset, w - (ulinepad * 2), ulinestroke, 1, 0);
-		x += w;
-	}
-	w = TEXTW(m->ltsymbol);
-	drw_setscheme(drw, scheme[SchemeNorm]);
-	x = drw_text(drw, x, y, w, th, lrpad / 2, m->ltsymbol, 0);
-
-	if ((w = mw - tw - stw - x) > th) {
-		if (m->sel) {
-			drw_setscheme(drw, scheme[m == selmon ? SchemeSel : SchemeNorm]);
-			drw_text(drw, x, y, w, th, lrpad / 2, m->sel->name, 0);
-			if (m->sel->isfloating)
-				drw_rect(drw, x + boxs, y + boxs, boxw, boxw, m->sel->isfixed, 0);
-		} else {
-			drw_setscheme(drw, scheme[SchemeNorm]);
-			drw_rect(drw, x, y, w, th, 1, 1);
-		}
-	}
-	drw_map(drw, m->barwin, 0, 0, m->ww - stw, bh);
-}
-
-void
-drawbars(void)
-{
-	Monitor *m;
-
-	for (m = mons; m; m = m->next)
-		drawbar(m);
-}
-
-void
-expose(XEvent *e)
-{
-	Monitor *m;
-	XExposeEvent *ev = &e->xexpose;
-
-	if (ev->count == 0 && (m = wintomon(ev->window))) {
-		drawbar(m);
-		if (m == selmon)
-			updatesystray();
-	}
-}
-
-void
-focus(Client *c)
-{
-	if (!c || !ISVISIBLE(c))
-		for (c = selmon->stack; c && !ISVISIBLE(c); c = c->snext);
-	if (selmon->sel && selmon->sel != c)
-		unfocus(selmon->sel, 0);
-	if (c) {
-		if (c->mon != selmon)
-			selmon = c->mon;
-		if (c->isurgent)
-			seturgent(c, 0);
-		detachstack(c);
-		attachstack(c);
-		grabbuttons(c, 1);
-		XSetWindowBorder(dpy, c->win, scheme[SchemeSel][ColBorder].pixel);
-		setfocus(c);
-	} else {
-		XSetInputFocus(dpy, root, RevertToPointerRoot, CurrentTime);
-		XDeleteProperty(dpy, root, netatom[NetActiveWindow]);
-	}
-	selmon->sel = c;
-	drawbars();
-}
-
-/* there are some broken focus acquiring clients needing extra handling */
-void
-focusin(XEvent *e)
-{
-	XFocusChangeEvent *ev = &e->xfocus;
-
-	if (selmon->sel && ev->window != selmon->sel->win)
-		setfocus(selmon->sel);
-}
-
-void
-focusmon(const Arg *arg)
-{
-	Monitor *m;
-
-	if (!mons->next)
-		return;
-	if ((m = dirtomon(arg->i)) == selmon)
-		return;
-	unfocus(selmon->sel, 0);
-	selmon = m;
-	focus(NULL);
-}
-
-void
-focusstack(const Arg *arg)
-{
-	Client *c = NULL, *i;
-
-	if (!selmon->sel || (selmon->sel->isfullscreen && lockfullscreen))
-		return;
-	if (arg->i > 0) {
-		for (c = selmon->sel->next; c && !ISVISIBLE(c); c = c->next);
-		if (!c)
-			for (c = selmon->clients; c && !ISVISIBLE(c); c = c->next);
-	} else {
-		for (i = selmon->clients; i != selmon->sel; i = i->next)
-			if (ISVISIBLE(i))
-				c = i;
-		if (!c)
-			for (; i; i = i->next)
-				if (ISVISIBLE(i))
-					c = i;
-	}
-	if (c) {
-		focus(c);
-		restack(selmon);
-	}
-}
-
-Atom
-getatomprop(Client *c, Atom prop)
-{
-	int di;
-	unsigned long dl;
-	unsigned char *p = NULL;
-	Atom da, atom = None;
-
-	/* FIXME getatomprop should return the number of items and a pointer to
-	 * the stored data instead of this workaround */
-	Atom req = XA_ATOM;
-	if (prop == xatom[XembedInfo])
-		req = xatom[XembedInfo];
-
-	if (XGetWindowProperty(dpy, c->win, prop, 0L, sizeof atom, False, req,
-		&da, &di, &dl, &dl, &p) == Success && p) {
-		atom = *(Atom *)p;
-		if (da == xatom[XembedInfo] && dl == 2)
-			atom = ((Atom *)p)[1];
-		XFree(p);
-	}
-	return atom;
-}
-
-int
-getrootptr(int *x, int *y)
-{
-	int di;
-	unsigned int dui;
-	Window dummy;
-
-	return XQueryPointer(dpy, root, &dummy, &dummy, x, y, &di, &di, &dui);
-}
-
-long
-getstate(Window w)
-{
-	int format;
-	long result = -1;
-	unsigned char *p = NULL;
-	unsigned long n, extra;
-	Atom real;
-
-	if (XGetWindowProperty(dpy, w, wmatom[WMState], 0L, 2L, False, wmatom[WMState],
-		&real, &format, &n, &extra, (unsigned char **)&p) != Success)
-		return -1;
-	if (n != 0)
-		result = *p;
-	XFree(p);
-	return result;
-}
-
-unsigned int
-getsystraywidth()
-{
-	unsigned int w = 0;
-	Client *i;
-	if(showsystray)
-		for(i = systray->icons; i; w += i->w + systrayspacing, i = i->next) ;
-	return w ? w + systrayspacing : 1;
-}
-
-int
-gettextprop(Window w, Atom atom, char *text, unsigned int size)
-{
-	char **list = NULL;
-	int n;
-	XTextProperty name;
-
-	if (!text || size == 0)
-		return 0;
-	text[0] = '\0';
-	if (!XGetTextProperty(dpy, w, &name, atom) || !name.nitems)
-		return 0;
-	if (name.encoding == XA_STRING) {
-		strncpy(text, (char *)name.value, size - 1);
-	} else if (XmbTextPropertyToTextList(dpy, &name, &list, &n) >= Success && n > 0 && *list) {
-		strncpy(text, *list, size - 1);
-		XFreeStringList(list);
-	}
-	text[size - 1] = '\0';
-	XFree(name.value);
-	return 1;
-}
-
-void
-grabbuttons(Client *c, int focused)
-{
-	updatenumlockmask();
-	{
-		unsigned int i, j;
-		unsigned int modifiers[] = { 0, LockMask, numlockmask, numlockmask|LockMask };
-		XUngrabButton(dpy, AnyButton, AnyModifier, c->win);
-		if (!focused)
-			XGrabButton(dpy, AnyButton, AnyModifier, c->win, False,
-				BUTTONMASK, GrabModeSync, GrabModeSync, None, None);
-		for (i = 0; i < LENGTH(buttons); i++)
-			if (buttons[i].click == ClkClientWin)
-				for (j = 0; j < LENGTH(modifiers); j++)
-					XGrabButton(dpy, buttons[i].button,
-						buttons[i].mask | modifiers[j],
-						c->win, False, BUTTONMASK,
-						GrabModeAsync, GrabModeSync, None, None);
-	}
-}
-
-void
-grabkeys(void)
-{
-	updatenumlockmask();
-	{
-		unsigned int i, j, k;
-		unsigned int modifiers[] = { 0, LockMask, numlockmask, numlockmask|LockMask };
-		int start, end, skip;
-		KeySym *syms;
-
-		XUngrabKey(dpy, AnyKey, AnyModifier, root);
-		XDisplayKeycodes(dpy, &start, &end);
-		syms = XGetKeyboardMapping(dpy, start, end - start + 1, &skip);
-		if (!syms)
-			return;
-		for (k = start; k <= end; k++)
-			for (i = 0; i < LENGTH(keys); i++)
-				/* skip modifier codes, we do that ourselves */
-				if (keys[i].keysym == syms[(k - start) * skip])
-					for (j = 0; j < LENGTH(modifiers); j++)
-						XGrabKey(dpy, k,
-							 keys[i].mod | modifiers[j],
-							 root, True,
-							 GrabModeAsync, GrabModeAsync);
-		XFree(syms);
-	}
-}
-
-void
-incnmaster(const Arg *arg)
-{
-	selmon->nmaster = MAX(selmon->nmaster + arg->i, 0);
-	arrange(selmon);
-}
-
-#ifdef XINERAMA
-static int
-isuniquegeom(XineramaScreenInfo *unique, size_t n, XineramaScreenInfo *info)
-{
-	while (n--)
-		if (unique[n].x_org == info->x_org && unique[n].y_org == info->y_org
-		&& unique[n].width == info->width && unique[n].height == info->height)
-			return 0;
-	return 1;
-}
-#endif /* XINERAMA */
-
-void
-keypress(XEvent *e)
-{
-	unsigned int i;
-	KeySym keysym;
-	XKeyEvent *ev;
-
-	ev = &e->xkey;
-	keysym = XKeycodeToKeysym(dpy, (KeyCode)ev->keycode, 0);
-	for (i = 0; i < LENGTH(keys); i++)
-		if (keysym == keys[i].keysym
-		&& CLEANMASK(keys[i].mod) == CLEANMASK(ev->state)
-		&& keys[i].func)
-			keys[i].func(&(keys[i].arg));
-}
-
-void
-killclient(const Arg *arg)
-{
-	if (!selmon->sel)
-		return;
-
-	if (!sendevent(selmon->sel->win, wmatom[WMDelete], NoEventMask, wmatom[WMDelete], CurrentTime, 0 , 0, 0)) {
-		XGrabServer(dpy);
-		XSetErrorHandler(xerrordummy);
-		XSetCloseDownMode(dpy, DestroyAll);
-		XKillClient(dpy, selmon->sel->win);
-		XSync(dpy, False);
-		XSetErrorHandler(xerror);
-		XUngrabServer(dpy);
-	}
-}
-
-void
-manage(Window w, XWindowAttributes *wa)
-{
-	Client *c, *t = NULL;
-	Window trans = None;
-	XWindowChanges wc;
-
-	c = ecalloc(1, sizeof(Client));
-	c->win = w;
-	/* geometry */
-	c->x = c->oldx = wa->x;
-	c->y = c->oldy = wa->y;
-	c->w = c->oldw = wa->width;
-	c->h = c->oldh = wa->height;
-	c->oldbw = wa->border_width;
-
-	updatetitle(c);
-	if (XGetTransientForHint(dpy, w, &trans) && (t = wintoclient(trans))) {
-		c->mon = t->mon;
-		c->tags = t->tags;
-	} else {
-		c->mon = selmon;
-		applyrules(c);
-	}
-
-	if (c->x + WIDTH(c) > c->mon->wx + c->mon->ww)
-		c->x = c->mon->wx + c->mon->ww - WIDTH(c);
-	if (c->y + HEIGHT(c) > c->mon->wy + c->mon->wh)
-		c->y = c->mon->wy + c->mon->wh - HEIGHT(c);
-	c->x = MAX(c->x, c->mon->wx);
-	c->y = MAX(c->y, c->mon->wy);
-	c->bw = borderpx;
-
-	wc.border_width = c->bw;
-	XConfigureWindow(dpy, w, CWBorderWidth, &wc);
-	XSetWindowBorder(dpy, w, scheme[SchemeNorm][ColBorder].pixel);
-	configure(c); /* propagates border_width, if size doesn't change */
-	updatewindowtype(c);
-	updatesizehints(c);
-	updatewmhints(c);
-	XSelectInput(dpy, w, EnterWindowMask|FocusChangeMask|PropertyChangeMask|StructureNotifyMask);
-	grabbuttons(c, 0);
-	if (!c->isfloating)
-		c->isfloating = c->oldstate = trans != None || c->isfixed;
-	if (c->isfloating)
-		XRaiseWindow(dpy, c->win);
-	attachaside(c);
-	attachstack(c);
-	XChangeProperty(dpy, root, netatom[NetClientList], XA_WINDOW, 32, PropModeAppend,
-		(unsigned char *) &(c->win), 1);
-	XMoveResizeWindow(dpy, c->win, c->x + 2 * sw, c->y, c->w, c->h); /* some windows require this */
-	setclientstate(c, NormalState);
-	if (c->mon == selmon)
-		unfocus(selmon->sel, 0);
-	c->mon->sel = c;
-	arrange(c->mon);
-	XMapWindow(dpy, c->win);
-	focus(NULL);
-}
-
-void
-mappingnotify(XEvent *e)
-{
-	XMappingEvent *ev = &e->xmapping;
-
-	XRefreshKeyboardMapping(ev);
-	if (ev->request == MappingKeyboard)
-		grabkeys();
-}
-
-void
-maprequest(XEvent *e)
-{
-	static XWindowAttributes wa;
-	XMapRequestEvent *ev = &e->xmaprequest;
-
-	Client *i;
-	if ((i = wintosystrayicon(ev->window))) {
-		sendevent(i->win, netatom[Xembed], StructureNotifyMask, CurrentTime, XEMBED_WINDOW_ACTIVATE, 0, systray->win, XEMBED_EMBEDDED_VERSION);
-		resizebarwin(selmon);
-		updatesystray();
-	}
-
-	if (!XGetWindowAttributes(dpy, ev->window, &wa) || wa.override_redirect)
-		return;
-	if (!wintoclient(ev->window))
-		manage(ev->window, &wa);
-}
-
-void
-monocle(Monitor *m)
-{
-	unsigned int n = 0;
-	Client *c;
-
-	for (c = m->clients; c; c = c->next)
-		if (ISVISIBLE(c))
-			n++;
-	if (n > 0) /* override layout symbol */
-		snprintf(m->ltsymbol, sizeof m->ltsymbol, "[%d]", n);
-	for (c = nexttiled(m->clients); c; c = nexttiled(c->next))
-		resize(c, m->wx, m->wy, m->ww - 2 * c->bw, m->wh - 2 * c->bw, 0);
-}
-
-void
-movemouse(const Arg *arg)
-{
-	int x, y, ocx, ocy, nx, ny;
-	Client *c;
-	Monitor *m;
-	XEvent ev;
-	Time lasttime = 0;
-
-	if (!(c = selmon->sel))
-		return;
-	if (c->isfullscreen) /* no support moving fullscreen windows by mouse */
-		return;
-	restack(selmon);
-	ocx = c->x;
-	ocy = c->y;
-	if (XGrabPointer(dpy, root, False, MOUSEMASK, GrabModeAsync, GrabModeAsync,
-		None, cursor[CurMove]->cursor, CurrentTime) != GrabSuccess)
-		return;
-	if (!getrootptr(&x, &y))
-		return;
-	do {
-		XMaskEvent(dpy, MOUSEMASK|ExposureMask|SubstructureRedirectMask, &ev);
-		switch(ev.type) {
-		case ConfigureRequest:
-		case Expose:
-		case MapRequest:
-			handler[ev.type](&ev);
-			break;
-		case MotionNotify:
-			if ((ev.xmotion.time - lasttime) <= (1000 / 60))
-				continue;
-			lasttime = ev.xmotion.time;
-
-			nx = ocx + (ev.xmotion.x - x);
-			ny = ocy + (ev.xmotion.y - y);
-			if (abs(selmon->wx - nx) < snap)
-				nx = selmon->wx;
-			else if (abs((selmon->wx + selmon->ww) - (nx + WIDTH(c))) < snap)
-				nx = selmon->wx + selmon->ww - WIDTH(c);
-			if (abs(selmon->wy - ny) < snap)
-				ny = selmon->wy;
-			else if (abs((selmon->wy + selmon->wh) - (ny + HEIGHT(c))) < snap)
-				ny = selmon->wy + selmon->wh - HEIGHT(c);
-			if (!c->isfloating && selmon->lt[selmon->sellt]->arrange
-			&& (abs(nx - c->x) > snap || abs(ny - c->y) > snap))
-				togglefloating(NULL);
-			if (!selmon->lt[selmon->sellt]->arrange || c->isfloating)
-				resize(c, nx, ny, c->w, c->h, 1);
-			break;
-		}
-	} while (ev.type != ButtonRelease);
-	XUngrabPointer(dpy, CurrentTime);
-	if ((m = recttomon(c->x, c->y, c->w, c->h)) != selmon) {
-		sendmon(c, m);
-		selmon = m;
-		focus(NULL);
-	}
-}
-
-Client *
-nexttagged(Client *c) {
-	Client *walked = c->mon->clients;
-	for(;
-		walked && (walked->isfloating || !ISVISIBLEONTAG(walked, c->tags));
-		walked = walked->next
-	);
-	return walked;
-}
-
-Client *
-nexttiled(Client *c)
-{
-	for (; c && (c->isfloating || !ISVISIBLE(c)); c = c->next);
-	return c;
-}
-
-void
-pop(Client *c)
-{
-	detach(c);
-	attach(c);
-	focus(c);
-	arrange(c->mon);
-}
-
-void
-propertynotify(XEvent *e)
-{
-	Client *c;
-	Window trans;
-	XPropertyEvent *ev = &e->xproperty;
-
-	if ((c = wintosystrayicon(ev->window))) {
-		if (ev->atom == XA_WM_NORMAL_HINTS) {
-			updatesizehints(c);
-			updatesystrayicongeom(c, c->w, c->h);
-		}
-		else
-			updatesystrayiconstate(c, ev);
-		resizebarwin(selmon);
-		updatesystray();
-	}
-
-    if ((ev->window == root) && (ev->atom == XA_WM_NAME))
-		updatestatus();
-	else if (ev->state == PropertyDelete)
-		return; /* ignore */
-	else if ((c = wintoclient(ev->window))) {
-		switch(ev->atom) {
-		default: break;
-		case XA_WM_TRANSIENT_FOR:
-			if (!c->isfloating && (XGetTransientForHint(dpy, c->win, &trans)) &&
-				(c->isfloating = (wintoclient(trans)) != NULL))
-				arrange(c->mon);
-			break;
-		case XA_WM_NORMAL_HINTS:
-			c->hintsvalid = 0;
-			break;
-		case XA_WM_HINTS:
-			updatewmhints(c);
-			drawbars();
-			break;
-		}
-		if (ev->atom == XA_WM_NAME || ev->atom == netatom[NetWMName]) {
-			updatetitle(c);
-			if (c == c->mon->sel)
-				drawbar(c->mon);
-		}
-		if (ev->atom == netatom[NetWMWindowType])
-			updatewindowtype(c);
-	}
-}
-
-void
-quit(const Arg *arg)
-{
-	running = 0;
-}
-
-Monitor *
-recttomon(int x, int y, int w, int h)
-{
-	Monitor *m, *r = selmon;
-	int a, area = 0;
-
-	for (m = mons; m; m = m->next)
-		if ((a = INTERSECT(x, y, w, h, m)) > area) {
-			area = a;
-			r = m;
-		}
-	return r;
-}
-
-void
-removesystrayicon(Client *i)
-{
-	Client **ii;
-
-	if (!showsystray || !i)
-		return;
-	for (ii = &systray->icons; *ii && *ii != i; ii = &(*ii)->next);
-	if (ii)
-		*ii = i->next;
-	free(i);
-}
-
-void
-resize(Client *c, int x, int y, int w, int h, int interact)
-{
-	if (applysizehints(c, &x, &y, &w, &h, interact))
-		resizeclient(c, x, y, w, h);
-}
-
-void
-resizebarwin(Monitor *m) {
-	unsigned int w = m->ww;
-	if (showsystray && m == systraytomon(m) && !systrayonleft)
-		w -= getsystraywidth();
-	XMoveResizeWindow(dpy, m->barwin, m->wx, m->by, w, bh);
-}
-
-void
-resizeclient(Client *c, int x, int y, int w, int h)
-{
-	XWindowChanges wc;
-
-	c->oldx = c->x; c->x = wc.x = x;
-	c->oldy = c->y; c->y = wc.y = y;
-	c->oldw = c->w; c->w = wc.width = w;
-	c->oldh = c->h; c->h = wc.height = h;
-	wc.border_width = c->bw;
-	XConfigureWindow(dpy, c->win, CWX|CWY|CWWidth|CWHeight|CWBorderWidth, &wc);
-	configure(c);
-	XSync(dpy, False);
-}
-
-void
-resizemouse(const Arg *arg)
-{
-	int ocx, ocy, nw, nh;
-	Client *c;
-	Monitor *m;
-	XEvent ev;
-	Time lasttime = 0;
-
-	if (!(c = selmon->sel))
-		return;
-	if (c->isfullscreen) /* no support resizing fullscreen windows by mouse */
-		return;
-	restack(selmon);
-	ocx = c->x;
-	ocy = c->y;
-	if (XGrabPointer(dpy, root, False, MOUSEMASK, GrabModeAsync, GrabModeAsync,
-		None, cursor[CurResize]->cursor, CurrentTime) != GrabSuccess)
-		return;
-	XWarpPointer(dpy, None, c->win, 0, 0, 0, 0, c->w + c->bw - 1, c->h + c->bw - 1);
-	do {
-		XMaskEvent(dpy, MOUSEMASK|ExposureMask|SubstructureRedirectMask, &ev);
-		switch(ev.type) {
-		case ConfigureRequest:
-		case Expose:
-		case MapRequest:
-			handler[ev.type](&ev);
-			break;
-		case MotionNotify:
-			if ((ev.xmotion.time - lasttime) <= (1000 / 60))
-				continue;
-			lasttime = ev.xmotion.time;
-
-			nw = MAX(ev.xmotion.x - ocx - 2 * c->bw + 1, 1);
-			nh = MAX(ev.xmotion.y - ocy - 2 * c->bw + 1, 1);
-			if (c->mon->wx + nw >= selmon->wx && c->mon->wx + nw <= selmon->wx + selmon->ww
-			&& c->mon->wy + nh >= selmon->wy && c->mon->wy + nh <= selmon->wy + selmon->wh)
-			{
-				if (!c->isfloating && selmon->lt[selmon->sellt]->arrange
-				&& (abs(nw - c->w) > snap || abs(nh - c->h) > snap))
-					togglefloating(NULL);
-			}
-			if (!selmon->lt[selmon->sellt]->arrange || c->isfloating)
-				resize(c, c->x, c->y, nw, nh, 1);
-			break;
-		}
-	} while (ev.type != ButtonRelease);
-	XWarpPointer(dpy, None, c->win, 0, 0, 0, 0, c->w + c->bw - 1, c->h + c->bw - 1);
-	XUngrabPointer(dpy, CurrentTime);
-	while (XCheckMaskEvent(dpy, EnterWindowMask, &ev));
-	if ((m = recttomon(c->x, c->y, c->w, c->h)) != selmon) {
-		sendmon(c, m);
-		selmon = m;
-		focus(NULL);
-	}
-}
-
-void
-resizerequest(XEvent *e)
-{
-	XResizeRequestEvent *ev = &e->xresizerequest;
-	Client *i;
-
-	if ((i = wintosystrayicon(ev->window))) {
-		updatesystrayicongeom(i, ev->width, ev->height);
-		resizebarwin(selmon);
-		updatesystray();
-	}
-}
-
-void
-restack(Monitor *m)
-{
-	Client *c;
-	XEvent ev;
-	XWindowChanges wc;
-
-	drawbar(m);
-	if (!m->sel)
-		return;
-	if (m->sel->isfloating || !m->lt[m->sellt]->arrange)
-		XRaiseWindow(dpy, m->sel->win);
-	if (m->lt[m->sellt]->arrange) {
-		wc.stack_mode = Below;
-		wc.sibling = m->barwin;
-		for (c = m->stack; c; c = c->snext)
-			if (!c->isfloating && ISVISIBLE(c)) {
-				XConfigureWindow(dpy, c->win, CWSibling|CWStackMode, &wc);
-				wc.sibling = c->win;
-			}
-	}
-	XSync(dpy, False);
-	while (XCheckMaskEvent(dpy, EnterWindowMask, &ev));
-}
-
-void
-run(void)
-{
-	XEvent ev;
-	/* main event loop */
-	XSync(dpy, False);
-	while (running && !XNextEvent(dpy, &ev))
-		if (handler[ev.type])
-			handler[ev.type](&ev); /* call handler */
-}
-
-void
-runAutostart(void) {
-	system("cd ~/.dwm; ./autostart_blocking.sh");
-	system("cd ~/.dwm; ./autostart.sh &");
-}
-
-void
-scan(void)
-{
-	unsigned int i, num;
-	Window d1, d2, *wins = NULL;
-	XWindowAttributes wa;
-
-	if (XQueryTree(dpy, root, &d1, &d2, &wins, &num)) {
-		for (i = 0; i < num; i++) {
-			if (!XGetWindowAttributes(dpy, wins[i], &wa)
-			|| wa.override_redirect || XGetTransientForHint(dpy, wins[i], &d1))
-				continue;
-			if (wa.map_state == IsViewable || getstate(wins[i]) == IconicState)
-				manage(wins[i], &wa);
-		}
-		for (i = 0; i < num; i++) { /* now the transients */
-			if (!XGetWindowAttributes(dpy, wins[i], &wa))
-				continue;
-			if (XGetTransientForHint(dpy, wins[i], &d1)
-			&& (wa.map_state == IsViewable || getstate(wins[i]) == IconicState))
-				manage(wins[i], &wa);
-		}
-		if (wins)
-			XFree(wins);
-	}
-}
-
-void
-sendmon(Client *c, Monitor *m)
-{
-	if (c->mon == m)
-		return;
-	unfocus(c, 1);
-	detach(c);
-	detachstack(c);
-	c->mon = m;
-	c->tags = m->tagset[m->seltags]; /* assign tags of target monitor */
-	attachaside(c);
-	attachstack(c);
-	focus(NULL);
-	arrange(NULL);
-}
-
-void
-setclientstate(Client *c, long state)
-{
-	long data[] = { state, None };
-
-	XChangeProperty(dpy, c->win, wmatom[WMState], wmatom[WMState], 32,
-		PropModeReplace, (unsigned char *)data, 2);
-}
-
-int
-sendevent(Window w, Atom proto, int mask, long d0, long d1, long d2, long d3, long d4)
-{
-	int n;
-	Atom *protocols, mt;
-	int exists = 0;
-	XEvent ev;
-
-	if (proto == wmatom[WMTakeFocus] || proto == wmatom[WMDelete]) {
-		mt = wmatom[WMProtocols];
-		if (XGetWMProtocols(dpy, w, &protocols, &n)) {
-			while (!exists && n--)
-				exists = protocols[n] == proto;
-			XFree(protocols);
-		}
-	}
-	else {
-		exists = True;
-		mt = proto;
-    }
-
-	if (exists) {
-		ev.type = ClientMessage;
-		ev.xclient.window = w;
-		ev.xclient.message_type = mt;
-		ev.xclient.format = 32;
-		ev.xclient.data.l[0] = d0;
-		ev.xclient.data.l[1] = d1;
-		ev.xclient.data.l[2] = d2;
-		ev.xclient.data.l[3] = d3;
-		ev.xclient.data.l[4] = d4;
-		XSendEvent(dpy, w, False, mask, &ev);
-	}
-	return exists;
-}
-
-void
-setfocus(Client *c)
-{
-	if (!c->neverfocus) {
-		XSetInputFocus(dpy, c->win, RevertToPointerRoot, CurrentTime);
-		XChangeProperty(dpy, root, netatom[NetActiveWindow],
-			XA_WINDOW, 32, PropModeReplace,
-			(unsigned char *) &(c->win), 1);
-	}
-	sendevent(c->win, wmatom[WMTakeFocus], NoEventMask, wmatom[WMTakeFocus], CurrentTime, 0, 0, 0);
-}
-
-void
-setfullscreen(Client *c, int fullscreen)
-{
-	if (fullscreen && !c->isfullscreen) {
-		XChangeProperty(dpy, c->win, netatom[NetWMState], XA_ATOM, 32,
-			PropModeReplace, (unsigned char*)&netatom[NetWMFullscreen], 1);
-		c->isfullscreen = 1;
-		c->oldstate = c->isfloating;
-		c->oldbw = c->bw;
-		c->bw = 0;
-		c->isfloating = 1;
-		resizeclient(c, c->mon->mx, c->mon->my, c->mon->mw, c->mon->mh);
-		XRaiseWindow(dpy, c->win);
-	} else if (!fullscreen && c->isfullscreen){
-		XChangeProperty(dpy, c->win, netatom[NetWMState], XA_ATOM, 32,
-			PropModeReplace, (unsigned char*)0, 0);
-		c->isfullscreen = 0;
-		c->isfloating = c->oldstate;
-		c->bw = c->oldbw;
-		c->x = c->oldx;
-		c->y = c->oldy;
-		c->w = c->oldw;
-		c->h = c->oldh;
-		resizeclient(c, c->x, c->y, c->w, c->h);
-		arrange(c->mon);
-	}
-}
-
-void
-setgaps(int oh, int ov, int ih, int iv)
-{
-	if (oh < 0) oh = 0;
-	if (ov < 0) ov = 0;
-	if (ih < 0) ih = 0;
-	if (iv < 0) iv = 0;
-
-	selmon->gappoh = oh;
-	selmon->gappov = ov;
-	selmon->gappih = ih;
-	selmon->gappiv = iv;
-	arrange(selmon);
-}
-
-void
-togglegaps(const Arg *arg)
-{
-	enablegaps = !enablegaps;
-	arrange(selmon);
-}
-
-void
-defaultgaps(const Arg *arg)
-{
-	setgaps(gappoh, gappov, gappih, gappiv);
-}
-
-void
-incrgaps(const Arg *arg)
-{
-	setgaps(
-		selmon->gappoh + arg->i,
-		selmon->gappov + arg->i,
-		selmon->gappih + arg->i,
-		selmon->gappiv + arg->i
-	);
-}
-
-void
-incrigaps(const Arg *arg)
-{
-	setgaps(
-		selmon->gappoh,
-		selmon->gappov,
-		selmon->gappih + arg->i,
-		selmon->gappiv + arg->i
-	);
-}
-
-void
-incrogaps(const Arg *arg)
-{
-	setgaps(
-		selmon->gappoh + arg->i,
-		selmon->gappov + arg->i,
-		selmon->gappih,
-		selmon->gappiv
-	);
-}
-
-void
-incrohgaps(const Arg *arg)
-{
-	setgaps(
-		selmon->gappoh + arg->i,
-		selmon->gappov,
-		selmon->gappih,
-		selmon->gappiv
-	);
-}
-
-void
-incrovgaps(const Arg *arg)
-{
-	setgaps(
-		selmon->gappoh,
-		selmon->gappov + arg->i,
-		selmon->gappih,
-		selmon->gappiv
-	);
-}
-
-void
-incrihgaps(const Arg *arg)
-{
-	setgaps(
-		selmon->gappoh,
-		selmon->gappov,
-		selmon->gappih + arg->i,
-		selmon->gappiv
-	);
-}
-
-void
-incrivgaps(const Arg *arg)
-{
-	setgaps(
-		selmon->gappoh,
-		selmon->gappov,
-		selmon->gappih,
-		selmon->gappiv + arg->i
-	);
-}
-
-void
-setlayout(const Arg *arg)
-{
-	if (!arg || !arg->v || arg->v != selmon->lt[selmon->sellt])
-		selmon->sellt ^= 1;
-	if (arg && arg->v)
-		selmon->lt[selmon->sellt] = (Layout *)arg->v;
-	strncpy(selmon->ltsymbol, selmon->lt[selmon->sellt]->symbol, sizeof selmon->ltsymbol);
-	if (selmon->sel)
-		arrange(selmon);
-	else
-		drawbar(selmon);
-}
-
-/* arg > 1.0 will set mfact absolutely */
-void
-setmfact(const Arg *arg)
-{
-	float f;
-
-	if (!arg || !selmon->lt[selmon->sellt]->arrange)
-		return;
-	f = arg->f < 1.0 ? arg->f + selmon->mfact : arg->f - 1.0;
-	if (f < 0.05 || f > 0.95)
-		return;
-	selmon->mfact = f;
-	arrange(selmon);
-}
-
-void
-setup(void)
-{
-	int i;
-	XSetWindowAttributes wa;
-	Atom utf8string;
-	struct sigaction sa;
-
-	/* do not transform children into zombies when they terminate */
-	sigemptyset(&sa.sa_mask);
-	sa.sa_flags = SA_NOCLDSTOP | SA_NOCLDWAIT | SA_RESTART;
-	sa.sa_handler = SIG_IGN;
-	sigaction(SIGCHLD, &sa, NULL);
-
-	/* clean up any zombies (inherited from .xinitrc etc) immediately */
-	while (waitpid(-1, NULL, WNOHANG) > 0);
-
-	/* init screen */
-	screen = DefaultScreen(dpy);
-	sw = DisplayWidth(dpy, screen);
-	sh = DisplayHeight(dpy, screen);
-	root = RootWindow(dpy, screen);
-	drw = drw_create(dpy, screen, root, sw, sh);
-	if (!drw_fontset_create(drw, fonts, LENGTH(fonts)))
-		die("no fonts could be loaded.");
-	lrpad = drw->fonts->h;
-	bh = drw->fonts->h + 2 + barpadding * 2;
-	updategeom();
-	/* init atoms */
-	utf8string = XInternAtom(dpy, "UTF8_STRING", False);
-	wmatom[WMProtocols] = XInternAtom(dpy, "WM_PROTOCOLS", False);
-	wmatom[WMDelete] = XInternAtom(dpy, "WM_DELETE_WINDOW", False);
-	wmatom[WMState] = XInternAtom(dpy, "WM_STATE", False);
-	wmatom[WMTakeFocus] = XInternAtom(dpy, "WM_TAKE_FOCUS", False);
-	netatom[NetActiveWindow] = XInternAtom(dpy, "_NET_ACTIVE_WINDOW", False);
-	netatom[NetSupported] = XInternAtom(dpy, "_NET_SUPPORTED", False);
-	netatom[NetSystemTray] = XInternAtom(dpy, "_NET_SYSTEM_TRAY_S0", False);
-	netatom[NetSystemTrayOP] = XInternAtom(dpy, "_NET_SYSTEM_TRAY_OPCODE", False);
-	netatom[NetSystemTrayOrientation] = XInternAtom(dpy, "_NET_SYSTEM_TRAY_ORIENTATION", False);
-	netatom[NetSystemTrayOrientationHorz] = XInternAtom(dpy, "_NET_SYSTEM_TRAY_ORIENTATION_HORZ", False);
-	netatom[NetWMName] = XInternAtom(dpy, "_NET_WM_NAME", False);
-	netatom[NetWMState] = XInternAtom(dpy, "_NET_WM_STATE", False);
-	netatom[NetWMCheck] = XInternAtom(dpy, "_NET_SUPPORTING_WM_CHECK", False);
-	netatom[NetWMFullscreen] = XInternAtom(dpy, "_NET_WM_STATE_FULLSCREEN", False);
-	netatom[NetWMWindowType] = XInternAtom(dpy, "_NET_WM_WINDOW_TYPE", False);
-	netatom[NetWMWindowTypeDialog] = XInternAtom(dpy, "_NET_WM_WINDOW_TYPE_DIALOG", False);
-	netatom[NetClientList] = XInternAtom(dpy, "_NET_CLIENT_LIST", False);
-	xatom[Manager] = XInternAtom(dpy, "MANAGER", False);
-	xatom[Xembed] = XInternAtom(dpy, "_XEMBED", False);
-	xatom[XembedInfo] = XInternAtom(dpy, "_XEMBED_INFO", False);
-	/* init cursors */
-	cursor[CurNormal] = drw_cur_create(drw, XC_left_ptr);
-	cursor[CurResize] = drw_cur_create(drw, XC_sizing);
-	cursor[CurMove] = drw_cur_create(drw, XC_fleur);
-	/* init appearance */
-	scheme = ecalloc(LENGTH(colors) + 1, sizeof(Clr *));
-	scheme[LENGTH(colors)] = drw_scm_create(drw, colors[0], 3);
-	for (i = 0; i < LENGTH(colors); i++)
-		scheme[i] = drw_scm_create(drw, colors[i], 3);
-	drw_clr_create(drw, &clrborder, col_borderbar);
-	/* init system tray */
-	updatesystray();
-	/* init bars */
-	updatebars();
-	updatestatus();
-	/* supporting window for NetWMCheck */
-	wmcheckwin = XCreateSimpleWindow(dpy, root, 0, 0, 1, 1, 0, 0, 0);
-	XChangeProperty(dpy, wmcheckwin, netatom[NetWMCheck], XA_WINDOW, 32,
-		PropModeReplace, (unsigned char *) &wmcheckwin, 1);
-	XChangeProperty(dpy, wmcheckwin, netatom[NetWMName], utf8string, 8,
-		PropModeReplace, (unsigned char *) "dwm", 3);
-	XChangeProperty(dpy, root, netatom[NetWMCheck], XA_WINDOW, 32,
-		PropModeReplace, (unsigned char *) &wmcheckwin, 1);
-	/* EWMH support per view */
-	XChangeProperty(dpy, root, netatom[NetSupported], XA_ATOM, 32,
-		PropModeReplace, (unsigned char *) netatom, NetLast);
-	XDeleteProperty(dpy, root, netatom[NetClientList]);
-	/* select events */
-	wa.cursor = cursor[CurNormal]->cursor;
-	wa.event_mask = SubstructureRedirectMask|SubstructureNotifyMask
-		|ButtonPressMask|PointerMotionMask|EnterWindowMask
-		|LeaveWindowMask|StructureNotifyMask|PropertyChangeMask;
-	XChangeWindowAttributes(dpy, root, CWEventMask|CWCursor, &wa);
-	XSelectInput(dpy, root, wa.event_mask);
-	grabkeys();
-	focus(NULL);
-}
-
-void
-seturgent(Client *c, int urg)
-{
-	XWMHints *wmh;
-
-	c->isurgent = urg;
-	if (!(wmh = XGetWMHints(dpy, c->win)))
-		return;
-	wmh->flags = urg ? (wmh->flags | XUrgencyHint) : (wmh->flags & ~XUrgencyHint);
-	XSetWMHints(dpy, c->win, wmh);
-	XFree(wmh);
-}
-
-void
-showhide(Client *c)
-{
-	if (!c)
-		return;
-	if (ISVISIBLE(c)) {
-		/* show clients top down */
-		XMoveWindow(dpy, c->win, c->x, c->y);
-		if ((!c->mon->lt[c->mon->sellt]->arrange || c->isfloating) && !c->isfullscreen)
-			resize(c, c->x, c->y, c->w, c->h, 0);
-		showhide(c->snext);
-	} else {
-		/* hide clients bottom up */
-		showhide(c->snext);
-		XMoveWindow(dpy, c->win, WIDTH(c) * -2, c->y);
-	}
-}
-
-void
-spawn(const Arg *arg)
-{
-	struct sigaction sa;
-
-	if (arg->v == dmenucmd)
-		dmenumon[0] = '0' + selmon->num;
-	if (fork() == 0) {
-		if (dpy)
-			close(ConnectionNumber(dpy));
-		setsid();
-
-		sigemptyset(&sa.sa_mask);
-		sa.sa_flags = 0;
-		sa.sa_handler = SIG_DFL;
-		sigaction(SIGCHLD, &sa, NULL);
-
-		execvp(((char **)arg->v)[0], (char **)arg->v);
-		die("dwm: execvp '%s' failed:", ((char **)arg->v)[0]);
-	}
-}
-
-void
-tag(const Arg *arg)
-{
-	if (selmon->sel && arg->ui & TAGMASK) {
-		selmon->sel->tags = arg->ui & TAGMASK;
-		focus(NULL);
-		arrange(selmon);
-	}
-}
-
-void
-tagmon(const Arg *arg)
-{
-	if (!selmon->sel || !mons->next)
-		return;
-	sendmon(selmon->sel, dirtomon(arg->i));
-}
-
-void
-tile(Monitor *m)
-{
-	unsigned int i, n, h, r, oe = enablegaps, ie = enablegaps, mw, my, ty;
-	Client *c;
-
-	for (n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next), n++);
-	if (n == 0)
-		return;
-
-	if (smartgaps == n) {
-		oe = 0; // outer gaps disabled
-	}
-
-	if (n > m->nmaster)
-		mw = m->nmaster ? (m->ww + m->gappiv*ie) * m->mfact : 0;
-	else
-		mw = m->ww - 2*m->gappov*oe + m->gappiv*ie;
-	for (i = 0, my = ty = m->gappoh*oe, c = nexttiled(m->clients); c; c = nexttiled(c->next), i++)
-		if (i < m->nmaster) {
-			r = MIN(n, m->nmaster) - i;
-			h = (m->wh - my - m->gappoh*oe - m->gappih*ie * (r - 1)) / r;
-			resize(c, m->wx + m->gappov*oe, m->wy + my, mw - (2*c->bw) - m->gappiv*ie, h - (2*c->bw), 0);
-			if (my + HEIGHT(c) + m->gappih*ie < m->wh)
-			  my += HEIGHT(c) + m->gappih*ie;
-		} else {
-			r = n - i;
-			h = (m->wh - ty - m->gappoh*oe - m->gappih*ie * (r - 1)) / r;
-			resize(c, m->wx + mw + m->gappov*oe, m->wy + ty, m->ww - mw - (2*c->bw) - 2*m->gappov*oe, h - (2*c->bw), 0);
-			if (ty + HEIGHT(c) + m->gappih*ie < m->wh)
-			  ty += HEIGHT(c) + m->gappih*ie;
-		}
-}
-
-void
-togglebar(const Arg *arg)
-{
-	selmon->showbar = !selmon->showbar;
-	updatebarpos(selmon);
-	resizebarwin(selmon);
-	if (showsystray) {
-		XWindowChanges wc;
-		if (!selmon->showbar)
-			wc.y = -bh;
-		else if (selmon->showbar) {
-			wc.y = 0;
-			if (!selmon->topbar)
-				wc.y = selmon->mh - bh;
-		}
-		XConfigureWindow(dpy, systray->win, CWY, &wc);
-	}
-	arrange(selmon);
-}
-
-void
-togglefloating(const Arg *arg)
-{
-	if (!selmon->sel)
-		return;
-	if (selmon->sel->isfullscreen) /* no support for fullscreen windows */
-		return;
-	selmon->sel->isfloating = !selmon->sel->isfloating || selmon->sel->isfixed;
-	if (selmon->sel->isfloating)
-		resize(selmon->sel, selmon->sel->x, selmon->sel->y,
-			selmon->sel->w, selmon->sel->h, 0);
-	arrange(selmon);
-}
-
-void
-toggletag(const Arg *arg)
-{
-	unsigned int newtags;
-
-	if (!selmon->sel)
-		return;
-	newtags = selmon->sel->tags ^ (arg->ui & TAGMASK);
-	if (newtags) {
-		selmon->sel->tags = newtags;
-		focus(NULL);
-		arrange(selmon);
-	}
-}
-
-void
-toggleview(const Arg *arg)
-{
-	unsigned int newtagset = selmon->tagset[selmon->seltags] ^ (arg->ui & TAGMASK);
-
-	if (newtagset) {
-		selmon->tagset[selmon->seltags] = newtagset;
-		focus(NULL);
-		arrange(selmon);
-	}
-}
-
-void
-unfocus(Client *c, int setfocus)
-{
-	if (!c)
-		return;
-	grabbuttons(c, 0);
-	XSetWindowBorder(dpy, c->win, scheme[SchemeNorm][ColBorder].pixel);
-	if (setfocus) {
-		XSetInputFocus(dpy, root, RevertToPointerRoot, CurrentTime);
-		XDeleteProperty(dpy, root, netatom[NetActiveWindow]);
-	}
-}
-
-void
-unmanage(Client *c, int destroyed)
-{
-	Monitor *m = c->mon;
-	XWindowChanges wc;
-
-	detach(c);
-	detachstack(c);
-	if (!destroyed) {
-		wc.border_width = c->oldbw;
-		XGrabServer(dpy); /* avoid race conditions */
-		XSetErrorHandler(xerrordummy);
-		XSelectInput(dpy, c->win, NoEventMask);
-		XConfigureWindow(dpy, c->win, CWBorderWidth, &wc); /* restore border */
-		XUngrabButton(dpy, AnyButton, AnyModifier, c->win);
-		setclientstate(c, WithdrawnState);
-		XSync(dpy, False);
-		XSetErrorHandler(xerror);
-		XUngrabServer(dpy);
-	}
-	free(c);
-	focus(NULL);
-	updateclientlist();
-	arrange(m);
-}
-
-void
-unmapnotify(XEvent *e)
-{
-	Client *c;
-	XUnmapEvent *ev = &e->xunmap;
-
-	if ((c = wintoclient(ev->window))) {
-		if (ev->send_event)
-			setclientstate(c, WithdrawnState);
-		else
-			unmanage(c, 0);
-	}
-	else if ((c = wintosystrayicon(ev->window))) {
-		/* KLUDGE! sometimes icons occasionally unmap their windows, but do
-		 * _not_ destroy them. We map those windows back */
-		XMapRaised(dpy, c->win);
-		updatesystray();
-	}
-}
-
-void
-updatebars(void)
-{
-	unsigned int w;
-	Monitor *m;
-	XSetWindowAttributes wa = {
-		.override_redirect = True,
-		.background_pixmap = ParentRelative,
-		.event_mask = ButtonPressMask|ExposureMask
-	};
-	XClassHint ch = {"dwm", "dwm"};
-	for (m = mons; m; m = m->next) {
-		if (m->barwin)
-			continue;
-		w = m->ww;
-		if (showsystray && m == systraytomon(m))
-			w -= getsystraywidth();
-		m->barwin = XCreateWindow(dpy, root, m->wx, m->by, w, bh, 0, DefaultDepth(dpy, screen),
-				CopyFromParent, DefaultVisual(dpy, screen),
-				CWOverrideRedirect|CWBackPixmap|CWEventMask, &wa);
-		XDefineCursor(dpy, m->barwin, cursor[CurNormal]->cursor);
-		if (showsystray && m == systraytomon(m))
-			XMapRaised(dpy, systray->win);
-		XMapRaised(dpy, m->barwin);
-		XSetClassHint(dpy, m->barwin, &ch);
-	}
-}
-
-void
-updatebarpos(Monitor *m)
-{
-	m->wy = m->my;
-	m->wh = m->mh;
-	if (m->showbar) {
-		m->wh -= bh;
-		m->by = m->topbar ? m->wy : m->wy + m->wh;
-		m->wy = m->topbar ? m->wy + bh : m->wy;
-	} else
-		m->by = -bh;
-}
-
-void
-updateclientlist()
-{
-	Client *c;
-	Monitor *m;
-
-	XDeleteProperty(dpy, root, netatom[NetClientList]);
-	for (m = mons; m; m = m->next)
-		for (c = m->clients; c; c = c->next)
-			XChangeProperty(dpy, root, netatom[NetClientList],
-				XA_WINDOW, 32, PropModeAppend,
-				(unsigned char *) &(c->win), 1);
-}
-
-int
-updategeom(void)
-{
-	int dirty = 0;
-
-#ifdef XINERAMA
-	if (XineramaIsActive(dpy)) {
-		int i, j, n, nn;
-		Client *c;
-		Monitor *m;
-		XineramaScreenInfo *info = XineramaQueryScreens(dpy, &nn);
-		XineramaScreenInfo *unique = NULL;
-
-		for (n = 0, m = mons; m; m = m->next, n++);
-		/* only consider unique geometries as separate screens */
-		unique = ecalloc(nn, sizeof(XineramaScreenInfo));
-		for (i = 0, j = 0; i < nn; i++)
-			if (isuniquegeom(unique, j, &info[i]))
-				memcpy(&unique[j++], &info[i], sizeof(XineramaScreenInfo));
-		XFree(info);
-		nn = j;
-
-		/* new monitors if nn > n */
-		for (i = n; i < nn; i++) {
-			for (m = mons; m && m->next; m = m->next);
-			if (m)
-				m->next = createmon();
-			else
-				mons = createmon();
-		}
-		for (i = 0, m = mons; i < nn && m; m = m->next, i++)
-			if (i >= n
-			|| unique[i].x_org != m->mx || unique[i].y_org != m->my
-			|| unique[i].width != m->mw || unique[i].height != m->mh)
-			{
-				dirty = 1;
-				m->num = i;
-				m->mx = m->wx = unique[i].x_org;
-				m->my = m->wy = unique[i].y_org;
-				m->mw = m->ww = unique[i].width;
-				m->mh = m->wh = unique[i].height;
-				updatebarpos(m);
-			}
-		/* removed monitors if n > nn */
-		for (i = nn; i < n; i++) {
-			for (m = mons; m && m->next; m = m->next);
-			while ((c = m->clients)) {
-				dirty = 1;
-				m->clients = c->next;
-				detachstack(c);
-				c->mon = mons;
-				attachaside(c);
-				attachstack(c);
-			}
-			if (m == selmon)
-				selmon = mons;
-			cleanupmon(m);
-		}
-		free(unique);
-	} else
-#endif /* XINERAMA */
-	{ /* default monitor setup */
-		if (!mons)
-			mons = createmon();
-		if (mons->mw != sw || mons->mh != sh) {
-			dirty = 1;
-			mons->mw = mons->ww = sw;
-			mons->mh = mons->wh = sh;
-			updatebarpos(mons);
-		}
-	}
-	if (dirty) {
-		selmon = mons;
-		selmon = wintomon(root);
-	}
-	return dirty;
-}
-
-void
-updatenumlockmask(void)
-{
-	unsigned int i, j;
-	XModifierKeymap *modmap;
-
-	numlockmask = 0;
-	modmap = XGetModifierMapping(dpy);
-	for (i = 0; i < 8; i++)
-		for (j = 0; j < modmap->max_keypermod; j++)
-			if (modmap->modifiermap[i * modmap->max_keypermod + j]
-				== XKeysymToKeycode(dpy, XK_Num_Lock))
-				numlockmask = (1 << i);
-	XFreeModifiermap(modmap);
-}
-
-void
-updatesizehints(Client *c)
-{
-	long msize;
-	XSizeHints size;
-
-	if (!XGetWMNormalHints(dpy, c->win, &size, &msize))
-		/* size is uninitialized, ensure that size.flags aren't used */
-		size.flags = PSize;
-	if (size.flags & PBaseSize) {
-		c->basew = size.base_width;
-		c->baseh = size.base_height;
-	} else if (size.flags & PMinSize) {
-		c->basew = size.min_width;
-		c->baseh = size.min_height;
-	} else
-		c->basew = c->baseh = 0;
-	if (size.flags & PResizeInc) {
-		c->incw = size.width_inc;
-		c->inch = size.height_inc;
-	} else
-		c->incw = c->inch = 0;
-	if (size.flags & PMaxSize) {
-		c->maxw = size.max_width;
-		c->maxh = size.max_height;
-	} else
-		c->maxw = c->maxh = 0;
-	if (size.flags & PMinSize) {
-		c->minw = size.min_width;
-		c->minh = size.min_height;
-	} else if (size.flags & PBaseSize) {
-		c->minw = size.base_width;
-		c->minh = size.base_height;
-	} else
-		c->minw = c->minh = 0;
-	if (size.flags & PAspect) {
-		c->mina = (float)size.min_aspect.y / size.min_aspect.x;
-		c->maxa = (float)size.max_aspect.x / size.max_aspect.y;
-	} else
-		c->maxa = c->mina = 0.0;
-	c->isfixed = (c->maxw && c->maxh && c->maxw == c->minw && c->maxh == c->minh);
-	c->hintsvalid = 1;
-}
-
-void
-updatestatus(void)
-{
-	if (!gettextprop(root, XA_WM_NAME, stext, sizeof(stext)))
-		strcpy(stext, "dwm-"VERSION);
-	drawbar(selmon);
-	updatesystray();
-}
-
-
-void
-updatesystrayicongeom(Client *i, int w, int h)
-{
-  if (!i)
-    return;
-  applysizehints(i, &(i->x), &(i->y), &(i->w), &(i->h), False);
-  if (systrayiconsize >= bh) {
-    i->w = bh;
-		i->h = bh;
-  } else {
-    i->w = systrayiconsize;
-    i->h = systrayiconsize;
-  }
-}
-
-void
-updatesystrayiconstate(Client *i, XPropertyEvent *ev)
-{
-	long flags;
-	int code = 0;
-
-	if (!showsystray || !i || ev->atom != xatom[XembedInfo] ||
-			!(flags = getatomprop(i, xatom[XembedInfo])))
-		return;
-
-	if (flags & XEMBED_MAPPED && !i->tags) {
-		i->tags = 1;
-		code = XEMBED_WINDOW_ACTIVATE;
-		XMapRaised(dpy, i->win);
-		setclientstate(i, NormalState);
-	}
-	else if (!(flags & XEMBED_MAPPED) && i->tags) {
-		i->tags = 0;
-		code = XEMBED_WINDOW_DEACTIVATE;
-		XUnmapWindow(dpy, i->win);
-		setclientstate(i, WithdrawnState);
-	}
-	else
-		return;
-	sendevent(i->win, xatom[Xembed], StructureNotifyMask, CurrentTime, code, 0,
-			systray->win, XEMBED_EMBEDDED_VERSION);
-}
-
-void
-updatesystray(void)
-{
-	XSetWindowAttributes wa;
-	XWindowChanges wc;
-	Client *i;
-	Monitor *m = systraytomon(NULL);
-	unsigned int x = m->mx + m->mw;
-	unsigned int sw = TEXTW(stext) - lrpad + systrayspacing;
-	unsigned int w = 1;
-
-	if (!showsystray)
-		return;
-	if (systrayonleft)
-		x -= sw + lrpad / 2;
-	if (!systray) {
-		/* init systray */
-		if (!(systray = (Systray *)calloc(1, sizeof(Systray))))
-			die("fatal: could not malloc() %u bytes\n", sizeof(Systray));
-		systray->win = XCreateSimpleWindow(dpy, root, x, m->by, w, bh, 0, 0, scheme[SchemeSel][ColBg].pixel);
-		wa.event_mask        = ButtonPressMask | ExposureMask;
-		wa.override_redirect = True;
-		wa.background_pixel  = scheme[SchemeNorm][ColBg].pixel;
-		XSelectInput(dpy, systray->win, SubstructureNotifyMask);
-		XChangeProperty(dpy, systray->win, netatom[NetSystemTrayOrientation], XA_CARDINAL, 32,
-				PropModeReplace, (unsigned char *)&netatom[NetSystemTrayOrientationHorz], 1);
-		XChangeWindowAttributes(dpy, systray->win, CWEventMask|CWOverrideRedirect|CWBackPixel, &wa);
-		XMapRaised(dpy, systray->win);
-		XSetSelectionOwner(dpy, netatom[NetSystemTray], systray->win, CurrentTime);
-		if (XGetSelectionOwner(dpy, netatom[NetSystemTray]) == systray->win) {
-			sendevent(root, xatom[Manager], StructureNotifyMask, CurrentTime, netatom[NetSystemTray], systray->win, 0, 0);
-			XSync(dpy, False);
-		}
-		else {
-			fprintf(stderr, "dwm: unable to obtain system tray.\n");
-			free(systray);
-			systray = NULL;
-			return;
-		}
-	}
-	for (w = 0, i = systray->icons; i; i = i->next) {
-		/* make sure the background color stays the same */
-		wa.background_pixel  = scheme[SchemeNorm][ColBg].pixel;
-		XChangeWindowAttributes(dpy, i->win, CWBackPixel, &wa);
-		XMapRaised(dpy, i->win);
-		w += systrayspacing;
-		i->x = w;
-    if (systrayiconsize >= bh)
-    i->y = 0;
-    else
-    i->y = (bh - systrayiconsize) / 2;
-    XMoveResizeWindow(dpy, i->win, i->x, i->y, i->w, i->h);
-		w += i->w;
-		if (i->mon != m)
-			i->mon = m;
-	}
-	w = w ? w + systrayspacing : 1;
-	x -= w;
-	XMoveResizeWindow(dpy, systray->win, x, m->by, w, bh);
-	wc.x = x; wc.y = m->by; wc.width = w; wc.height = bh;
-	wc.stack_mode = Above; wc.sibling = m->barwin;
-	XConfigureWindow(dpy, systray->win, CWX|CWY|CWWidth|CWHeight|CWSibling|CWStackMode, &wc);
-	XMapWindow(dpy, systray->win);
-	XMapSubwindows(dpy, systray->win);
-	/* redraw background */
-	XSetForeground(dpy, drw->gc, scheme[SchemeNorm][ColBg].pixel);
-	XFillRectangle(dpy, systray->win, drw->gc, 0, 0, w, bh);
-	XSync(dpy, False);
-}
-
-void
-updatetitle(Client *c)
-{
-	if (!gettextprop(c->win, netatom[NetWMName], c->name, sizeof c->name))
-		gettextprop(c->win, XA_WM_NAME, c->name, sizeof c->name);
-	if (c->name[0] == '\0') /* hack to mark broken clients */
-		strcpy(c->name, broken);
-}
-
-void
-updatewindowtype(Client *c)
-{
-	Atom state = getatomprop(c, netatom[NetWMState]);
-	Atom wtype = getatomprop(c, netatom[NetWMWindowType]);
-
-	if (state == netatom[NetWMFullscreen])
-		setfullscreen(c, 1);
-	if (wtype == netatom[NetWMWindowTypeDialog])
-		c->isfloating = 1;
-}
-
-void
-updatewmhints(Client *c)
-{
-	XWMHints *wmh;
-
-	if ((wmh = XGetWMHints(dpy, c->win))) {
-		if (c == selmon->sel && wmh->flags & XUrgencyHint) {
-			wmh->flags &= ~XUrgencyHint;
-			XSetWMHints(dpy, c->win, wmh);
-		} else
-			c->isurgent = (wmh->flags & XUrgencyHint) ? 1 : 0;
-		if (wmh->flags & InputHint)
-			c->neverfocus = !wmh->input;
-		else
-			c->neverfocus = 0;
-		XFree(wmh);
-	}
-}
-
-void
-view(const Arg *arg)
-{
-	if ((arg->ui & TAGMASK) == selmon->tagset[selmon->seltags])
-		return;
-	selmon->seltags ^= 1; /* toggle sel tagset */
-	if (arg->ui & TAGMASK)
-		selmon->tagset[selmon->seltags] = arg->ui & TAGMASK;
-	focus(NULL);
-	arrange(selmon);
-}
-
-Client *
-wintoclient(Window w)
-{
-	Client *c;
-	Monitor *m;
-
-	for (m = mons; m; m = m->next)
-		for (c = m->clients; c; c = c->next)
-			if (c->win == w)
-				return c;
-	return NULL;
-}
-
-Client *
-wintosystrayicon(Window w) {
-	Client *i = NULL;
-
-	if (!showsystray || !w)
-		return i;
-	for (i = systray->icons; i && i->win != w; i = i->next) ;
-	return i;
-}
-
-Monitor *
-wintomon(Window w)
-{
-	int x, y;
-	Client *c;
-	Monitor *m;
-
-	if (w == root && getrootptr(&x, &y))
-		return recttomon(x, y, 1, 1);
-	for (m = mons; m; m = m->next)
-		if (w == m->barwin)
-			return m;
-	if ((c = wintoclient(w)))
-		return c->mon;
-	return selmon;
-}
-
-/* There's no way to check accesses to destroyed windows, thus those cases are
- * ignored (especially on UnmapNotify's). Other types of errors call Xlibs
- * default error handler, which may call exit. */
-int
-xerror(Display *dpy, XErrorEvent *ee)
-{
-	if (ee->error_code == BadWindow
-	|| (ee->request_code == X_SetInputFocus && ee->error_code == BadMatch)
-	|| (ee->request_code == X_PolyText8 && ee->error_code == BadDrawable)
-	|| (ee->request_code == X_PolyFillRectangle && ee->error_code == BadDrawable)
-	|| (ee->request_code == X_PolySegment && ee->error_code == BadDrawable)
-	|| (ee->request_code == X_ConfigureWindow && ee->error_code == BadMatch)
-	|| (ee->request_code == X_GrabButton && ee->error_code == BadAccess)
-	|| (ee->request_code == X_GrabKey && ee->error_code == BadAccess)
-	|| (ee->request_code == X_CopyArea && ee->error_code == BadDrawable))
-		return 0;
-	fprintf(stderr, "dwm: fatal error: request code=%d, error code=%d\n",
-		ee->request_code, ee->error_code);
-	return xerrorxlib(dpy, ee); /* may call exit */
-}
-
-int
-xerrordummy(Display *dpy, XErrorEvent *ee)
-{
-	return 0;
-}
-
-/* Startup Error handler to check if another window manager
- * is already running. */
-int
-xerrorstart(Display *dpy, XErrorEvent *ee)
-{
-	die("dwm: another window manager is already running");
-	return -1;
-}
-
-Monitor *
-systraytomon(Monitor *m) {
-	Monitor *t;
-	int i, n;
-	if(!systraypinning) {
-		if(!m)
-			return selmon;
-		return m == selmon ? m : NULL;
-	}
-	for(n = 1, t = mons; t && t->next; n++, t = t->next) ;
-	for(i = 1, t = mons; t && t->next && i < systraypinning; i++, t = t->next) ;
-	if(systraypinningfailfirst && n < systraypinning)
-		return mons;
-	return t;
-}
-
-void
-zoom(const Arg *arg)
-{
-	Client *c = selmon->sel;
-
-	if (!selmon->lt[selmon->sellt]->arrange || !c || c->isfloating)
-		return;
-	if (c == nexttiled(selmon->clients) && !(c = nexttiled(c->next)))
-		return;
-	pop(c);
-}
-
-int
-main(int argc, char *argv[])
-{
-	if (argc == 2 && !strcmp("-v", argv[1]))
-		die("dwm-"VERSION);
-	else if (argc != 1)
-		die("usage: dwm [-v]");
-	if (!setlocale(LC_CTYPE, "") || !XSupportsLocale())
-		fputs("warning: no locale support\n", stderr);
-	if (!(dpy = XOpenDisplay(NULL)))
-		die("dwm: cannot open display");
-	checkotherwm();
-	setup();
-#ifdef __OpenBSD__
-	if (pledge("stdio rpath proc exec", NULL) == -1)
-		die("pledge");
-#endif /* __OpenBSD__ */
-	scan();
-	runAutostart();
-	run();
-	cleanup();
-	XCloseDisplay(dpy);
-	return EXIT_SUCCESS;
-}
diff --git a/dwm.o b/dwm.o
index fc29079307b5dd200993d13dded8e805e5ac9717..fda07c535e21a75087ce6efe5cbdba8da7c3e7ff 100644
GIT binary patch
delta 13909
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

delta 13761
zcmZ`<30PIt+CJ+j3VJ|}iJPrxkT~Gb@stB9sFZpjK_MqBiH=2i%Xvt>zlNrEB{HQi
zU3ycK%G+p(h&U(C<`6iSA>z=5)YQy=O_BdwYp*5C)qnQ$@a}!y_xs-Utzl1xGrzQU
z#hKcR+Sn^v=e3ROlI%}xw)pIU;V;K$w{O|Th99!Nj=atHRq<IrRBSm|T^*mbFFxB3
zIa_=W{|56`+F6SAxm({h4dyLi#GIMEZ4KsigOy$4!dd>y@$G7J!v^#2GJW=L-c(lE
z^J$e(-u@A2*tJRP!I9(Rvr_#lnD@LLQw+=1eHCk%g;Z9b$Z7aD14eWWH`y^HV!2s!
z!Z`*bW;6A}u4W@1J|`Keiq8(QlFKTN!2Yfsp?P#feNk*y`DQyLMu!o9_(ya*avc^&
zw<o(`XLJX$7_K9}3eCHj#-`)d)fFcy(Ik7zQZ(F-f3}JPFrb^a$wNJx@`~sccIgNl
z=+>(B!*VMja|4XI`y=z58+jYHKiZi1=XdB%2pI*g9$oDn_Q9wgVfE@Auu6AdfcJW2
z*jxMsw|YEDeuJo(j*Z$~tgasZLVR{CR%5HkD#0RG!<d*Sf^9detLMy&CJp9RGi4oo
z8xvJ`*(uchZ$ep2dolzZv0>zCh>DH$<eaFkzWhXd4?cZUda!YFpMKEQ_ysT-dmFzX
ze>@w>UQEfFGmTN%TNbfhxAbXK{3>?B2eIFhgV3jEQoX6@$ZVWD;lrMh<XhO$GpgZR
z7nrBDMzT_;Jzsel?)F?mYQY!12HFFE&i|{|leOw!EW;X;4kL`pkAC_&5-<x#-d$bM
z?hZ8Q-U7Dw=}E>xRiCcyx?ZWS-WA`ikX0}_ZAg69Ek2}!;<N51S8V&qYQM=AG)jc@
zzM<qtnAW!ij_mTjQDigh?K{-o^w<36{R#<5fRmo?<TN<rkC1zCE<We64~|w>2b`Wf
zJv)SrYj$Uba*)|^#Z`cWC)$1R9qZ7VSy;j4<E*<)b~EC``51C}GZuXoXW==V<d73^
zJ)v#=;Ty1;YzAYX<uj3FGCcFl2xI(Zmc(b!{U=}b@e5)*Y=mvktgIdUOLa9A2Q-1{
z{hj0_WcP12XzZ^z9)Aw6eEL56oJF(vc{?VX@!4zHvQ&$FuCgc2cj~U8cq+GHr|p{}
zI0(;OK32mk?^mJ8GPv8nOWp5^u-3|-AUZLgl)&u7_QVU{Bz|OnqyPpc{Yg$izX5Z}
z7&tg!1UZ=BW?&K_U%(s5ok&mkD)|L+6zZkSBIS^s(u1sqeJPzETm3DT)@|36Mz~7Y
z2vvN*h^$?#+>UIphC=gaTiaWef#=!Z?DkUVI%p}`3B`lV;9@K#G3#1F);zY#Dt>`G
zgW8dp{FZ|swKsWd9oH(B;mXIDitgW7`;hJM!q71C2mH^_R5BBe4+UIxqlSe!-`QVX
zoshkaEtABoanmYJ!Qx>_Bo8hOb2l81njEs?0vw7f&??n!5BL&>r?zW)cc)dbysYh-
z+$27G+BBS`@$gY<hy!Q2BmSYWjes-FfE}q9^1m5A#NJ@iOA|9P#!ebFZnDigF~bYJ
zN0hWn7&j^7jn}>512QJQ9Nur-*va8Z<HnBbKItF-%!qY&>ON`m^wAly&t|+jWwe);
zw<iXKr?tvYPP<q;zt6~LgYlC;ESdOtt>})O^Y=}h=}5@0h3&=#1;1^N3ksc6%M-N9
zZvU)aP-vf^;J6_FzV&MjAVHto`v<MHC*l4%+z-b6^SB=*_A_w*RM4vY1({#@li%~Z
z%|BI(9L{&X`%x_?H%I@+YTImf?BP}@T4*Fp?2Z&}UTbITC)8tte-p3iY+HtVmX*R6
zwawOr4H0fbMEt)XV$q`{6yg>QGZXt*T2E_d%N8;3K;9z5+$q#og}PFxQBc0fAn9;t
zk;~i?Z;5+E%mEQI3*vGNvrd1D9wF4TLLCVcP(3SDx2XKKP#Zuls+W?jq$fpgj!;9P
zB*$<MPO<1&LamEeHrDIog1;vCgCc7enD4u==7jfM_S?hYpYQjB)9(jE@%#P}#UeCV
z?Bmdi*c`UC;&W*Jo%hS^W|jCTcWvviBR^XJ+*oXwjm0QSwTn<&L&Orp?5L?v3AHDr
zpqiqo1BCh_%tn=6{?+X{p}q@wsD7cTuL$)Zl%slDQzr`b5;&=ma8py?6skkahirAO
z;9F|^JA&^96R2Sh*3>0J&464~$7t%uLY)F7sJ^AC-w1UckfnyXSW`C(bqTmpU8kvg
zg?bRYOAY65ntBv+ml}96XIRSd635>;P6G0=K?t~)86<$ClVb~xojCU5n9LA%EDOao
z#iGY>%;dO$<A)so!*M;wJsit8UW2@UyYPm`a{a;ip+OpP4CnYH$9^2W94B&on<M4;
zImdjCyE)=b6n)A$-r-mma+Vw95sr}@yK(FZMax~JKR+JE(aUiZ$LSpBb6m>tbB^md
z?%{Zf;{}d4I1-3kX%IW_QDc7GmSb0r138Z5h;zQuMc(Gei#dMEF`wgRjzt{zay-tl
zl;bZPZ*i>R=m!z24APL}V;sA3?8|Wo$JaPc<T#V#B96;Be#LP!$9)`+b1dWd8^=2w
z>+to_h@sgOZ$S-h{_-TTdGSiaws0QPnxmUz9LE71hjV<9<Lex!ah%OCKm3!Ub@Fe2
zvE2_getXC~if;F+t?j&6$82{DR;+cA<8XNGRB{6P=D7k-Dv|He2?2NmTbdV%PhH#c
zT(C9I0k`uU<P7+&`;7byYt|Wfyl0&YPk>wNT;^FNIX3`5;KurL24eGFqzuO7r;~GV
zIG<%*!s9d0cl}gcX4}>?hpX#daAmy%+7z%BIv0FK&O>Q|hg^V`8$9G9jM?BqT(Q9g
zqc=F<^ad7n2|pd$;0V0t<c;yxeuNH%F7jVUD>MRsL|S&d3#1fcZwejoZlNRag@!d5
zXJA`lI=KwZHhO3bAr2V7F_K(`#T#AZ3hdeF!Q;S99&l`O1m0^@lU501HnFbE+vI|K
zn;fuXQw%=OS0PskA)7t;5|XyrFe{Z3a*dkoGq7N@2S#jmz`4zX$?wp4i;LWZj4e~i
zEhxp~KOu0d3mjV=5WjUa#B6m0ZZ&JNE8*}~!#tySS1RfqsM_iwe?i}EE^-&9Z1W&)
z+s0}=v27t<D>AmbNEIyJ?lMm+4$p_F{-xU&;?v@o?@nP>-yNTk`*3v!PS6gVpdtr^
z6*&SsKUxz{AgRcJL}a}RTMK3ux$vQKO%ZE*Pmu>^U~cHn7;x-#z>7QA)8#nafd%0;
zMwQTEmkZZc+AfwdWmme%-Yw-Eu8gRO41lY<u%KO7(C!!r+l|w<JMy75c=4g=HM>2;
z4{q&FCxI|z&q5Lem-e_w0|?pc!4lK<E+oNlb#FRc+3SGReWNjI&pr<%?!$uj$Kc8v
zvOgU!fCc+Kc!90jzmS}T1qTdr3|1e&>EDmjcpwr7%<ucDcnO*LJzJ}5zW3njzQr;2
zU^=ex6$d?}F<e44pu?ebXn)87OAn2PcX1zl_~Gh5X;stLGmvz6Dn4rMIqV@O1RlY~
zc*GI7v2{&EQy6oE4fP7dAUJ%)AYpKcABX(lA<ZD|2V87FIAHA$k*J^e!9^YgzhVyw
zhooW`#?CA@%rIr7`?am{4udtCI{zWHwAdic;THM?LCX^6JfwuRxuV3t5h*B1M?U1J
z2QlsFRMt9TGe|n-!N|pk&7kxcj`T4HbUe<g8*)4yxq{<Nuj0pPC)n|7#0a>0!a&vU
zqzl{ZeA0ufWai0q@+*{{oJv~2kW((4nR$q%P;km+Mk;;!wPQ`6&Op^Ewi41#Bj#^A
zJ<g5^9nP>t*Y}JEFL(>ic+5a0+15o(zKSsop!3gc$TNN(l=+9Ewp6n23!YtV*`=@;
zHMYIo)!Iw`YwM#eTktHlmEyC~NBk!i-;kR-m4q)Lr_?aF`AFLXq||U9($qtui1QjR
zi@OQ#QUlMSh_m>Z8vSqw*f_H-lB->Os3}~1$%mTB)f^w{8n}TyS}#;KK<fQw3pmU0
zK~&4_B&xcn@h=NLwHq%QANZ~587+7(OeizVZ-mP4VHhE=LVF>%%*ec}<;qbC6R%M$
z>o+B<yWnM84$)S!60hDYG8A6D&`-5^=z7j+F3~*YBmQdeo-@qtnmR+Y7y&uwjLZ=|
zusGagJ+l7S1<&fgh<~!zD}BU&qQsw2;<sz@_xM*vHrok{Z~LI(+M=w>TEYit#y3bQ
zH!?G0tPgs*{}Mbaw+%YUat~?oa)Fj<e0$M)3-OjK{pC>hvv}(aJA;kL22#O!-oWpm
z817=2d0Ml0*Q(f7rtxy5FAJWP?x&RgyB053<sFTe{x<8a8|q$g;@LUjykQO$@8PmD
zheRd#b;<?9d`+mVT{if#N7KQ5!AMxEs6<hZDZE|b&ntYC!e8ZWRS8vA@-s%TtqBxi
zCE>lSPg0eynXTals_li!>TIhxM?=I#Bl9UO_fyNt=25cRDOrP*`1Keod!4Gps}IWQ
zN<6DT`oCiFP<YX4PSRoyiQdhC@{0z+7a#0JjuKO#w7UdSFlGgdA^!pAC4+p!nF7YR
zw<}qNO4c5QXH_j1Eq>2)OSs!lkbB86%eBZ)MdU9$@+yn;{;9-lQd+4}c-G3-BG=v<
zKj6kVcH+n}4Cu|+zh6rlg7+6A!R*b&2Pgb`;nrO6x?4*vUY;+HLlL@l)>L_Rbob#F
zr^QRRXCUIgMna0FvS%Q+4eiZ$f9q+Q;N^;yZm+;>bQ`0oeT3UYA8ymNc<J^Ql%rdg
zrX~uv_k6f5*5akxN{Fj45>{*KVBz+q54SumUb=0DTy!ha)DgmMuMfAwTD){S38d1<
zEY(zbu|Ds^tx}7ZZoe!1PFv0Tyrb}PwV`agZ}DyaHqCx<O#b_V4uYaeBOydnJBiLW
z5xi_do*ofeyezjZMEq(bxHUCKxOMU27OTZew|+1i-I6r*W#RU$54Yi3ymT80<>>Yg
zO`R;<#`<uZqQy(MHzDq_kuXnFX9%}<e7NOk@zU+zkc)1)nmSjw{l|yf8ZBPBZ2)q`
zNZ6*S_pAkA+v&sYfEF*^j)M1!;r&rlYZJ@vtPi(KTKuP?^&1-R5I%oGPNm_l(o~rh
z@RXG<FH%1Xw;;H2#ULS&a@D{WsXWA1oaqYXR}C{pWU<wI8vo?#eVWCaLp0Ar!t*(p
zjq0mD)Umv+Ocp~Z_gSe#rlLn5;j<b_els$^R#aBUT%qO(o^jzg2C}w&TKu~r{+Pzg
z+4)uR308cnExzG{dz3s0gTZ~xz_<0BYxsWrwB^o<P+tvOKoP3#g=$BYMMR3J>cnzM
z9P=>~eK<S^UW|DOQmz~14IcSFJ|f?OJdDZa2t58{9>2y%{CaTSFvu1jxtB${4=Ry$
zlp#1Ocv-((H03<Eg12&C$!)0Q`a$juBf;6n8XxH(C!?|8*{G=RsNEG_eX<@1?%xga
zCP(}V9FI3}Y!5lV<1+30a4XBLkG8o?&HP$ZFADXz#>?8yYrI@2m4atAyOf?9{c2hV
zJlyKAKDV-X7<SW1o`Q&*26+}zZW`{FL_G6xD?Yy|K1`D@JF6iNvu=7US2>chs!;Jy
zGM2&q6(moCN1^<tVYXG&Cls|aS9>WcTbnX>98CCwJ*y&Su2y2y8QCs)S&tmOA2nV+
zzyG4~$FV)OUDJ3Of6L-)PCuDY8{D@HQV&Y7L??J};TI1HmK7U<CzWnI206Ek%$-7&
zh01|DsAQ>MD4tUI0LAT+51%Vayt<UDEWYNYRyJJsnVND-@lcL>2;9KVL@4TCirR&%
zv5I<DQ4^pD2PK)sxQ8e)?B*c-(-i)clKVP1|JNWBAs2BvZ{<xTQoSC`g9#Y(36Ia?
z@w-?&*$?G^8s;4(OI;}`KyDl6Q1K60Hc1zi*53y=s^2K8T3Z2lZyWe6XAWX7j`)uy
zJe~zbh>JMp!VPrzG7(L2WBx%(uh&Dw9V6kcQ1wL+n8cHKRwpH^k>FW8JE!FsM#Jno
zhB;eNS$pzKoez1ag5s%GvJA>m{mMt~I&l7FkWJiSj}M3A%)xz6QPpwoG{EYM?4zve
zb;$k8FlTA%yH>F6Jt#qSu~1oW)N5N2kh^StF~<Fq5~E(XS`GaF+wBS7yM}vg^24e;
z3#JI3wWwa1ma#0dj-mO35~KFCg2x2H4UBBcF@fVSj;A<ogxU8D^Y*h=>#P;^0S0I4
zp5a|Qs76)4C^{;5eI)${Tk(>YeF+piYo)WYiXtGc${<fLG`lIeY(<4REU#z4i81LM
zr!X|B63HCp-E0SxR2lA*N?Vnv%9VM^2R{?M_YL>wL#)=ApL)&tR`9Y%hpaH$29{;+
zQL@<Ms%+~DSMMmQdf{sdIhY$hw5G)tO70Z6ao->_SPaR5h-$<9Oo>#Vq1Ho6wLyMj
zk?t}jrW}oBCAS4H>;FL19|?KYMncD7H8rpwQOK-Bg;&?rn}U~a^83lG#ZF?FpK7XX
zt8j4~G4KaYti|sYXZ1_}<67<{QRiKamve0_E<w-75nIs20Q`qoeqc>k%4s0MdVWPl
z_GsZFHS%Q|%Vc$N%xqL6SJE*|{zJ+353iBy&=pKpZydE<HS%NhFq738{jN)me2P{P
za*Z6MSM6ATH1(@RT=a?^J22P^;#b<EG^rMv97alZAVZP6(V0v>rpVKT%x2~YU4wF9
zh%%vb=>()`MJ?i>KO-!uO(N;nco6uR;(L_F)+R0zK*!W39^#}0?9*9#$s$Aih^v`;
zPYuNe*v8sqe{-nUk33Cc=xU54E$IoCpk6lewS@0zL>)|MNi*tbk?oluZqoWYnpcOk
zBbBtY4h~x}y@d&8tkS{Pl!Ou*TNk5Z>5#g-{&{uDlcW*dRF^#8tf!J=)Oxs)8Px5M
z<=moE{K-Ocg8BvED4e880XRi$jnVl5B$D)^YaS34jAhc2dL#xzW9wn)*NmK24@1w=
z6-W?2dbl1*r-$kxA6*~$IGR=;-;b{3IpTt?5^QW_SQq3EuR3bH{IQt0;6I2TOpEGc
z6X)m+bR-REfCC36T|9_i*Gxibih~&Lclua7dm3h&-gdIaC(>mOf<Hr`<xR;W)DcL+
za0cSS@HmDYucf(oTsS%qhaf`!1njz)59uxWU|JqTjKXt4<TNqm@5t8rJzPjAEeXbx
zB$O86WhFrlNpYQrqi%~!!*w5gaNURFqi94!JZqxF;3R7@4i3r*a&Q)DvaDjQ#><H*
z*7#7Gr`iSkKU|Eo>!|V4E?MJ4sq+!FI!%^#Yc*cl6>EGbouJwU2l%K?<E34)#^Z#k
zc8fImL3J80?TR%%l)4)!oei$%qdJY3cF7taN^?}ZMVkDeI*pfh#Tp+<Z>V;`^?g*Q
z@zO3?<8j@EC@1A2O@2_F#^XsDf+zlLdH{Fk+u~A&zntV7JMGvlZ6S3w#wbeT8spMm
zE}~{>QMq&ilUECQktTmZbD6wG$g4CtkCtE?_Otz|-5~wUk^QX_lEn>KUIFS*FMcUx
zri-(7ye4m<IR^3Ak9DU%p$n-;BSP_p6&_0bo$57`b*c$XLCvfu>S<%O$1h_{4x_V~
z+(gK|H93OjF*!=eFaAv~XAQ4q4UgBfCe&$SYJ^CgugNYNhjM~!c$FqUA=1`re6-*<
zYW&kQ7wz2fLO!R-NrLD7Momun5K5ZhtstG6O>pK%(ge19g-&O?*XS2)H<td$b`xnp
zQ(QZ52&3`LK{1+Mn9`JdWG4mmMl<a7X&I(m+1YT176vpYuhu17>4cWpd-+T0NHM=G
zn*GUNN{`Zb`Ag}!8vid^f_4vnB;6<oJ#dqD?@-bT<(=YIma557)XijhBfPE2Td0@G
zvl1-R$qlT%G_ON*P|lPqdABCZpH2shg(=e-i1)wo8ZS@b`5GT8elERA<Hc=}wr)+F
zro3^U)`E7?l-9&(B2TBu;@5n#mfOP$-)c=>A@~$j*@kotc=21Si~ck!igYEjs5grA
zBCBXF?gCb^FO_lYODj>dUmrmqYfF0CM-e&__hdQEZHvLZX*t{3Xhb{G%YLpN9odfb
z3^+H=%AH2PXotDu4SF7Fl1d}mWAJ$DWxL5V7k4zgJ@Ka%?eVdfAGPT~qR9^G?SOXU
so6(Ouke(r{=2~_gn_K(FxI0R3bs+5mia)lfg*57M?1GJYA1AH<4=qNqo&W#<

diff --git a/util.o b/util.o
index 804cda64c32681fd7c67bca457ae7fd0e6c58bf2..26ab857d2a56ff49969dd1704810e8d70d6b9cca 100644
GIT binary patch
delta 16
XcmdlWxIu735hJsup~2=-Mr(EeE$IZV

delta 16
XcmdlWxIu735hJsOf$8Q_Mr(EeE%*en

-- 
2.48.1

